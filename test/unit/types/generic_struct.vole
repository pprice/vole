// Generic struct type checking tests

// Basic single type parameter struct
struct Box<T> {
    value: T
}

// Two type parameters with same type
struct Pair<T> {
    first: T,
    second: T,
}

// Multiple distinct type parameters
struct Entry<K, V> {
    key: K,
    value: V,
}

// Nested generic struct
struct Outer<T> {
    inner: Box<T>,
}

tests "generic struct basics" {
    test "infer T=i64 from field value" {
        let b = Box { value: 42 }
        assert(b.value == 42)
    }

    test "infer T=string from field value" {
        let b = Box { value: "hello" }
        assert(b.value == "hello")
    }

    test "infer T=bool from field value" {
        let b = Box { value: true }
        assert(b.value == true)
    }

    test "infer T=f64 from field value" {
        let b = Box { value: 3.14 }
        assert(b.value == 3.14)
    }
}

tests "generic struct pair" {
    test "pair of i64" {
        let p = Pair { first: 1, second: 2 }
        assert(p.first == 1)
        assert(p.second == 2)
    }

    test "pair of strings" {
        let p = Pair { first: "a", second: "b" }
        assert(p.first == "a")
        assert(p.second == "b")
    }

    test "pair of booleans" {
        let p = Pair { first: true, second: false }
        assert(p.first == true)
        assert(p.second == false)
    }
}

tests "generic struct multiple type params" {
    test "entry with string key and i64 value" {
        let e = Entry { key: "name", value: 42 }
        assert(e.key == "name")
        assert(e.value == 42)
    }

    test "entry with i64 key and string value" {
        let e = Entry { key: 1, value: "one" }
        assert(e.key == 1)
        assert(e.value == "one")
    }

    test "entry with i64 key and bool value" {
        let e = Entry { key: 0, value: false }
        assert(e.key == 0)
        assert(e.value == false)
    }

    test "entry with f64 key and string value" {
        let e = Entry { key: 3.14, value: "pi" }
        assert(e.key == 3.14)
        assert(e.value == "pi")
    }
}

tests "generic struct explicit type args" {
    test "explicit type arg i64" {
        let b = Box<i64> { value: 42 }
        assert(b.value == 42)
    }

    test "explicit type arg string" {
        let b = Box<string> { value: "hello" }
        assert(b.value == "hello")
    }

    test "explicit type args on pair" {
        let p = Pair<string> { first: "a", second: "b" }
        assert(p.first == "a")
        assert(p.second == "b")
    }

    test "explicit type args on entry" {
        let e = Entry<string, i64> { key: "age", value: 30 }
        assert(e.key == "age")
        assert(e.value == 30)
    }
}

tests "generic struct copy semantics" {
    test "generic struct is value type - copies" {
        let a = Box { value: 10 }
        let b = a
        assert(a.value == 10)
        assert(b.value == 10)
    }

    test "pair copy semantics" {
        let p1 = Pair { first: 1, second: 2 }
        let p2 = p1
        assert(p1.first == 1)
        assert(p2.first == 1)
    }

    test "entry copy semantics" {
        let e1 = Entry { key: "a", value: 1 }
        let e2 = e1
        assert(e1.key == "a")
        assert(e2.value == 1)
    }
}

tests "nested generic structs" {
    test "nested generic struct i64" {
        let o = Outer { inner: Box { value: 42 } }
        assert(o.inner.value == 42)
    }

    test "nested generic struct string" {
        let o = Outer { inner: Box { value: "nested" } }
        assert(o.inner.value == "nested")
    }
}

tests "generic struct field expressions" {
    test "field with arithmetic expression" {
        let b = Box { value: 3 * 14 }
        assert(b.value == 42)
    }

    test "field with string concatenation" {
        let b = Box { value: "he" + "llo" }
        assert(b.value == "hello")
    }

    test "multiple instances with different type params" {
        let int_box = Box { value: 1 }
        let str_box = Box { value: "a" }
        let bool_box = Box { value: true }
        assert(int_box.value == 1)
        assert(str_box.value == "a")
        assert(bool_box.value == true)
    }

    test "entry used in conditional" {
        let e = Entry { key: "enabled", value: true }
        if e.value {
            assert(e.key == "enabled")
        } else {
            assert(false)
        }
    }
}

// Generic struct with instance methods
struct Container<T> {
    item: T,

    func get() -> T {
        return self.item
    }

    func is_same(other: T) -> bool {
        return self.item == other
    }
}

// Generic struct with statics
struct Wrapper<T> {
    inner: T,

    statics {
        func of(v: T) -> Wrapper<T> {
            return Wrapper { inner: v }
        }
    }

    func unwrap() -> T {
        return self.inner
    }
}

// Generic struct with two type params and methods
struct KeyVal<K, V> {
    k: K,
    v: V,

    func get_key() -> K => self.k

    func get_val() -> V => self.v
}

tests "generic struct instance methods" {
    test "instance method returning T with i64" {
        let c = Container { item: 42 }
        assert(c.get() == 42)
    }

    test "instance method returning T with string" {
        let c = Container { item: "hello" }
        assert(c.get() == "hello")
    }

    test "instance method with T parameter" {
        let c = Container { item: 10 }
        assert(c.is_same(10))
        assert(!c.is_same(20))
    }

    test "instance method with string T parameter" {
        let c = Container { item: "abc" }
        assert(c.is_same("abc"))
        assert(!c.is_same("xyz"))
    }

    test "method on multi-param generic struct" {
        let kv = KeyVal { k: "name", v: 42 }
        assert(kv.get_key() == "name")
        assert(kv.get_val() == 42)
    }

    test "method on multi-param generic struct reversed types" {
        let kv = KeyVal { k: 100, v: "hundred" }
        assert(kv.get_key() == 100)
        assert(kv.get_val() == "hundred")
    }

    test "multiple monomorphized method instances coexist" {
        let ci = Container { item: 1 }
        let cs = Container { item: "x" }
        let cb = Container { item: true }
        assert(ci.get() == 1)
        assert(cs.get() == "x")
        assert(cb.get() == true)
    }
}

tests "generic struct static methods" {
    test "static factory method with i64" {
        let w = Wrapper.of(42)
        assert(w.inner == 42)
    }

    test "static factory method with string" {
        let w = Wrapper.of("hello")
        assert(w.inner == "hello")
    }

    test "static factory then instance method" {
        let w = Wrapper.of(99)
        assert(w.unwrap() == 99)
    }

    test "chained static and instance method" {
        assert(Wrapper.of("chain").unwrap() == "chain")
    }

    test "multiple static instantiations coexist" {
        let wi = Wrapper.of(1)
        let ws = Wrapper.of("a")
        let wb = Wrapper.of(true)
        assert(wi.unwrap() == 1)
        assert(ws.unwrap() == "a")
        assert(wb.unwrap() == true)
    }
}

// Free functions taking and returning generic structs
func make_box(v: i64) -> Box<i64> {
    return Box { value: v }
}

func make_str_box(s: string) -> Box<string> {
    return Box { value: s }
}

func unbox_i64(b: Box<i64>) -> i64 {
    return b.value
}

func unbox_str(b: Box<string>) -> string {
    return b.value
}

func swap_pair(p: Pair<i64>) -> Pair<i64> {
    return Pair { first: p.second, second: p.first }
}

tests "generic struct as function param and return" {
    test "return generic struct from function" {
        let b = make_box(42)
        assert(b.value == 42)
    }

    test "return generic struct with string from function" {
        let b = make_str_box("hello")
        assert(b.value == "hello")
    }

    test "pass generic struct to function" {
        let b = Box<i64> { value: 99 }
        assert(unbox_i64(b) == 99)
    }

    test "pass generic struct with string to function" {
        let b = Box<string> { value: "world" }
        assert(unbox_str(b) == "world")
    }

    test "roundtrip generic struct through function" {
        let original = Pair { first: 10, second: 20 }
        let swapped = swap_pair(original)
        assert(swapped.first == 20)
        assert(swapped.second == 10)
    }

    test "multiple generic struct types as function return" {
        let bi = make_box(1)
        let bs = make_str_box("a")
        assert(bi.value == 1)
        assert(bs.value == "a")
    }
}

tests "generic struct in arrays" {
    test "array of Box<i64>" {
        let boxes = [Box { value: 1 }, Box { value: 2 }, Box { value: 3 }]
        assert(boxes.length() == 3)
        assert(boxes[0].value == 1)
        assert(boxes[1].value == 2)
        assert(boxes[2].value == 3)
    }

    test "array of Box<string>" {
        let boxes = [Box { value: "a" }, Box { value: "b" }]
        assert(boxes.length() == 2)
        assert(boxes[0].value == "a")
        assert(boxes[1].value == "b")
    }

    test "array of Pair<i64>" {
        let pairs = [Pair { first: 1, second: 2 }, Pair { first: 3, second: 4 }]
        assert(pairs[0].first == 1)
        assert(pairs[0].second == 2)
        assert(pairs[1].first == 3)
        assert(pairs[1].second == 4)
    }

    test "iterate over array of generic structs" {
        let boxes = [Box { value: 10 }, Box { value: 20 }, Box { value: 30 }]
        var sum = 0
        for b in boxes {
            sum = sum + b.value
        }
        assert(sum == 60)
    }

    test "map over array of generic structs" {
        let boxes = [Box { value: 1 }, Box { value: 2 }, Box { value: 3 }]
        let values = boxes.iter().map((b) => b.value).collect()
        assert(values[0] == 1)
        assert(values[1] == 2)
        assert(values[2] == 3)
    }

    test "filter array of generic structs" {
        let pairs = [
            Pair { first: 1, second: 10 },
            Pair { first: 2, second: 20 },
            Pair { first: 3, second: 30 },
        ]
        let big = pairs.iter().filter((p) => p.first > 1).collect()
        assert(big.length() == 2)
        assert(big[0].first == 2)
        assert(big[1].first == 3)
    }
}
