// Struct instance method tests

struct Point {
    x: i64,
    y: i64,

    func sum() -> i64 {
        return self.x + self.y
    }

    func product() -> i64 => self.x * self.y

    func add_to_x(dx: i64) -> i64 {
        return self.x + dx
    }

    func weighted_sum(wx: i64, wy: i64) -> i64 {
        return self.x * wx + self.y * wy
    }

    func doubled() -> Point {
        return Point { x: self.x * 2, y: self.y * 2 }
    }

    func add(other: Point) -> Point {
        return Point { x: self.x + other.x, y: self.y + other.y }
    }

    func scaled(factor: i64) -> Point => Point { x: self.x * factor, y: self.y * factor }
}

struct Counter {
    value: i64,

    func get() -> i64 => self.value

    func is_zero() -> bool => self.value == 0

    func offset(n: i64) -> i64 => self.value + n
}

tests "struct methods" {
    test "basic method call" {
        let p = Point { x: 3, y: 7 }
        assert(p.sum() == 10)
    }

    test "expression-bodied method" {
        let p = Point { x: 4, y: 5 }
        assert(p.product() == 20)
    }

    test "method with parameter" {
        let p = Point { x: 2, y: 3 }
        assert(p.add_to_x(10) == 12)
    }

    test "method with multiple parameters" {
        let p = Point { x: 3, y: 4 }
        assert(p.weighted_sum(2, 3) == 18)
    }

    test "method on different struct" {
        let c = Counter { value: 42 }
        assert(c.get() == 42)
    }

    test "method returning bool" {
        let c1 = Counter { value: 0 }
        let c2 = Counter { value: 5 }
        assert(c1.is_zero())
        assert(!c2.is_zero())
    }

    test "method with parameter on different struct" {
        let c = Counter { value: 10 }
        assert(c.offset(5) == 15)
    }

    test "method on literal" {
        assert(Point { x: 10, y: 20 }.sum() == 30)
    }

    test "multiple method calls" {
        let p = Point { x: 5, y: 3 }
        assert(p.sum() == 8)
        assert(p.product() == 15)
        assert(p.add_to_x(10) == 15)
    }

    test "method returning struct" {
        let p = Point { x: 3, y: 4 }
        let p2 = p.doubled()
        assert(p2.x == 6)
        assert(p2.y == 8)
    }

    test "method with struct param returning struct" {
        let p1 = Point { x: 1, y: 2 }
        let p2 = Point { x: 10, y: 20 }
        let p3 = p1.add(p2)
        assert(p3.x == 11)
        assert(p3.y == 22)
    }

    test "chained struct method calls" {
        let p = Point { x: 1, y: 1 }
        let p2 = p.doubled().doubled()
        assert(p2.x == 4)
        assert(p2.y == 4)
    }

    test "expression-bodied method returning struct" {
        let p = Point { x: 3, y: 4 }
        let p2 = p.scaled(5)
        assert(p2.x == 15)
        assert(p2.y == 20)
    }

    test "method returning struct then accessing field" {
        assert(Point { x: 5, y: 10 }.doubled().sum() == 30)
    }

    test "chained add methods" {
        let a = Point { x: 1, y: 2 }
        let b = Point { x: 3, y: 4 }
        let c = Point { x: 5, y: 6 }
        let result = a.add(b).add(c)
        assert(result.x == 9)
        assert(result.y == 12)
    }
}
