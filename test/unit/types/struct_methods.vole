// Struct instance method tests

struct Point {
    x: i64,
    y: i64,

    func sum() -> i64 {
        return self.x + self.y
    }

    func product() -> i64 => self.x * self.y

    func add_to_x(dx: i64) -> i64 {
        return self.x + dx
    }

    func weighted_sum(wx: i64, wy: i64) -> i64 {
        return self.x * wx + self.y * wy
    }

    func doubled() -> Point {
        return Point { x: self.x * 2, y: self.y * 2 }
    }

    func add(other: Point) -> Point {
        return Point { x: self.x + other.x, y: self.y + other.y }
    }

    func scaled(factor: i64) -> Point => Point { x: self.x * factor, y: self.y * factor }
}

struct Counter {
    value: i64,

    func get() -> i64 => self.value

    func is_zero() -> bool => self.value == 0

    func offset(n: i64) -> i64 => self.value + n
}

tests "struct methods" {
    test "basic method call" {
        let p = Point { x: 3, y: 7 }
        assert(p.sum() == 10)
    }

    test "expression-bodied method" {
        let p = Point { x: 4, y: 5 }
        assert(p.product() == 20)
    }

    test "method with parameter" {
        let p = Point { x: 2, y: 3 }
        assert(p.add_to_x(10) == 12)
    }

    test "method with multiple parameters" {
        let p = Point { x: 3, y: 4 }
        assert(p.weighted_sum(2, 3) == 18)
    }

    test "method on different struct" {
        let c = Counter { value: 42 }
        assert(c.get() == 42)
    }

    test "method returning bool" {
        let c1 = Counter { value: 0 }
        let c2 = Counter { value: 5 }
        assert(c1.is_zero())
        assert(!c2.is_zero())
    }

    test "method with parameter on different struct" {
        let c = Counter { value: 10 }
        assert(c.offset(5) == 15)
    }

    test "method on literal" {
        assert(Point { x: 10, y: 20 }.sum() == 30)
    }

    test "multiple method calls" {
        let p = Point { x: 5, y: 3 }
        assert(p.sum() == 8)
        assert(p.product() == 15)
        assert(p.add_to_x(10) == 15)
    }

    test "method returning struct" {
        let p = Point { x: 3, y: 4 }
        let p2 = p.doubled()
        assert(p2.x == 6)
        assert(p2.y == 8)
    }

    test "method with struct param returning struct" {
        let p1 = Point { x: 1, y: 2 }
        let p2 = Point { x: 10, y: 20 }
        let p3 = p1.add(p2)
        assert(p3.x == 11)
        assert(p3.y == 22)
    }

    test "chained struct method calls" {
        let p = Point { x: 1, y: 1 }
        let p2 = p.doubled().doubled()
        assert(p2.x == 4)
        assert(p2.y == 4)
    }

    test "expression-bodied method returning struct" {
        let p = Point { x: 3, y: 4 }
        let p2 = p.scaled(5)
        assert(p2.x == 15)
        assert(p2.y == 20)
    }

    test "method returning struct then accessing field" {
        assert(Point { x: 5, y: 10 }.doubled().sum() == 30)
    }

    test "chained add methods" {
        let a = Point { x: 1, y: 2 }
        let b = Point { x: 3, y: 4 }
        let c = Point { x: 5, y: 6 }
        let result = a.add(b).add(c)
        assert(result.x == 9)
        assert(result.y == 12)
    }
}

struct Duration {
    nanos: i64,

    statics {
        func seconds(n: i64) -> Duration {
            return Duration { nanos: n * 1000000000 }
        }

        func zero() -> Duration {
            return Duration { nanos: 0 }
        }

        func from_ms(ms: i64) -> Duration {
            return Duration { nanos: ms * 1000000 }
        }
    }

    func as_ms() -> i64 {
        return self.nanos / 1000000
    }

    func as_nanos() -> i64 => self.nanos
}

struct Vec2 {
    x: f64,
    y: f64,

    statics {
        func origin() -> Vec2 {
            return Vec2 { x: 0.0, y: 0.0 }
        }

        func unit_x() -> Vec2 => Vec2 { x: 1.0, y: 0.0 }

        func unit_y() -> Vec2 => Vec2 { x: 0.0, y: 1.0 }
    }
}

tests "struct static methods" {
    test "basic static method call" {
        let d = Duration.seconds(5)
        assert(d.nanos == 5000000000)
    }

    test "static method returning zero" {
        let d = Duration.zero()
        assert(d.nanos == 0)
    }

    test "static method with parameter" {
        let d = Duration.from_ms(500)
        assert(d.nanos == 500000000)
    }

    test "static then instance method" {
        let d = Duration.seconds(5)
        assert(d.as_ms() == 5000)
    }

    test "chained static and instance method" {
        assert(Duration.seconds(3).as_ms() == 3000)
    }

    test "static method on different struct" {
        let v = Vec2.origin()
        assert(v.x == 0.0)
        assert(v.y == 0.0)
    }

    test "expression-bodied static method" {
        let v = Vec2.unit_x()
        assert(v.x == 1.0)
        assert(v.y == 0.0)
    }

    test "multiple static methods on same struct" {
        let vx = Vec2.unit_x()
        let vy = Vec2.unit_y()
        assert(vx.x == 1.0)
        assert(vy.y == 1.0)
    }

    test "static then instance on expression" {
        assert(Duration.from_ms(1234).as_nanos() == 1234000000)
    }
}
