// Test match on literal values

tests "integer literal patterns" {
    test "match first arm" {
        let x = 1
        let result = match x {
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        }
        assert(result == "one")
    }

    test "match middle arm" {
        let x = 2
        let result = match x {
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        }
        assert(result == "two")
    }

    test "match last literal arm" {
        let x = 3
        let result = match x {
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        }
        assert(result == "three")
    }

    test "match wildcard fallback" {
        let x = 99
        let result = match x {
            1 => "one"
            2 => "two"
            3 => "three"
            _ => "other"
        }
        assert(result == "other")
    }

    test "match without wildcard fallback" {
        let x = 2
        let result = match x {
            1 => "first"
            2 => "second"
        }
        assert(result == "second")
    }

    test "match negative integers" {
        let x = -5
        let result = match x {
            -10 => "minus ten"
            -5 => "minus five"
            0 => "zero"
            5 => "five"
            _ => "other"
        }
        assert(result == "minus five")
    }
}

tests "string literal patterns" {
    test "match string hello" {
        let msg = "hello"
        let result = match msg {
            "hello" => "greeting"
            "bye" => "farewell"
            _ => "unknown"
        }
        assert(result == "greeting")
    }

    test "match string bye" {
        let msg = "bye"
        let result = match msg {
            "hello" => "greeting"
            "bye" => "farewell"
            _ => "unknown"
        }
        assert(result == "farewell")
    }

    test "match string fallback" {
        let msg = "other"
        let result = match msg {
            "hello" => "greeting"
            "bye" => "farewell"
            _ => "unknown"
        }
        assert(result == "unknown")
    }

    test "match empty string" {
        let msg = ""
        let result = match msg {
            "" => "empty"
            "a" => "single"
            _ => "other"
        }
        assert(result == "empty")
    }
}

tests "boolean literal patterns" {
    test "match true" {
        let flag = true
        let result = match flag {
            true => "yes"
            false => "no"
        }
        assert(result == "yes")
    }

    test "match false" {
        let flag = false
        let result = match flag {
            true => "yes"
            false => "no"
        }
        assert(result == "no")
    }
}

tests "raw string literal patterns" {
    test "match raw string with backslashes" {
        let path = @"C:\Windows\System32"
        let result = match path {
            @"C:\Windows\System32" => "system"
            @"C:\Users\Public" => "public"
            _ => "other"
        }
        assert(result == "system")
    }

    test "match raw string with newlines" {
        let text = @"line1\nline2"
        let result = match text {
            @"line1\nline2" => "match"
            _ => "no match"
        }
        assert(result == "match")
    }

    test "raw string fallback" {
        let path = @"D:\Other"
        let result = match path {
            @"C:\Windows" => "windows"
            @"C:\Program Files" => "programs"
            _ => "unknown"
        }
        assert(result == "unknown")
    }

    test "mix regular and raw strings" {
        let s = "test"
        let result = match s {
            @"raw" => "raw match"
            "test" => "regular match"
            _ => "no match"
        }
        assert(result == "regular match")
    }
}

tests "mixed literal patterns" {
    test "literals with guards" {
        let x = 5
        let result = match x {
            1 => "one"
            _ if x > 10 => "big"
            5 => "five"
            _ => "other"
        }
        assert(result == "five")
    }

    test "guard takes precedence over literal" {
        let x = 15
        let result = match x {
            1 => "one"
            _ if x > 10 => "big"
            15 => "fifteen"
            _ => "other"
        }
        assert(result == "big")
    }
}

tests "float literal patterns" {
    test "match float" {
        let x = 3.14
        let result = match x {
            3.14 => "pi"
            2.718 => "e"
            _ => "other"
        }
        assert(result == "pi")
    }

    test "match float fallback" {
        let x = 1.5
        let result = match x {
            3.14 => "pi"
            2.718 => "e"
            _ => "other"
        }
        assert(result == "other")
    }
}

tests "nil literal patterns" {
    test "match nil" {
        let x: i32 | nil = nil
        let result = match x {
            nil => "nothing"
            _ => "something"
        }
        assert(result == "nothing")
    }

    test "match non-nil" {
        let x: i32 | nil = 42
        let result = match x {
            nil => "nothing"
            _ => "something"
        }
        assert(result == "something")
    }
}

tests "edge cases" {
    test "match on expression" {
        let a = 2
        let b = 3
        let result = match a + b {
            4 => "four"
            5 => "five"
            6 => "six"
            _ => "other"
        }
        assert(result == "five")
    }

    test "single arm match" {
        let x = 1
        let result = match x {
            1 => "one"
        }
        assert(result == "one")
    }

    test "match result as return value" {
        func classify(n: i32) -> string {
            return match n {
                0 => "zero"
                1 => "one"
                _ => "many"
            }
        }
        assert(classify(0) == "zero")
        assert(classify(1) == "one")
        assert(classify(5) == "many")
    }

    test "nested match" {
        let x = 1
        let y = 2
        let result = match x {
            1 => match y {
                1 => "one-one"
                2 => "one-two"
                _ => "one-other"
            }
            _ => "other"
        }
        assert(result == "one-two")
    }

    test "wildcard returns explicit nil" {
        // Test that wildcard can return nil explicitly
        let x = 99
        let result: string? = match x {
            1 => "one"
            2 => "two"
            _ => nil
        }
        assert(result == nil)
    }

    test "wildcard nil with type check" {
        // Test type narrowing on wildcard nil result
        let x = 99
        let result: string? = match x {
            1 => "one"
            2 => "two"
            _ => nil
        }
        if result != nil {
            assert(false)  // Should not reach here
        } else {
            assert(true)
        }
    }
}

tests "identifier binding patterns" {
    test "bind value with identifier" {
        let x = 42
        let result = match x {
            n => n * 2
        }
        assert(result == 84)
    }

    test "identifier after literals" {
        let x = 5
        let result = match x {
            1 => 100
            2 => 200
            n => n * 10
        }
        assert(result == 50)
    }

    test "identifier catches unmatched" {
        let x = 99
        let result = match x {
            1 => 1
            2 => 2
            other => other
        }
        assert(result == 99)
    }

    test "identifier with string match" {
        let s = "hello"
        let result = match s {
            "hi" => "greeting"
            "bye" => "farewell"
            msg => msg
        }
        assert(result == "hello")
    }
}

tests "mixed type and literal patterns" {
    test "literal then type pattern" {
        let x: i32 | string = 1
        let result = match x {
            1 => "one"
            2 => "two"
            string => "text"
            _ => "other"
        }
        assert(result == "one")
    }

    test "type pattern matches variant" {
        let x: i32 | string = "hello"
        let result = match x {
            1 => "one"
            2 => "two"
            string => "text"
            _ => "other"
        }
        assert(result == "text")
    }

    test "string literal in union" {
        let x: i32 | string = "hello"
        let result = match x {
            "hello" => "greeting"
            i32 => "number"
            _ => "other string"
        }
        assert(result == "greeting")
    }

    test "cross-type literal no match" {
        let x: i32 | string = 42
        let result = match x {
            "42" => "string forty-two"
            42 => "int forty-two"
            _ => "other"
        }
        assert(result == "int forty-two")
    }

    test "three way union" {
        let x: i32 | string | bool = true
        let result = match x {
            1 => "one"
            "yes" => "affirmative"
            true => "truthy"
            _ => "other"
        }
        assert(result == "truthy")
    }
}

tests "function calls in match arms" {
    func double(x: i32) -> i32 { return x * 2 }
    func greet(name: string) -> string { return "Hello, {name}!" }

    test "call function in arm body" {
        let x = 5
        let result = match x {
            1 => double(10)
            5 => double(x)
            _ => 0
        }
        assert(result == 10)
    }

    test "call function returning string" {
        let x = 1
        let result = match x {
            1 => greet("World")
            _ => "default"
        }
        assert(result == "Hello, World!")
    }
}

tests "match on expressions and calls" {
    func getValue() -> i32 { return 42 }
    func getUnion() -> i32 | string { return "test" }

    test "match on function result" {
        let result = match getValue() {
            42 => "the answer"
            _ => "other"
        }
        assert(result == "the answer")
    }

    test "match on union function result" {
        let result = match getUnion() {
            i32 => "got int"
            string => "got string"
        }
        assert(result == "got string")
    }

    test "match on method call" {
        let arr = [1, 2, 3]
        let result = match arr.length {
            0 => "empty"
            3 => "three"
            _ => "other"
        }
        assert(result == "three")
    }

    test "triple nested match" {
        let x = 1
        let y = 2
        let z = 3
        let result = match x {
            1 => match y {
                2 => match z {
                    3 => "all match"
                    _ => "z fail"
                }
                _ => "y fail"
            }
            _ => "x fail"
        }
        assert(result == "all match")
    }
}
