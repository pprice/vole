// Comprehensive error handling tests
// Tests for: error declarations, raise, try propagation, and fallible match patterns
//
// NOTE: Some tests use workarounds for current implementation limitations:
// - Wildcard patterns are added because exhaustiveness check doesn't recognize
//   success + error as exhaustive for fallible types
// - All match arms use i64 literals to avoid type mismatch errors

// Error type declarations
error DivByZero {}
error Overflow { value: i64, max: i64 }
error NotFound { key: string }
error Timeout { ms: i64 }

// Basic fallible function with i64
func divide(a: i64, b: i64) -> fallible(i64, DivByZero) {
    if b == 0 {
        raise DivByZero {}
    }
    return a / b
}

// Fallible function with data in error
func checkOverflow(value: i64, max: i64) -> fallible(i64, Overflow) {
    if value > max {
        raise Overflow { value: value, max: max }
    }
    return value
}

// Function with multiple error types
func complexOp(x: i64) -> fallible(i64, NotFound | Timeout) {
    if x < 0 {
        raise NotFound { key: "negative" }
    }
    if x > 100 {
        raise Timeout { ms: x }
    }
    return x * 2
}

// Try propagation - single error type
func processDivide(a: i64, b: i64, c: i64) -> fallible(i64, DivByZero) {
    let x = try divide(a, b)
    let y = try divide(x, c)
    return y
}

// Try propagation - chained operations
func chainedDivide(a: i64, b: i64, c: i64, d: i64) -> fallible(i64, DivByZero) {
    let step1 = try divide(a, b)
    let step2 = try divide(step1, c)
    let step3 = try divide(step2, d)
    return step3
}

// Try propagation - mixed with normal expressions
func mixedOps(a: i64, b: i64) -> fallible(i64, DivByZero) {
    let x = try divide(a, b)
    let y = x + 10  // normal operation
    let z = try divide(y, 2)
    return z * 3
}

tests "error declaration and raising" {
    test "basic success" {
        let result = match divide(10, 2) {
            success x => x
            error => -999
            _ => -888
        }
        assert(result == 5)
    }

    test "basic error" {
        let result = match divide(10, 0) {
            success x => x
            error => -999
            _ => -888
        }
        assert(result == -999)
    }

    test "error with data" {
        let result = match checkOverflow(150, 100) {
            success x => x
            Overflow => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "success with data error type" {
        let result = match checkOverflow(50, 100) {
            success x => x
            error => -999
            _ => -888
        }
        assert(result == 50)
    }
}

tests "try propagation operator" {
    test "try propagates success" {
        let result = match processDivide(100, 2, 5) {
            success x => x
            error => -999
            _ => -888
        }
        assert(result == 10)  // 100/2=50, 50/5=10
    }

    test "try propagates first error" {
        let result = match processDivide(100, 0, 5) {
            success x => x
            DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "try propagates second error" {
        let result = match processDivide(100, 2, 0) {
            success x => x
            DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "chained try all success" {
        let result = match chainedDivide(1000, 2, 5, 10) {
            success x => x
            error => -999
            _ => -888
        }
        assert(result == 10)  // 1000/2=500, 500/5=100, 100/10=10
    }

    test "chained try early failure" {
        let result = match chainedDivide(1000, 0, 5, 10) {
            success x => x
            DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "chained try late failure" {
        let result = match chainedDivide(1000, 2, 5, 0) {
            success x => x
            DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "mixed operations with try" {
        let result = match mixedOps(20, 2) {
            success x => x
            error => -999
            _ => -888
        }
        // mixedOps: x = a/b, y = x+10, z = y/2, return z*3
        // a=20, b=2: x=10, y=20, z=10, return 30
        assert(result == 30)
    }
}

tests "explicit success keyword" {
    test "success with binding" {
        let result = match divide(10, 2) {
            success x => x + 100
            error => 0
            _ => -888
        }
        assert(result == 105)
    }

    test "success without binding" {
        let result = match divide(10, 2) {
            success => 42
            error => 0
            _ => -888
        }
        assert(result == 42)
    }
}

tests "error pattern variations" {
    test "bare error catchall" {
        let result = match divide(10, 0) {
            success x => x
            error => -1
            _ => -888
        }
        assert(result == -1)
    }

    test "error with identifier binding" {
        let result = match divide(10, 0) {
            success x => x
            error e => -1
            _ => -888
        }
        assert(result == -1)
    }

    test "specific error type pattern" {
        // NOTE: error keyword is REQUIRED to match specific error types
        // Without 'error', 'DivByZero => -1' would be an identifier binding, not a type match
        let result = match divide(10, 0) {
            success x => x
            error DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "multiple specific error types in union" {
        // Test that specific error patterns correctly match in unions
        let r1 = match complexOp(-5) {
            success x => x
            error NotFound => -1
            error Timeout => -2
            error => -999
            _ => -888
        }
        assert(r1 == -1)  // NotFound should match

        let r2 = match complexOp(150) {
            success x => x
            error NotFound => -1
            error Timeout => -2
            error => -999
            _ => -888
        }
        assert(r2 == -2)  // Timeout should match
    }

    test "error catchall with union type" {
        // Test that error catchall works for any error in union
        let r1 = match complexOp(-5) {
            success x => x
            error => -1
            _ => -888
        }
        assert(r1 == -1)

        let r2 = match complexOp(150) {
            success x => x
            error => -2
            _ => -888
        }
        assert(r2 == -2)

        // Test success
        let r3 = match complexOp(25) {
            success x => x
            error => -999
            _ => -888
        }
        assert(r3 == 50)  // 25 * 2 = 50
    }
}

tests "match arm ordering" {
    test "success before error" {
        let result = match divide(10, 2) {
            success x => x
            error => -1
            _ => -888
        }
        assert(result == 5)
    }

    test "error before success" {
        let result = match divide(10, 2) {
            error => -1
            success x => x
            _ => -888
        }
        assert(result == 5)
    }

    test "specific error before catchall" {
        let result = match divide(10, 0) {
            success x => x
            error DivByZero => -1
            error => -999
            _ => -888
        }
        assert(result == -1)
    }

    test "catchall error catches when specific misses" {
        // Test that error catchall catches errors not matched by specific patterns
        let result = match complexOp(-5) {
            success x => x
            error Timeout => -2   // This won't match NotFound
            error => -999         // Catchall should match NotFound
            _ => -888
        }
        assert(result == -999)  // NotFound should fall through to catchall
    }
}

tests "nested fallible operations" {
    test "outer success inner success" {
        // Both operations succeed
        let outer_result = match processDivide(100, 2, 5) {
            success x => x + 1000
            error => -1
            _ => -888
        }
        assert(outer_result == 1010)  // 100/2/5 = 10, +1000 = 1010
    }

    test "handle error then continue" {
        // Handle an error, get a default, then continue
        let first = match divide(10, 0) {
            success x => x
            error => 100  // default on error
            _ => -888
        }
        let second = match divide(first, 2) {
            success x => x
            error => -999
            _ => -888
        }
        assert(second == 50)  // 100/2 = 50
    }
}
