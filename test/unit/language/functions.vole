// Function tests

// Return type inference - should infer i64 from return expression
func doubleA(x: i64) { return x * 2 }

// Explicit return type
func doubleB(x: i64) -> i64 { return x * 2 }

// Implicit void - no return type, no return statement
func implicitVoid(x: i64) {
    let y = x + 1
}

// Explicit void return type
func explicitVoid(x: i64) -> void {
    let y = x + 1
}

// Return nil explicitly
func returnNil() -> nil {
    return nil
}

// Inferred nil return
func inferredNil() {
    return nil
}

// Expression-bodied functions
func exprDouble(x: i64) -> i64 => x * 2

// Expression-bodied with inferred return type
func exprDoubleInferred(x: i64) => x * 2

// Expression-bodied void (returns value of expression statement - usually nil)
func exprVoid(x: i64) => x + 1

// Expression-bodied multiple params
func exprAdd(a: i64, b: i64) -> i64 => a + b

// Fallible returns - block body with explicit type
func maybeDouble(x: i64) -> i64? {
    if x < 0 {
        return nil
    }
    return x * 2
}

// Fallible with early nil return
func maybeQuad(x: i64) -> i64? {
    if x < 0 { return nil }
    if x == 0 { return nil }
    return x * 4
}

// Chained fallible - uses another fallible result
func doubleIfPositive(x: i64) -> i64? {
    let result = maybeDouble(x)
    if result == nil {
        return nil
    }
    return result
}

// Nil coalesce with fallible
func safeDouble(x: i64) -> i64 {
    return maybeDouble(x) ?? 0
}

tests "functions" {
    test "inferred return type" {
        assert(doubleA(21) == 42)
    }

    test "explicit return type" {
        assert(doubleB(21) == 42)
    }

    test "implicit void" {
        implicitVoid(1)
        assert(true)
    }

    test "explicit void" {
        explicitVoid(1)
        assert(true)
    }

    test "return nil" {
        assert(returnNil() == nil)
    }

    test "inferred nil return" {
        assert(inferredNil() == nil)
    }

    test "expression-bodied function" {
        assert(exprDouble(21) == 42)
    }

    test "expression-bodied inferred return" {
        assert(exprDoubleInferred(21) == 42)
    }

    test "expression-bodied void" {
        let result = exprVoid(5)
        assert(result == 6)
    }

    test "expression-bodied multiple params" {
        assert(exprAdd(20, 22) == 42)
    }

    test "fallible return - some" {
        assert(maybeDouble(5) == 10)
    }

    test "fallible return - nil" {
        assert(maybeDouble(-1) == nil)
    }

    test "multiple early nil returns - some" {
        assert(maybeQuad(2) == 8)
    }

    test "multiple early nil returns - first nil" {
        assert(maybeQuad(-1) == nil)
    }

    test "multiple early nil returns - second nil" {
        assert(maybeQuad(0) == nil)
    }

    test "chained fallible - some" {
        assert(doubleIfPositive(5) == 10)
    }

    test "chained fallible - nil" {
        assert(doubleIfPositive(-1) == nil)
    }

    test "nil coalesce with fallible - some" {
        assert(safeDouble(5) == 10)
    }

    test "nil coalesce with fallible - nil case" {
        assert(safeDouble(-1) == 0)
    }
}

tests "nested functions" {
    test "nested function declaration" {
        func localAdd(a: i64, b: i64) -> i64 {
            return a + b
        }
        assert(localAdd(10, 20) == 30)
    }

    test "nested function with no params" {
        func getValue() -> i64 {
            return 42
        }
        assert(getValue() == 42)
    }

    test "function in function" {
        func outer() -> i64 {
            func inner() -> i64 {
                return 42
            }
            return inner()
        }
        assert(outer() == 42)
    }

    test "nested function with closure" {
        let x = 10
        func addX(y: i64) -> i64 {
            return x + y
        }
        assert(addX(5) == 15)
    }

    test "nested expression-bodied function" {
        func double(x: i64) -> i64 => x * 2
        assert(double(21) == 42)
    }
}
