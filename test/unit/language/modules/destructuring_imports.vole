// Destructuring imports tests

tests {
    // Test basic destructuring import with single name
    test "destructuring single export" {
        let { PI } = import "std:math"
        assert(PI > 3.14)
        assert(PI < 3.15)
    }

    // Test destructuring import with multiple names
    test "destructuring multiple exports" {
        let { sin, cos, PI } = import "std:math"
        assert(PI > 3.14)
        assert(PI < 3.15)
        assert(sin(0.0) == 0.0)
        assert(cos(0.0) == 1.0)
    }

    // Test destructuring import with rename using 'as'
    test "destructuring with as rename" {
        let { sqrt as squareRoot, PI as pi } = import "std:math"
        assert(squareRoot(4.0) == 2.0)
        assert(pi > 3.14)
        assert(pi < 3.15)
    }

    // Test destructuring import with mixed - some renamed, some not
    test "destructuring with mixed rename" {
        let { sqrt, pow as power } = import "std:math"
        assert(sqrt(16.0) == 4.0)
        assert(power(2.0, 3.0) == 8.0)
    }

    // Test destructuring import functions work correctly
    test "destructured functions work" {
        let { min, max, clamp } = import "std:math"
        assert(min(3.0, 5.0) == 3.0)
        assert(max(3.0, 5.0) == 5.0)
        assert(clamp(5.0, 0.0, 10.0) == 5.0)
        assert(clamp(-5.0, 0.0, 10.0) == 0.0)
    }

    // Test destructuring import pure vole functions
    test "destructured pure vole functions" {
        let { lerp, deg_to_rad } = import "std:math"
        assert(lerp(0.0, 10.0, 0.5) == 5.0)
        let rad = deg_to_rad(180.0)
        assert(rad > 3.14)
        assert(rad < 3.15)
    }

    // Test destructured class types are usable as type names
    test "destructured class type in variable annotation" {
        let time = import "std:time"
        let { Duration } = import "std:time"
        // Use Duration in a variable type annotation
        // Note: static methods require module-qualified access (time.Duration.nanos)
        let d: Duration = time.Duration.nanos(4000)
        assert(d.as_nanos() == 4000)
    }

    test "destructured class type as type name in class literal" {
        let { Duration } = import "std:time"
        // Use Duration as a type name in a class literal
        let d = Duration { nanos: 1000 }
        assert(d.as_nanos() == 1000)
    }

    test "destructured class type in function parameter annotation" {
        let { Duration } = import "std:time"
        // Use Duration as a type annotation for a function parameter
        func get_nanos(d: Duration) -> i64 {
            return d.as_nanos()
        }
        let d = Duration { nanos: 2000 }
        assert(get_nanos(d) == 2000)
    }

    test "destructured class type in function return annotation" {
        let time = import "std:time"
        let { Duration } = import "std:time"
        // Use Duration as a return type annotation
        // Static methods require module-qualified access
        func make_duration(n: i64) -> Duration {
            return time.Duration.nanos(n)
        }
        let d = make_duration(3000)
        assert(d.nanos == 3000)
    }

    test "destructured class with renamed type binding" {
        let { Duration as Dur } = import "std:time"
        // Use the renamed type as a type name
        let d = Dur { nanos: 5000 }
        assert(d.as_nanos() == 5000)

        // Also works in type annotations
        func get_nanos(d: Dur) -> i64 {
            return d.as_nanos()
        }
        assert(get_nanos(d) == 5000)
    }

    test "multiple destructured class types" {
        let { Duration, Timestamp } = import "std:time"
        // Both Duration and Timestamp are usable as type names
        let d = Duration { nanos: 1000 }
        let ts = Timestamp { nanos: 1000000000, offset_mins: 0 }
        assert(d.nanos == 1000)
        assert(ts.nanos == 1000000000)
    }
}
