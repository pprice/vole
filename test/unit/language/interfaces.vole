// Test interface functionality

interface Named {
    name: string
}

record Person {
    name: string,
    age: i64,
}

interface Hashable {
    func hash() -> i64
}

record User implements Hashable {
    id: i64,

    func hash() -> i64 {
        return self.id
    }
}

interface Describable {
    func describe() -> string
}

// Implement for existing record
implement Describable for Person {
    func describe() -> string {
        return self.name
    }
}

tests "interfaces" {
    test "record with matching field satisfies interface structurally" {
        let p = Person { name: "Alice", age: 30 }
        assert(p.name == "Alice")
    }

    test "explicit implements with method" {
        let u = User { id: 42 }
        assert(u.hash() == 42)
    }
}

tests "implement blocks" {
    test "implement block adds method to type" {
        let p = Person { name: "Bob", age: 25 }
        assert(p.describe() == "Bob")
    }
}

// Functional interface - single abstract method, no fields
interface Predicate {
    func check(value: i64) -> bool
}

tests "functional interfaces" {
    test "lambda can be assigned to functional interface" {
        // Lambda gets type-checked against interface method signature
        let isEven: Predicate = (x: i64) => x % 2 == 0
        // For now, just verify this type-checks
        // TODO: Test calling via the interface once that's supported
        assert(true)
    }
}
