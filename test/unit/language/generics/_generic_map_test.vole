// Test: generic Map<K, V> with constraints and external functions
// This tests the full stack: constraint resolution in lambdas, type erasure for externals

// Simple wrapper to test the pattern without full Map implementation
class GenericContainer<K: Hashable + Equatable, V> {
    _ptr: i64,

    statics {
        func new() -> GenericContainer<K, V> {
            // Create equality closure that uses constraint methods
            let eq_fn = (a: K, b: K) -> bool => a.equals(b)
            return GenericContainer { _ptr: _generic_map_new_with_eq(eq_fn) }
        }
    }

    func set(key: K, value: V) {
        let h = key.hash()
        _generic_map_set(self._ptr, key, h, value)
    }

    func get(key: K) -> V? {
        let h = key.hash()
        if !_generic_map_has(self._ptr, key, h) {
            return nil
        }
        return _generic_map_get(self._ptr, key, h)
    }

    func len() -> i64 {
        return _generic_map_len(self._ptr)
    }
}

// External declarations with generic type params for type erasure
// Using different names to avoid conflict with prelude's non-generic versions
external("std:collections") {
    func "map_new_with_eq" as _generic_map_new_with_eq<K>(eq_closure: (K, K) -> bool) -> i64
    func "map_get" as _generic_map_get<K, V>(ptr: i64, key: K, key_hash: i64) -> V
    func "map_has" as _generic_map_has<K>(ptr: i64, key: K, key_hash: i64) -> bool
    func "map_set" as _generic_map_set<K, V>(ptr: i64, key: K, key_hash: i64, value: V) -> void
    func "map_len" as _generic_map_len(ptr: i64) -> i64
}

tests {
    test "generic container with i64" {
        let m = GenericContainer.new<i64, i64>()
        m.set(1, 100)
        m.set(2, 200)

        assert(m.len() == 2)
        assert((m.get(1) ?? 0) == 100)
        assert((m.get(2) ?? 0) == 200)
        assert(m.get(3) == nil)
    }
}
