// Lambda tests

// Module-level lambdas with type annotations:
let simpleLambda = (x: i64) => x * 2
let noParams = () => 5
let multiParams = (a: i64, b: i64) => a + b

tests "lambdas" {
    test "simple lambda (module level)" {
        assert(simpleLambda(5) == 10)
    }

    test "no params (module level)" {
        assert(noParams() == 5)
    }

    test "multiple params (module level)" {
        assert(multiParams(2, 3) == 5)
    }

    test "lambda inside test" {
        let double = (n: i64) => n * 2
        assert(double(5) == 10)
    }

    test "multi-param lambda inside test" {
        let add = (a: i64, b: i64) => a + b
        assert(add(10, 20) == 30)
    }

    test "block body" {
        let complex = (x: i64) -> i64 => {
            let y = x * 2
            return y + 1
        }
        assert(complex(5) == 11)
    }

    test "higher order" {
        let apply = (f: (i64) -> i64, x: i64) => f(x)
        let double = (n: i64) => n * 2
        assert(apply(double, 5) == 10)
    }

    // TODO: returned lambdas (currying) cause segfault
    // test "returned lambda" {
    //     let makeAdder = (n: i64) -> (i64) -> i64 => (x: i64) => x + n
    //     let add5 = makeAdder(5)
    //     assert(add5(10) == 15)
    // }

    test "closure capture" {
        let x = 10
        let addX = (n: i64) => n + x
        assert(addX(5) == 15)
    }

    test "mutable closure" {
        let mut count = 0
        let inc = () -> i64 => {
            count = count + 1
            return count
        }
        assert(inc() == 1)
        assert(inc() == 2)
        assert(inc() == 3)
    }
}

tests "type annotations" {
    test "parameter types" {
        let add = (x: i32, y: i32) => x + y
        let a: i32 = 10
        let b: i32 = 20
        assert(add(a, b) == 30)
    }

    test "return type" {
        let typed = (x: i32, y: i32) -> i32 => x + y
        let a: i32 = 5
        let b: i32 = 3
        assert(typed(a, b) == 8)
    }

    test "subtraction" {
        let sub = (a: i32, b: i32) -> i32 => a - b
        let x: i32 = 10
        let y: i32 = 5
        assert(sub(x, y) == 5)
    }
}

func applyFn(fn: (i32) -> i32, x: i32) -> i32 {
    return fn(x)
}

tests "lambda inference" {
    test "bidirectional inference" {
        // Lambda infers x is i32 from function parameter type
        // Use x + x to avoid type widening from literal
        let result = applyFn((x) => x + x, 5)
        assert(result == 10)
    }
}
