// Coroutine tests

tests "coroutines" {
    test "create coroutine" {
        let gen = () => { yield 1 }
        let coro = Coroutine.create(gen)
        let status = Coroutine.status(coro)
        assert(status == "suspended")
    }

    test "simple yield" {
        let gen = () => { yield 42 }
        let coro = Coroutine.create(gen)
        let result = Coroutine.resume(coro, nil)
        assert(result == 42)
    }

    test "multiple yields" {
        let gen = () => {
            yield 1
            yield 2
            yield 3
        }
        let coro = Coroutine.create(gen)
        let a = Coroutine.resume(coro, nil)
        let b = Coroutine.resume(coro, nil)
        let c = Coroutine.resume(coro, nil)
        assert(a == 1)
        assert(b == 2)
        assert(c == 3)
    }

    test "yield nil" {
        let gen = () => { yield nil }
        let coro = Coroutine.create(gen)
        let result = Coroutine.resume(coro, nil)
        assert(result == nil)
    }

    test "yield bool" {
        let gen = () => {
            yield true
            yield false
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == true)
        assert(Coroutine.resume(coro, nil) == false)
    }

    test "yield string" {
        let gen = () => { yield "hello" }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == "hello")
    }
}

tests "status" {
    test "suspended before resume" {
        let gen = () => { yield 1 }
        let coro = Coroutine.create(gen)
        assert(Coroutine.status(coro) == "suspended")
    }

    test "suspended after yield" {
        let gen = () => {
            yield 1
            yield 2
        }
        let coro = Coroutine.create(gen)
        Coroutine.resume(coro, nil)
        assert(Coroutine.status(coro) == "suspended")
    }

    test "dead after return" {
        let gen = () => { yield 1 }
        let coro = Coroutine.create(gen)
        Coroutine.resume(coro, nil)
        Coroutine.resume(coro, nil)
        assert(Coroutine.status(coro) == "dead")
    }
}

tests "with arguments" {
    test "first resume passes argument" {
        let gen = (x: i32) => { yield x * 2 }
        let coro = Coroutine.create(gen)
        let result = Coroutine.resume(coro, 5)
        assert(result == 10)
    }

    test "argument used in computation" {
        let gen = (n: i32) => {
            yield n
            yield n * 2
            yield n * 3
        }
        let coro = Coroutine.create(gen)
        let a = Coroutine.resume(coro, 7)
        let b = Coroutine.resume(coro, nil)
        let c = Coroutine.resume(coro, nil)
        assert(a == 7)
        assert(b == 14)
        assert(c == 21)
    }
}

tests "with local state" {
    test "mutable local preserved across yields" {
        let gen = () => {
            let mut x = 1
            yield x
            x = x + 1
            yield x
            x = x + 1
            yield x
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 1)
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.resume(coro, nil) == 3)
    }

    test "multiple locals preserved" {
        let gen = () => {
            let mut a = 1
            let mut b = 10
            yield a + b
            a = a + 1
            b = b + 10
            yield a + b
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 11)
        assert(Coroutine.resume(coro, nil) == 22)
    }
}

tests "with loops" {
    test "yield in while loop" {
        let gen = () => {
            let mut i = 1
            while i <= 3 {
                yield i
                i = i + 1
            }
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 1)
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.resume(coro, nil) == 3)
    }

    test "counter generator" {
        let gen = () => {
            let mut count = 0
            while true {
                count = count + 1
                yield count
                if count >= 5 { return nil }
            }
        }
        let coro = Coroutine.create(gen)
        let mut sum = 0
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        assert(sum == 15)
    }

    test "range generator" {
        let range = (n: i32) => {
            let mut i = 1
            while i <= n {
                yield i
                i = i + 1
            }
        }
        let coro = Coroutine.create(range)
        let mut sum = 0
        sum = sum + Coroutine.resume(coro, 4)
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        sum = sum + Coroutine.resume(coro, nil)
        assert(sum == 10)
    }
}

tests "with conditionals" {
    test "yield in if branch" {
        let gen = (flag: bool) => {
            if flag {
                yield 1
            } else {
                yield 2
            }
        }
        let coro1 = Coroutine.create(gen)
        let coro2 = Coroutine.create(gen)
        assert(Coroutine.resume(coro1, true) == 1)
        assert(Coroutine.resume(coro2, false) == 2)
    }

    test "conditional yield value" {
        let gen = () => {
            let mut x = 0
            while x < 5 {
                if x % 2 == 0 {
                    yield x
                }
                x = x + 1
            }
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 0)
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.resume(coro, nil) == 4)
    }
}

tests "multiple coroutines" {
    test "independent coroutines" {
        let gen = () => {
            let mut x = 0
            yield x
            x = x + 1
            yield x
        }
        let coro1 = Coroutine.create(gen)
        let coro2 = Coroutine.create(gen)

        assert(Coroutine.resume(coro1, nil) == 0)
        assert(Coroutine.resume(coro2, nil) == 0)
        assert(Coroutine.resume(coro1, nil) == 1)
        assert(Coroutine.resume(coro2, nil) == 1)
    }

    test "interleaved execution" {
        let gen1 = () => {
            yield 1
            yield 2
        }
        let gen2 = () => {
            yield 10
            yield 20
        }
        let c1 = Coroutine.create(gen1)
        let c2 = Coroutine.create(gen2)

        let a = Coroutine.resume(c1, nil)
        let b = Coroutine.resume(c2, nil)
        let c = Coroutine.resume(c1, nil)
        let d = Coroutine.resume(c2, nil)

        assert(a == 1)
        assert(b == 10)
        assert(c == 2)
        assert(d == 20)
    }
}

tests "yield expressions" {
    test "yield arithmetic result" {
        let gen = () => {
            let a = 10
            let b = 5
            yield a + b
            yield a - b
            yield a * b
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 15)
        assert(Coroutine.resume(coro, nil) == 5)
        assert(Coroutine.resume(coro, nil) == 50)
    }

    test "yield array element" {
        let gen = () => {
            let arr = [10, 20, 30]
            yield arr[0]
            yield arr[1]
            yield arr[2]
        }
        let coro = Coroutine.create(gen)
        assert(Coroutine.resume(coro, nil) == 10)
        assert(Coroutine.resume(coro, nil) == 20)
        assert(Coroutine.resume(coro, nil) == 30)
    }
}

tests "producer pattern" {
    test "fibonacci generator" {
        let fib = () => {
            let mut a = 0
            let mut b = 1
            while true {
                yield a
                let temp = a + b
                a = b
                b = temp
                if a > 20 { return nil }
            }
        }
        let coro = Coroutine.create(fib)
        assert(Coroutine.resume(coro, nil) == 0)
        assert(Coroutine.resume(coro, nil) == 1)
        assert(Coroutine.resume(coro, nil) == 1)
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.resume(coro, nil) == 3)
        assert(Coroutine.resume(coro, nil) == 5)
        assert(Coroutine.resume(coro, nil) == 8)
        assert(Coroutine.resume(coro, nil) == 13)
    }

    test "squares generator" {
        let squares = (max: i32) => {
            let mut i = 1
            while i <= max {
                yield i * i
                i = i + 1
            }
        }
        let coro = Coroutine.create(squares)
        assert(Coroutine.resume(coro, 5) == 1)
        assert(Coroutine.resume(coro, nil) == 4)
        assert(Coroutine.resume(coro, nil) == 9)
        assert(Coroutine.resume(coro, nil) == 16)
        assert(Coroutine.resume(coro, nil) == 25)
    }

    test "filter generator" {
        // Only yields even numbers
        let evens = () => {
            let mut i = 0
            while i < 10 {
                if i % 2 == 0 {
                    yield i
                }
                i = i + 1
            }
        }
        let coro = Coroutine.create(evens)
        assert(Coroutine.resume(coro, nil) == 0)
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.resume(coro, nil) == 4)
        assert(Coroutine.resume(coro, nil) == 6)
        assert(Coroutine.resume(coro, nil) == 8)
    }
}

tests "state machine" {
    test "simple state transitions" {
        // A simple state machine using coroutine
        let state_machine = () => {
            // State 1: Initial
            yield 1
            // State 2: Processing
            yield 2
            // State 3: Complete
            yield 3
        }
        let coro = Coroutine.create(state_machine)
        assert(Coroutine.resume(coro, nil) == 1)
        assert(Coroutine.status(coro) == "suspended")
        assert(Coroutine.resume(coro, nil) == 2)
        assert(Coroutine.status(coro) == "suspended")
        assert(Coroutine.resume(coro, nil) == 3)
        // After last yield, one more resume to complete
        Coroutine.resume(coro, nil)
        assert(Coroutine.status(coro) == "dead")
    }
}
