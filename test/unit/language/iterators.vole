// Iterator method tests

tests "iterators" {
    test "array iter returns iterator" {
        let arr = [1, 2, 3]
        let iter = arr.iter()
        assert(true)
    }

    test "iter on empty array" {
        let arr: [i32] = []
        let iter = arr.iter()
        assert(true)
    }

    test "iter on string array" {
        let arr = ["a", "b", "c"]
        let iter = arr.iter()
        assert(true)
    }

    test "multiple iter calls on same array" {
        let arr = [1, 2, 3]
        let iter1 = arr.iter()
        let iter2 = arr.iter()
        assert(true)
    }

    test "iterator next returns value" {
        let arr = [10, 20, 30]
        let iter = arr.iter()

        let first = iter.next()
        // Check that we got a value, not Done
        let not_done = !(first is Done)
        assert(not_done)
    }

    test "iterator next returns done when exhausted" {
        let arr = [1]
        let iter = arr.iter()

        iter.next()  // consume the one element
        let second = iter.next()

        let is_done = second is Done
        assert(is_done)
    }

    test "iterate all elements" {
        let arr = [1, 2, 3]
        let iter = arr.iter()
        let mut count = 0

        // Verify we can call next() three times and get values
        let first = iter.next()
        assert(!(first is Done))
        count = count + 1

        let second = iter.next()
        assert(!(second is Done))
        count = count + 1

        let third = iter.next()
        assert(!(third is Done))
        count = count + 1

        // Fourth call should return Done
        let fourth = iter.next()
        assert(fourth is Done)

        assert(count == 3)
    }

    test "collect to array" {
        let arr = [1, 2, 3]
        let collected = arr.iter().collect()
        assert(collected.length() == 3)
        assert(collected[0] == 1)
        assert(collected[1] == 2)
        assert(collected[2] == 3)
    }

    test "map transforms elements" {
        let arr = [1, 2, 3]
        let doubled = arr.iter().map((x) => x * 2).collect()
        assert(doubled.length() == 3)
        assert(doubled[0] == 2)
        assert(doubled[1] == 4)
        assert(doubled[2] == 6)
    }

    test "map with closure captures" {
        let arr = [1, 2, 3]
        let multiplier = 10
        let result = arr.iter().map((x) => x * multiplier).collect()
        assert(result[0] == 10)
        assert(result[1] == 20)
        assert(result[2] == 30)
    }

    test "chained map" {
        let arr = [1, 2, 3]
        let result = arr.iter().map((x) => x + 1).map((x) => x * 2).collect()
        assert(result[0] == 4)   // (1+1)*2 = 4
        assert(result[1] == 6)   // (2+1)*2 = 6
        assert(result[2] == 8)   // (3+1)*2 = 8
    }

    test "filter keeps matching elements" {
        let arr = [1, 2, 3, 4, 5]
        let evens = arr.iter().filter((x) => x % 2 == 0).collect()
        assert(evens.length() == 2)
        assert(evens[0] == 2)
        assert(evens[1] == 4)
    }

    test "filter with closure" {
        let arr = [1, 2, 3, 4, 5]
        let threshold = 3
        let result = arr.iter().filter((x) => x > threshold).collect()
        assert(result.length() == 2)
        assert(result[0] == 4)
        assert(result[1] == 5)
    }

    test "chained filter and map" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 10).collect()
        assert(result.length() == 2)
        assert(result[0] == 20)
        assert(result[1] == 40)
    }

    test "chained map and filter" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().map((x) => x * 2).filter((x) => x > 5).collect()
        assert(result.length() == 3)
        assert(result[0] == 6)   // 3*2 = 6
        assert(result[1] == 8)   // 4*2 = 8
        assert(result[2] == 10)  // 5*2 = 10
    }

    test "filter all elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().filter((x) => x > 10).collect()
        assert(result.length() == 0)
    }

    test "filter no elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().filter((x) => x > 0).collect()
        assert(result.length() == 3)
    }

    test "chained filters" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let result = arr.iter().filter((x) => x % 2 == 0).filter((x) => x > 4).collect()
        assert(result.length() == 3)
        assert(result[0] == 6)
        assert(result[1] == 8)
        assert(result[2] == 10)
    }

    // Consumer methods: count(), sum(), for_each()

    test "count elements" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().count() == 5)
    }

    test "count with filter" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().filter((x) => x % 2 == 0).count() == 2)
    }

    test "count empty iterator" {
        let arr: [i64] = []
        assert(arr.iter().count() == 0)
    }

    test "count with map" {
        let arr = [1, 2, 3]
        assert(arr.iter().map((x) => x * 2).count() == 3)
    }

    test "sum elements" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().sum() == 15)
    }

    test "sum with map" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().map((x) => x * 2).sum() == 30)
    }

    test "sum empty iterator" {
        let arr: [i64] = []
        assert(arr.iter().sum() == 0)
    }

    test "sum with filter" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().filter((x) => x % 2 == 0).sum() == 6)
    }

    // Note: Vole closures capture variables by copying to heap storage.
    // The closure's copy is separate from the outer variable, so side effects
    // on captured variables won't affect the outer scope. For this reason,
    // for_each is primarily useful for side effects like printing.

    test "for_each executes without error" {
        let arr = [1, 2, 3]
        // Just verify for_each doesn't crash - it runs the callback
        arr.iter().for_each((x) => { let y = x * 2 })
        assert(true)
    }

    test "for_each with filter chain" {
        let arr = [1, 2, 3, 4, 5]
        // for_each after filter should work
        arr.iter().filter((x) => x > 3).for_each((x) => { let y = x })
        assert(true)
    }

    test "for_each empty iterator" {
        let arr: [i64] = []
        // for_each on empty iterator should just do nothing
        arr.iter().for_each((x) => { let y = x })
        assert(true)
    }

    test "chained operations with count" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 10).count()
        assert(result == 5)
    }

    test "chained operations with sum" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().filter((x) => x % 2 == 1).map((x) => x * 2).sum()
        // Odd numbers: 1, 3, 5 -> doubled: 2, 6, 10 -> sum: 18
        assert(result == 18)
    }
}
