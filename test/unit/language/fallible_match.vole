// Fallible match expression tests

error NotFound { key: string }
error Timeout { ms: i32 }

func mayFail(x: i32) -> fallible(i32, NotFound | Timeout) {
    if x < 0 {
        raise NotFound { key: "negative" }
    }
    if x > 100 {
        raise Timeout { ms: x }
    }
    return x * 2
}

tests "fallible match" {
    test "success pattern with binding" {
        let result = match mayFail(5) {
            success x => x + 1
            error => 0
        }
        assert(result == 11)
    }

    test "success pattern without binding" {
        let result = match mayFail(5) {
            success => 42
            error => 0
        }
        assert(result == 42)
    }

    test "specific error pattern" {
        let result = match mayFail(-1) {
            NotFound => -1
            success x => x
            error => -999
        }
        assert(result == -1)
    }

    test "error catchall pattern" {
        let result = match mayFail(-1) {
            success x => x
            error => -999
        }
        assert(result == -999)
    }

    test "error catchall with binding" {
        let result = match mayFail(-1) {
            success x => x
            error e => -1
        }
        assert(result == -1)
    }

    test "success transforms value" {
        let result = match mayFail(5) {
            success x => x * 3
            error => 0
        }
        assert(result == 30)
    }

    test "multiple specific errors before catchall" {
        let result = match mayFail(-1) {
            NotFound => -1
            Timeout => -2
            success x => x
            error => -999
        }
        assert(result == -1)
    }

    test "timeout error matches" {
        let result = match mayFail(150) {
            NotFound => -1
            Timeout => -2
            success x => x
            error => -999
        }
        assert(result == -2)
    }

    test "multiple sequential matches" {
        // mayFail(-1) raises NotFound, mayFail(-2) raises NotFound, mayFail(5) returns 10
        let r1 = match mayFail(-1) {
            success x => x
            error => 100
        }
        let r2 = match mayFail(-2) {
            success x => x
            error => 200
        }
        let r3 = match mayFail(5) {
            success x => x
            error => 300
        }
        assert(r1 == 100)
        assert(r2 == 200)
        assert(r3 == 10)
    }

    // TODO: Implement implicit success passthrough in IR generation
    // Currently, all match arms must be explicit. The sema handles type inference
    // for implicit defaults, but IR generation doesn't add implicit arms yet.
    // test "implicit success passthrough" {
    //     let result = match mayFail(5) {
    //         NotFound => 0
    //         Timeout => 0
    //         error => -1
    //     }
    //     assert(result == 10)
    // }

    test "bare raise in error pattern" {
        // Test that bare raise re-raises the caught error
        // Success case
        let r1 = match wrapperBareRaise(5) {
            success x => x
            error => -999
        }
        assert(r1 == 110)  // 5*2 + 100 = 110

        // Error re-raised case
        let r2 = match wrapperBareRaise(-1) {
            NotFound => -1
            error => -999
        }
        assert(r2 == -1)  // NotFound should be re-raised
    }

    test "bare raise with binding preserves error" {
        let r = match wrapperBareRaiseWithBinding(150) {
            Timeout => -2
            error => -999
        }
        assert(r == -2)  // Timeout should be re-raised
    }
}

// Helper functions for bare raise tests (outside tests block)
func wrapperBareRaise(x: i32) -> fallible(i32, NotFound | Timeout) {
    let result = match mayFail(x) {
        success v => v + 100
        error => raise  // bare raise - re-raise the error
    }
    return result
}

func wrapperBareRaiseWithBinding(x: i32) -> fallible(i32, NotFound | Timeout) {
    let result = match mayFail(x) {
        success v => v
        error e => raise  // bare raise even with binding
    }
    return result
}
