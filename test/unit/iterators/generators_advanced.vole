// Advanced generator tests: yield inside control flow
// These patterns require stackful coroutines (impossible with AST state machine)

// Yield inside a while loop
func count_up(n: i64) -> Iterator<i64> {
    var i = 0
    while i < n {
        yield i
        i = i + 1
    }
}

// Yield inside a for-range loop
func range_gen(start: i64, end: i64) -> Iterator<i64> {
    for i in start..end {
        yield i * i
    }
}

// Yield inside a for-array loop
func array_gen(arr: [i64]) -> Iterator<i64> {
    for x in arr {
        yield x + 1
    }
}

// Yield inside if/else branches
func branch_gen(n: i64) -> Iterator<i64> {
    var i = 0
    while i < n {
        if i % 2 == 0 {
            yield i
        } else {
            yield i * 10
        }
        i = i + 1
    }
}

// Yield in nested loops
func nested_gen(rows: i64, cols: i64) -> Iterator<i64> {
    var r = 0
    while r < rows {
        var c = 0
        while c < cols {
            yield r * cols + c
            c = c + 1
        }
        r = r + 1
    }
}

// Early break from generator (consumer stops early)
func infinite_counter() -> Iterator<i64> {
    var i = 0
    while true {
        yield i
        i = i + 1
    }
}

// Fibonacci generator
func fibonacci() -> Iterator<i64> {
    var a = 0
    var b = 1
    while true {
        yield a
        let next = a + b
        a = b
        b = next
    }
}

// Yield with conditional guard (skip some values)
func evens_up_to(n: i64) -> Iterator<i64> {
    var i = 0
    while i < n {
        if i % 2 == 0 {
            yield i
        }
        i = i + 1
    }
}

// Multiple yield points in sequence + loop
func mixed_gen() -> Iterator<i64> {
    yield 100
    var i = 0
    while i < 3 {
        yield i
        i = i + 1
    }
    yield 200
}

tests {
    test "yield in while loop" {
        let result = count_up(5).collect()
        assert(result.length() == 5)
        assert(result[0] == 0)
        assert(result[1] == 1)
        assert(result[2] == 2)
        assert(result[3] == 3)
        assert(result[4] == 4)
    }

    test "yield in for-range loop" {
        let result = range_gen(1, 5).collect()
        assert(result.length() == 4)
        assert(result[0] == 1)   // 1*1
        assert(result[1] == 4)   // 2*2
        assert(result[2] == 9)   // 3*3
        assert(result[3] == 16)  // 4*4
    }

    test "yield in for-array loop" {
        let result = array_gen([10, 20, 30]).collect()
        assert(result.length() == 3)
        assert(result[0] == 11)
        assert(result[1] == 21)
        assert(result[2] == 31)
    }

    test "yield in if/else branches" {
        let result = branch_gen(5).collect()
        assert(result.length() == 5)
        assert(result[0] == 0)    // even: 0
        assert(result[1] == 10)   // odd: 1*10
        assert(result[2] == 2)    // even: 2
        assert(result[3] == 30)   // odd: 3*10
        assert(result[4] == 4)    // even: 4
    }

    test "yield in nested loops" {
        let result = nested_gen(2, 3).collect()
        assert(result.length() == 6)
        assert(result[0] == 0)  // 0*3+0
        assert(result[1] == 1)  // 0*3+1
        assert(result[2] == 2)  // 0*3+2
        assert(result[3] == 3)  // 1*3+0
        assert(result[4] == 4)  // 1*3+1
        assert(result[5] == 5)  // 1*3+2
    }

    test "infinite generator with take" {
        let result = infinite_counter().take(5).collect()
        assert(result.length() == 5)
        assert(result[0] == 0)
        assert(result[1] == 1)
        assert(result[2] == 2)
        assert(result[3] == 3)
        assert(result[4] == 4)
    }

    test "fibonacci generator" {
        let result = fibonacci().take(8).collect()
        assert(result.length() == 8)
        assert(result[0] == 0)
        assert(result[1] == 1)
        assert(result[2] == 1)
        assert(result[3] == 2)
        assert(result[4] == 3)
        assert(result[5] == 5)
        assert(result[6] == 8)
        assert(result[7] == 13)
    }

    test "conditional yield (skip values)" {
        let result = evens_up_to(10).collect()
        assert(result.length() == 5)
        assert(result[0] == 0)
        assert(result[1] == 2)
        assert(result[2] == 4)
        assert(result[3] == 6)
        assert(result[4] == 8)
    }

    test "mixed sequential and loop yields" {
        let result = mixed_gen().collect()
        assert(result.length() == 5)
        assert(result[0] == 100)
        assert(result[1] == 0)
        assert(result[2] == 1)
        assert(result[3] == 2)
        assert(result[4] == 200)
    }

    test "generator with map on loop yield" {
        let result = count_up(4).map((x) => x * 10).collect()
        assert(result.length() == 4)
        assert(result[0] == 0)
        assert(result[1] == 10)
        assert(result[2] == 20)
        assert(result[3] == 30)
    }

    test "generator with filter on loop yield" {
        let result = count_up(6).filter((x) => x % 2 == 0).collect()
        assert(result.length() == 3)
        assert(result[0] == 0)
        assert(result[1] == 2)
        assert(result[2] == 4)
    }

    test "chained operations on infinite generator" {
        let result = infinite_counter()
            .filter((x) => x % 3 == 0)
            .map((x) => x * 2)
            .take(4)
            .collect()
        assert(result.length() == 4)
        assert(result[0] == 0)   // 0*2
        assert(result[1] == 6)   // 3*2
        assert(result[2] == 12)  // 6*2
        assert(result[3] == 18)  // 9*2
    }

    test "fibonacci sum of first 6" {
        // 0 + 1 + 1 + 2 + 3 + 5 = 12
        assert(fibonacci().take(6).sum() == 12)
    }

    test "fibonacci count" {
        assert(fibonacci().take(10).count() == 10)
    }

    test "count_up with for loop" {
        var sum = 0
        for x in count_up(5) {
            sum = sum + x
        }
        // 0 + 1 + 2 + 3 + 4 = 10
        assert(sum == 10)
    }

    test "infinite generator in for loop with break" {
        var last = 0
        for x in infinite_counter() {
            last = x
            if x >= 4 {
                break
            }
        }
        assert(last == 4)
    }
}
