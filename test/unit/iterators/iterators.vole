// Iterator method tests

func sum_iterator_param(iter: Iterator<i64>) -> i64 {
    let mut total = 0
    for v in iter {
        total = total + v
    }
    return total
}

tests "iterators" {
    test "array iter returns iterator" {
        let arr = [1, 2, 3]
        let iter = arr.iter()
        assert(true)
    }

    test "iter on empty array" {
        let arr: [i32] = []
        let iter = arr.iter()
        assert(true)
    }

    test "iter on string array" {
        let arr = ["a", "b", "c"]
        let iter = arr.iter()
        assert(true)
    }

    test "iterator parameter works in for loop" {
        assert(sum_iterator_param([1, 2, 3].iter()) == 6)
    }

    test "multiple iter calls on same array" {
        let arr = [1, 2, 3]
        let iter1 = arr.iter()
        let iter2 = arr.iter()
        assert(true)
    }

    test "iterator next returns value" {
        let arr = [10, 20, 30]
        let iter = arr.iter()

        let first = iter.next()
        // Check that we got a value, not Done
        let not_done = !(first is Done)
        assert(not_done)
    }

    test "iterator next returns done when exhausted" {
        let arr = [1]
        let iter = arr.iter()

        _ = iter.next()  // consume the one element
        let second = iter.next()

        let is_done = second is Done
        assert(is_done)
    }

    test "iterate all elements" {
        let arr = [1, 2, 3]
        let iter = arr.iter()
        let mut count = 0

        // Verify we can call next() three times and get values
        let first = iter.next()
        assert(!(first is Done))
        count = count + 1

        let second = iter.next()
        assert(!(second is Done))
        count = count + 1

        let third = iter.next()
        assert(!(third is Done))
        count = count + 1

        // Fourth call should return Done
        let fourth = iter.next()
        assert(fourth is Done)

        assert(count == 3)
    }

    test "collect to array" {
        let arr = [1, 2, 3]
        let collected = arr.iter().collect()
        assert(collected.length() == 3)
        assert(collected[0] == 1)
        assert(collected[1] == 2)
        assert(collected[2] == 3)
    }

    test "map transforms elements" {
        let arr = [1, 2, 3]
        let doubled = arr.iter().map((x) => x * 2).collect()
        assert(doubled.length() == 3)
        assert(doubled[0] == 2)
        assert(doubled[1] == 4)
        assert(doubled[2] == 6)
    }

    test "map with closure captures" {
        let arr = [1, 2, 3]
        let multiplier = 10
        let result = arr.iter().map((x) => x * multiplier).collect()
        assert(result[0] == 10)
        assert(result[1] == 20)
        assert(result[2] == 30)
    }

    test "chained map" {
        let arr = [1, 2, 3]
        let result = arr.iter().map((x) => x + 1).map((x) => x * 2).collect()
        assert(result[0] == 4)   // (1+1)*2 = 4
        assert(result[1] == 6)   // (2+1)*2 = 6
        assert(result[2] == 8)   // (3+1)*2 = 8
    }

    test "filter keeps matching elements" {
        let arr = [1, 2, 3, 4, 5]
        let evens = arr.iter().filter((x) => x % 2 == 0).collect()
        assert(evens.length() == 2)
        assert(evens[0] == 2)
        assert(evens[1] == 4)
    }

    test "filter with closure" {
        let arr = [1, 2, 3, 4, 5]
        let threshold = 3
        let result = arr.iter().filter((x) => x > threshold).collect()
        assert(result.length() == 2)
        assert(result[0] == 4)
        assert(result[1] == 5)
    }

    test "chained filter and map" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 10).collect()
        assert(result.length() == 2)
        assert(result[0] == 20)
        assert(result[1] == 40)
    }

    test "chained map and filter" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().map((x) => x * 2).filter((x) => x > 5).collect()
        assert(result.length() == 3)
        assert(result[0] == 6)   // 3*2 = 6
        assert(result[1] == 8)   // 4*2 = 8
        assert(result[2] == 10)  // 5*2 = 10
    }

    test "filter all elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().filter((x) => x > 10).collect()
        assert(result.length() == 0)
    }

    test "filter no elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().filter((x) => x > 0).collect()
        assert(result.length() == 3)
    }

    test "chained filters" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let result = arr.iter().filter((x) => x % 2 == 0).filter((x) => x > 4).collect()
        assert(result.length() == 3)
        assert(result[0] == 6)
        assert(result[1] == 8)
        assert(result[2] == 10)
    }

    // Consumer methods: count(), sum(), for_each()

    test "count elements" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().count() == 5)
    }

    test "count with filter" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().filter((x) => x % 2 == 0).count() == 2)
    }

    test "count empty iterator" {
        let arr: [i64] = []
        assert(arr.iter().count() == 0)
    }

    test "count with map" {
        let arr = [1, 2, 3]
        assert(arr.iter().map((x) => x * 2).count() == 3)
    }

    test "sum elements" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().sum() == 15)
    }

    test "sum with map" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().map((x) => x * 2).sum() == 30)
    }

    test "sum empty iterator" {
        let arr: [i64] = []
        assert(arr.iter().sum() == 0)
    }

    test "sum with filter" {
        let arr = [1, 2, 3, 4, 5]
        assert(arr.iter().filter((x) => x % 2 == 0).sum() == 6)
    }

    // Note: Vole closures capture variables by copying to heap storage.
    // The closure's copy is separate from the outer variable, so side effects
    // on captured variables won't affect the outer scope. For this reason,
    // for_each is primarily useful for side effects like printing.

    test "for_each executes without error" {
        let arr = [1, 2, 3]
        // Just verify for_each doesn't crash - it runs the callback
        arr.iter().for_each((x) => { let y = x * 2 })
        assert(true)
    }

    test "for_each with filter chain" {
        let arr = [1, 2, 3, 4, 5]
        // for_each after filter should work
        arr.iter().filter((x) => x > 3).for_each((x) => { let y = x })
        assert(true)
    }

    test "for_each empty iterator" {
        let arr: [i64] = []
        // for_each on empty iterator should just do nothing
        arr.iter().for_each((x) => { let y = x })
        assert(true)
    }

    test "chained operations with count" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 10).count()
        assert(result == 5)
    }

    test "chained operations with sum" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().filter((x) => x % 2 == 1).map((x) => x * 2).sum()
        // Odd numbers: 1, 3, 5 -> doubled: 2, 6, 10 -> sum: 18
        assert(result == 18)
    }

    // take() tests

    test "take first n elements" {
        let arr = [1, 2, 3, 4, 5]
        let first3 = arr.iter().take(3).collect()
        assert(first3.length() == 3)
        assert(first3[0] == 1)
        assert(first3[1] == 2)
        assert(first3[2] == 3)
    }

    test "take more than available" {
        let arr = [1, 2]
        let result = arr.iter().take(10).collect()
        assert(result.length() == 2)
    }

    test "take with map" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().map((x) => x * 2).take(2).collect()
        assert(result.length() == 2)
        assert(result[0] == 2)
        assert(result[1] == 4)
    }

    test "take zero elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().take(0).collect()
        assert(result.length() == 0)
    }

    test "take from empty array" {
        let arr: [i64] = []
        let result = arr.iter().take(5).collect()
        assert(result.length() == 0)
    }

    test "take with filter" {
        let arr = [1, 2, 3, 4, 5, 6]
        let result = arr.iter().filter((x) => x % 2 == 0).take(2).collect()
        assert(result.length() == 2)
        assert(result[0] == 2)
        assert(result[1] == 4)
    }

    test "take count" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().take(3).count()
        assert(result == 3)
    }

    test "take sum" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().take(3).sum()
        assert(result == 6)
    }

    // skip() tests

    test "skip first n elements" {
        let arr = [1, 2, 3, 4, 5]
        let last2 = arr.iter().skip(3).collect()
        assert(last2.length() == 2)
        assert(last2[0] == 4)
        assert(last2[1] == 5)
    }

    test "skip more than available" {
        let arr = [1, 2]
        let result = arr.iter().skip(10).collect()
        assert(result.length() == 0)
    }

    test "skip with filter" {
        let arr = [1, 2, 3, 4, 5, 6]
        let result = arr.iter().filter((x) => x % 2 == 0).skip(1).collect()
        assert(result.length() == 2)
        assert(result[0] == 4)
        assert(result[1] == 6)
    }

    test "skip zero elements" {
        let arr = [1, 2, 3]
        let result = arr.iter().skip(0).collect()
        assert(result.length() == 3)
        assert(result[0] == 1)
    }

    test "skip from empty array" {
        let arr: [i64] = []
        let result = arr.iter().skip(5).collect()
        assert(result.length() == 0)
    }

    test "skip with map" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().map((x) => x * 2).skip(2).collect()
        assert(result.length() == 3)
        assert(result[0] == 6)  // 3*2
        assert(result[1] == 8)  // 4*2
        assert(result[2] == 10) // 5*2
    }

    test "skip count" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().skip(2).count()
        assert(result == 3)
    }

    test "skip sum" {
        let arr = [1, 2, 3, 4, 5]
        let result = arr.iter().skip(2).sum()
        // 3 + 4 + 5 = 12
        assert(result == 12)
    }

    // Combined take and skip tests

    test "skip then take" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Skip first 3, then take next 4: [4, 5, 6, 7]
        let result = arr.iter().skip(3).take(4).collect()
        assert(result.length() == 4)
        assert(result[0] == 4)
        assert(result[1] == 5)
        assert(result[2] == 6)
        assert(result[3] == 7)
    }

    test "take then skip" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Take first 6, then skip 2: [3, 4, 5, 6]
        let result = arr.iter().take(6).skip(2).collect()
        assert(result.length() == 4)
        assert(result[0] == 3)
        assert(result[1] == 4)
        assert(result[2] == 5)
        assert(result[3] == 6)
    }

    test "filter map take" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Filter evens: [2, 4, 6, 8, 10], map double: [4, 8, 12, 16, 20], take 3: [4, 8, 12]
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 2).take(3).collect()
        assert(result.length() == 3)
        assert(result[0] == 4)
        assert(result[1] == 8)
        assert(result[2] == 12)
    }

    test "map filter skip" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Map double: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
        // Filter > 10: [12, 14, 16, 18, 20]
        // Skip 2: [16, 18, 20]
        let result = arr.iter().map((x) => x * 2).filter((x) => x > 10).skip(2).collect()
        assert(result.length() == 3)
        assert(result[0] == 16)
        assert(result[1] == 18)
        assert(result[2] == 20)
    }

    // reduce() tests

    test "reduce to sum" {
        let arr = [1, 2, 3, 4, 5]
        let total = arr.iter().reduce(0, (acc, x) => acc + x)
        assert(total == 15)
    }

    test "reduce to product" {
        let arr = [1, 2, 3, 4]
        let product = arr.iter().reduce(1, (acc, x) => acc * x)
        assert(product == 24)
    }

    test "reduce empty iterator" {
        let arr: [i64] = []
        let result = arr.iter().reduce(100, (acc, x) => acc + x)
        assert(result == 100)
    }

    test "reduce with filter" {
        let arr = [1, 2, 3, 4, 5]
        let sum_evens = arr.iter().filter((x) => x % 2 == 0).reduce(0, (acc, x) => acc + x)
        assert(sum_evens == 6)
    }

    test "reduce with map" {
        let arr = [1, 2, 3]
        // Double each element then sum: (1*2) + (2*2) + (3*2) = 2 + 4 + 6 = 12
        let result = arr.iter().map((x) => x * 2).reduce(0, (acc, x) => acc + x)
        assert(result == 12)
    }

    test "reduce with take" {
        let arr = [1, 2, 3, 4, 5]
        // Take first 3, then sum: 1 + 2 + 3 = 6
        let result = arr.iter().take(3).reduce(0, (acc, x) => acc + x)
        assert(result == 6)
    }

    test "reduce with skip" {
        let arr = [1, 2, 3, 4, 5]
        // Skip first 2, then sum: 3 + 4 + 5 = 12
        let result = arr.iter().skip(2).reduce(0, (acc, x) => acc + x)
        assert(result == 12)
    }

    test "reduce with closure" {
        let arr = [1, 2, 3]
        let multiplier = 10
        // Multiply each by 10 then sum: (1*10) + (2*10) + (3*10) = 60
        let result = arr.iter().reduce(0, (acc, x) => acc + x * multiplier)
        assert(result == 60)
    }

    test "reduce chained operations" {
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Filter evens: [2, 4, 6, 8, 10]
        // Map double: [4, 8, 12, 16, 20]
        // Take 3: [4, 8, 12]
        // Sum: 24
        let result = arr.iter().filter((x) => x % 2 == 0).map((x) => x * 2).take(3).reduce(0, (acc, x) => acc + x)
        assert(result == 24)
    }
}
