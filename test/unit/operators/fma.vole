// Test FMA (fused multiply-add) pattern detection
// FMA computes x*y + z with only one rounding operation

tests {
    test "fma pattern: (x * y) + z" {
        let x = 1.5
        let y = 2.0
        let z = 3.0
        // This should emit: fma(x, y, z) = 1.5 * 2.0 + 3.0 = 6.0
        let result = (x * y) + z
        assert(result == 6.0)
    }

    test "fma pattern: z + (x * y)" {
        let x = 1.5
        let y = 2.0
        let z = 3.0
        // This should also emit fma: z + (x * y) = 3.0 + (1.5 * 2.0) = 6.0
        let result = z + (x * y)
        assert(result == 6.0)
    }

    test "fnma pattern: z - (x * y)" {
        let x = 2.0
        let y = 3.0
        let z = 10.0
        // This should emit: fma(-x, y, z) = 10.0 - (2.0 * 3.0) = 4.0
        let result = z - (x * y)
        assert(result == 4.0)
    }

    test "fma pattern: (x * y) - z" {
        let x = 3.0
        let y = 4.0
        let z = 2.0
        // This should emit: fma(x, y, -z) = 3.0 * 4.0 - 2.0 = 10.0
        let result = (x * y) - z
        assert(result == 10.0)
    }

    test "fma with f32 values" {
        let x: f32 = 1.5_f32
        let y: f32 = 2.0_f32
        let z: f32 = 0.5_f32
        let result = (x * y) + z
        assert(result == 3.5_f32)
    }

    test "nested fma: a*b + c*d + e" {
        let a = 1.0
        let b = 2.0
        let c = 3.0
        let d = 4.0
        let e = 5.0
        // (a * b) + (c * d) + e = 2.0 + 12.0 + 5.0 = 19.0
        let result = (a * b) + (c * d) + e
        assert(result == 19.0)
    }

    test "fma precision test" {
        // FMA should have better precision than separate mul+add
        // This is a case where FMA makes a difference
        let a = 1.0 + 1e-16
        let b = 1.0 - 1e-16
        let c = -1.0
        // a * b + c = (1 + 1e-16)(1 - 1e-16) - 1 = 1 - 1e-32 - 1 = -1e-32
        // With FMA, we should get a more accurate result
        let result = (a * b) + c
        // Just verify it runs without error
        assert(result <= 0.0)
    }

    test "fma in loop (mandelbrot-like)" {
        var zr = 0.0
        var zi = 0.0
        let cr = -0.5
        let ci = 0.5

        // One iteration of mandelbrot
        // new_zr = zr*zr - zi*zi + cr
        // new_zi = 2*zr*zi + ci
        let zr_sq = zr * zr
        let zi_sq = zi * zi
        let new_zr = zr_sq - zi_sq + cr  // Should use FMA patterns
        let new_zi = (2.0 * zr) * zi + ci  // Should use FMA

        assert(new_zr == -0.5)
        assert(new_zi == 0.5)
    }

    // ============ Additional FMA pattern validation tests ============

    test "fma with negative x" {
        let x = -2.0
        let y = 3.0
        let z = 10.0
        // (-2) * 3 + 10 = -6 + 10 = 4
        let result = (x * y) + z
        assert(result == 4.0)
    }

    test "fma with negative y" {
        let x = 2.0
        let y = -3.0
        let z = 10.0
        // 2 * (-3) + 10 = -6 + 10 = 4
        let result = (x * y) + z
        assert(result == 4.0)
    }

    test "fma with negative z" {
        let x = 2.0
        let y = 3.0
        let z = -10.0
        // 2 * 3 + (-10) = 6 - 10 = -4
        let result = (x * y) + z
        assert(result == -4.0)
    }

    test "fma with all negative" {
        let x = -2.0
        let y = -3.0
        let z = -10.0
        // (-2) * (-3) + (-10) = 6 - 10 = -4
        let result = (x * y) + z
        assert(result == -4.0)
    }

    test "fma with zero x" {
        let x = 0.0
        let y = 100.0
        let z = 5.0
        // 0 * 100 + 5 = 5
        let result = (x * y) + z
        assert(result == 5.0)
    }

    test "fma with zero z" {
        let x = 2.0
        let y = 3.0
        let z = 0.0
        // 2 * 3 + 0 = 6
        let result = (x * y) + z
        assert(result == 6.0)
    }

    test "fnma with negative x" {
        let x = -2.0
        let y = 3.0
        let z = 10.0
        // 10 - ((-2) * 3) = 10 - (-6) = 16
        let result = z - (x * y)
        assert(result == 16.0)
    }

    test "fnma with negative result" {
        let x = 5.0
        let y = 4.0
        let z = 10.0
        // 10 - (5 * 4) = 10 - 20 = -10
        let result = z - (x * y)
        assert(result == -10.0)
    }

    test "fms pattern: (x * y) - z with negatives" {
        let x = -3.0
        let y = -4.0
        let z = 2.0
        // (-3) * (-4) - 2 = 12 - 2 = 10
        let result = (x * y) - z
        assert(result == 10.0)
    }

    test "fms with negative z" {
        let x = 3.0
        let y = 4.0
        let z = -2.0
        // 3 * 4 - (-2) = 12 + 2 = 14
        let result = (x * y) - z
        assert(result == 14.0)
    }

    test "f32 fma with negatives" {
        let x: f32 = -1.5_f32
        let y: f32 = 2.0_f32
        let z: f32 = 5.0_f32
        // (-1.5) * 2 + 5 = -3 + 5 = 2
        let result = (x * y) + z
        assert(result == 2.0_f32)
    }

    test "f32 fnma pattern" {
        let x: f32 = 2.0_f32
        let y: f32 = 3.0_f32
        let z: f32 = 10.0_f32
        // 10 - (2 * 3) = 10 - 6 = 4
        let result = z - (x * y)
        assert(result == 4.0_f32)
    }

    test "f32 fms pattern" {
        let x: f32 = 3.0_f32
        let y: f32 = 4.0_f32
        let z: f32 = 2.0_f32
        // 3 * 4 - 2 = 12 - 2 = 10
        let result = (x * y) - z
        assert(result == 10.0_f32)
    }

    test "chained fma: (a*b + c) * d + e" {
        let a = 2.0
        let b = 3.0
        let c = 4.0
        let d = 2.0
        let e = 1.0
        // (2*3 + 4) * 2 + 1 = (6 + 4) * 2 + 1 = 10 * 2 + 1 = 21
        let intermediate = (a * b) + c
        let result = (intermediate * d) + e
        assert(result == 21.0)
    }

    test "fma commutative: x*y+z vs y*x+z" {
        let x = 2.5
        let y = 3.0
        let z = 1.5
        let result1 = (x * y) + z
        let result2 = (y * x) + z
        assert(result1 == result2)
        assert(result1 == 9.0)
    }
}
