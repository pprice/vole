// Test constant folding optimization pass
// Verifies that constant expressions are evaluated at compile time

tests {
    // ============ Basic constant folding tests ============

    test "fold integer addition" {
        // 2 + 3 should be folded to 5 at compile time
        let result = 2 + 3
        assert(result == 5)
    }

    test "fold integer subtraction" {
        let result = 10 - 3
        assert(result == 7)
    }

    test "fold integer multiplication" {
        let result = 4 * 5
        assert(result == 20)
    }

    test "fold integer division" {
        let result = 20 / 4
        assert(result == 5)
    }

    test "fold integer modulo" {
        let result = 17 % 5
        assert(result == 2)
    }

    test "fold nested integer expression" {
        // ((2 + 3) * 4 - 10) / 2 = (5 * 4 - 10) / 2 = (20 - 10) / 2 = 10 / 2 = 5
        let result = ((2 + 3) * 4 - 10) / 2
        assert(result == 5)
    }

    test "fold float addition" {
        let result = 1.5 + 2.5
        assert(result == 4.0)
    }

    test "fold float subtraction" {
        let result = 5.0 - 2.5
        assert(result == 2.5)
    }

    test "fold float multiplication" {
        let result = 2.5 * 4.0
        assert(result == 10.0)
    }

    test "fold float division" {
        let result = 10.0 / 4.0
        assert(result == 2.5)
    }

    test "fold nested float expression" {
        // (1.0 + 2.0) * (3.0 - 1.0) = 3.0 * 2.0 = 6.0
        let result = (1.0 + 2.0) * (3.0 - 1.0)
        assert(result == 6.0)
    }

    test "fold mixed int/float promotes to float" {
        // 2 + 3.0 should work and fold to 5.0
        let result = 2 + 3.0
        assert(result == 5.0)
    }

    // ============ Unary operator folding ============

    test "fold unary negation int" {
        let result = -5
        assert(result == -5)
    }

    test "fold unary negation float" {
        let result = -3.5
        assert(result == -3.5)
    }

    test "fold double negation" {
        let result = --5
        assert(result == 5)
    }

    test "fold boolean not" {
        let result = !false
        assert(result == true)
    }

    test "fold double boolean not" {
        let result = !!true
        assert(result == true)
    }

    // ============ Comparison folding ============

    test "fold integer equality true" {
        let result = 5 == 5
        assert(result == true)
    }

    test "fold integer equality false" {
        let result = 5 == 6
        assert(result == false)
    }

    test "fold integer less than true" {
        let result = 3 < 5
        assert(result == true)
    }

    test "fold integer less than false" {
        let result = 5 < 3
        assert(result == false)
    }

    test "fold float comparison" {
        let result = 3.14 > 2.71
        assert(result == true)
    }

    // ============ Boolean operation folding ============

    test "fold boolean and true" {
        let result = true && true
        assert(result == true)
    }

    test "fold boolean and false" {
        let result = true && false
        assert(result == false)
    }

    test "fold boolean or true" {
        let result = false || true
        assert(result == true)
    }

    test "fold boolean or false" {
        let result = false || false
        assert(result == false)
    }

    // ============ Bitwise operation folding ============

    test "fold bitwise and" {
        let result = 0b1100 & 0b1010
        assert(result == 0b1000)
    }

    test "fold bitwise or" {
        let result = 0b1100 | 0b1010
        assert(result == 0b1110)
    }

    test "fold bitwise xor" {
        let result = 0b1100 ^ 0b1010
        assert(result == 0b0110)
    }

    test "fold left shift" {
        let result = 1 << 4
        assert(result == 16)
    }

    test "fold right shift" {
        let result = 16 >> 2
        assert(result == 4)
    }

    // ============ Division by constant optimization ============

    test "division by constant float" {
        // x / 4.0 should become x * 0.25
        let x = 20.0
        let result = x / 4.0
        assert(result == 5.0)
    }

    test "division by constant float in expression" {
        // y / 1000.0 should become y * 0.001
        let y = 5000.0
        let result = y / 1000.0
        assert(result == 5.0)
    }

    test "division by power of two unsigned" {
        // x / 8 should become x >> 3 for unsigned
        let x: u64 = 64
        let result = x / 8
        assert(result == 8)
    }

    test "division by power of two in mandelbrot pattern" {
        // This is the pattern from the mandelbrot benchmark
        let size = 4000.0
        let x = 2000.0
        // 2.0 * x / size - 1.5 = 2.0 * 2000 / 4000 - 1.5 = 4000/4000 - 1.5 = 1.0 - 1.5 = -0.5
        let cr = 2.0 * x / size - 1.5
        assert(cr == -0.5)
    }

    // ============ Complex expressions that should fold ============

    test "multiple constant operations" {
        // All of this should fold at compile time
        let a = 10 + 20
        let b = a * 2  // a is not constant, but if we inlined it...
        // For now, just test the direct constant folding
        assert(a == 30)
    }

    test "constant in loop bound (constant expression)" {
        let limit = 5 + 5  // Should fold to 10
        let mut sum = 0
        let mut i = 0
        while i < limit {
            sum = sum + 1
            i = i + 1
        }
        assert(sum == 10)
    }

    test "typed numeric suffix preserved" {
        let x: i32 = 10_i32 + 20_i32
        assert(x == 30_i32)
    }

    test "f32 constant folding" {
        let x: f32 = 1.5_f32 + 2.5_f32
        assert(x == 4.0_f32)
    }

    // ============ Edge cases ============

    test "fold division by 1" {
        let x = 42
        let result = x / 1
        assert(result == 42)
    }

    test "fold multiplication by 1" {
        let x = 42
        let result = x * 1
        assert(result == 42)
    }

    test "fold multiplication by 0" {
        let x = 42
        let result = x * 0
        assert(result == 0)
    }

    test "fold addition of 0" {
        let x = 42
        let result = x + 0
        assert(result == 42)
    }

    test "fold subtraction of 0" {
        let x = 42
        let result = x - 0
        assert(result == 42)
    }

    test "very large constant" {
        let result = 1000000 * 1000000
        assert(result == 1000000000000)
    }

    test "negative constant folding" {
        let result = -10 + 20
        assert(result == 10)
    }

    test "mixed sign constant folding" {
        let result = 10 * -5 + 100
        assert(result == 50)
    }

    // ============ Constant propagation tests ============

    test "propagate integer constant" {
        // The constant `size` should be propagated to the usage
        let size = 4000
        let result = size + 1
        assert(result == 4001)
    }

    test "propagate float constant" {
        // Float constants should also propagate
        let pi = 3.14159
        let result = pi * 2.0
        assert(result > 6.28 && result < 6.29)
    }

    test "propagate boolean constant" {
        let flag = true
        let result = flag && true
        assert(result == true)
    }

    test "propagate to division optimization" {
        // This is the key optimization for mandelbrot:
        // let size = 4000
        // let cr = 2.0 * x / size
        // After propagation: 2.0 * x / 4000
        // After div opt: 2.0 * x * 0.00025
        let size = 4000.0
        let x = 2000.0
        let cr = 2.0 * x / size - 1.5
        // 2.0 * 2000 / 4000 - 1.5 = 4000/4000 - 1.5 = 1.0 - 1.5 = -0.5
        assert(cr == -0.5)
    }

    test "propagate integer to float division" {
        // Integer constant propagated, then division optimized
        let size = 4000
        let x = 2000.0
        // 2.0 * 2000 / 4000 = 1.0
        let result = 2.0 * x / size
        assert(result == 1.0)
    }

    test "no propagation for mutable" {
        // Mutable variables should NOT be propagated
        let mut value = 10
        let a = value + 1  // Should not replace value with 10
        value = 20
        let b = value + 1  // Should definitely use current value of 20
        assert(a == 11)
        assert(b == 21)
    }

    test "propagate typed integer constant" {
        // Use suffix to indicate type, no explicit type annotation
        // (explicit annotation prevents propagation due to potential union storage)
        let size = 100_i32
        let result = size * 2_i32
        assert(result == 200_i32)
    }

    test "propagate typed float constant" {
        // Use suffix to indicate type, no explicit type annotation
        let value = 2.5_f32
        let result = value * 4.0_f32
        assert(result == 10.0_f32)
    }

    test "chained constant propagation" {
        // Constants defined in terms of other constants
        let a = 10
        let b = a + 5  // b = 15
        let c = b * 2  // c = 30
        assert(c == 30)
    }

    test "propagate in loop condition" {
        let limit = 5
        let mut sum = 0
        let mut i = 0
        while i < limit {
            sum = sum + 1
            i = i + 1
        }
        assert(sum == 5)
    }

    test "propagate across multiple uses" {
        let constant = 42
        let a = constant + 1
        let b = constant * 2
        let c = constant - 10
        assert(a == 43)
        assert(b == 84)
        assert(c == 32)
    }

    test "propagate negative constant" {
        let neg = -10
        let result = neg + 20
        assert(result == 10)
    }

    test "propagate constant from expression" {
        // If the initializer is a constant expression, it should be folded
        // and then the folded value should be propagated
        let value = 2 + 3  // Folded to 5
        let result = value * 2  // Propagated as 5 * 2 = 10
        assert(result == 10)
    }

    // ============ String constant folding tests ============

    test "fold string concatenation" {
        // "hello" + " " + "world" should fold to "hello world"
        let result = "hello" + " " + "world"
        assert(result == "hello world")
    }

    test "fold empty string concatenation left" {
        // "" + "hello" should fold to "hello"
        let result = "" + "hello"
        assert(result == "hello")
    }

    test "fold empty string concatenation right" {
        // "hello" + "" should fold to "hello"
        let result = "hello" + ""
        assert(result == "hello")
    }

    test "fold two empty strings" {
        let result = "" + ""
        assert(result == "")
    }

    test "fold string equality true" {
        let result = "abc" == "abc"
        assert(result == true)
    }

    test "fold string equality false" {
        let result = "abc" == "def"
        assert(result == false)
    }

    test "fold string inequality true" {
        let result = "abc" != "def"
        assert(result == true)
    }

    test "fold string inequality false" {
        let result = "abc" != "abc"
        assert(result == false)
    }

    test "fold chained string concatenation" {
        // "a" + "b" + "c" + "d" should fold to "abcd"
        let result = "a" + "b" + "c" + "d"
        assert(result == "abcd")
    }

    test "propagate string constant" {
        let greeting = "hello"
        let result = greeting + " world"
        assert(result == "hello world")
    }

    test "propagate string constant to comparison" {
        let expected = "hello"
        let result = expected == "hello"
        assert(result == true)
    }

    test "chained string constant propagation" {
        let a = "hello"
        let b = a + " "
        let c = b + "world"
        assert(c == "hello world")
    }

    test "no propagation for mutable string" {
        let mut s = "hello"
        let a = s + " world"
        s = "goodbye"
        let b = s + " world"
        assert(a == "hello world")
        assert(b == "goodbye world")
    }

    // ============ Dead branch elimination tests ============

    test "eliminate if true statement with else" {
        // if true { a } else { b } => a
        let mut result = 0
        if true {
            result = 42
        } else {
            result = 99
        }
        assert(result == 42)
    }

    test "eliminate if false statement with else branch" {
        // if false { a } else { b } => b
        let mut result = 0
        if false {
            result = 42
        } else {
            result = 99
        }
        assert(result == 99)
    }

    test "eliminate if true no else" {
        // if true { a } => a (value is the then branch)
        let mut x = 0
        if true {
            x = 42
        }
        assert(x == 42)
    }

    test "eliminate if false no else" {
        // if false { a } => removed (dead code)
        let mut x = 10
        if false {
            x = 42
        }
        assert(x == 10)
    }

    test "eliminate if statement with propagated true constant" {
        // Constant propagation feeds into dead branch elimination
        let debug = true
        let mut result = "release mode"
        if debug {
            result = "debug mode"
        }
        assert(result == "debug mode")
    }

    test "eliminate if statement with propagated false constant" {
        let debug = false
        let mut result = "release mode"
        if debug {
            result = "debug mode"
        }
        assert(result == "release mode")
    }

    test "eliminate if statement with propagated false and else" {
        let verbose = false
        let mut output = "unknown"
        if verbose {
            output = "loud"
        } else {
            output = "quiet"
        }
        assert(output == "quiet")
    }

    test "eliminate nested if statements" {
        // Both levels should be eliminated
        let a = true
        let b = false
        let mut result = 0
        if a {
            if b {
                result = 1
            } else {
                result = 2
            }
        } else {
            result = 3
        }
        assert(result == 2)
    }

    test "eliminate when expression with true condition" {
        // when with constant true arm eliminates to that arm's body
        let result = when {
            true => 42,
            _ => 99,
        }
        assert(result == 42)
    }

    test "eliminate when expression with false condition" {
        // when with constant false arm falls through to wildcard
        let result = when {
            false => 42,
            _ => 99,
        }
        assert(result == 99)
    }

    test "eliminate when with propagated constant" {
        let debug = true
        let result = when {
            debug => "debug mode",
            _ => "release mode",
        }
        assert(result == "debug mode")
    }

    test "eliminate if with computed constant condition" {
        // Condition is a constant expression: 5 > 3 folds to true
        let mut result = "no"
        if 5 > 3 {
            result = "yes"
        }
        assert(result == "yes")
    }

    test "eliminate if with constant boolean expression" {
        // true && false folds to false, so the else branch is taken
        let mut result = 0
        if true && false {
            result = 100
        } else {
            result = 200
        }
        assert(result == 200)
    }

    test "eliminate if false statement with else" {
        let mode = false
        let mut result = "unknown"
        if mode {
            result = "on"
        } else {
            result = "off"
        }
        assert(result == "off")
    }

    test "eliminate dead branch preserves side effects in taken branch" {
        // The taken branch should still execute correctly
        let mut counter = 0
        if true {
            counter = counter + 1
            counter = counter + 1
            counter = counter + 1
        }
        assert(counter == 3)
    }

    test "eliminate dead branch with multiple statements" {
        // The dead branch has multiple statements that should all be eliminated
        let mut x = 0
        if false {
            x = 1
            x = x + 1
            x = x * 2
        }
        assert(x == 0)
    }

    test "chained constant propagation into statement if elimination" {
        // a = 10, b = a > 5 = true, if b { ... } => taken
        let a = 10
        let b = a > 5
        let mut result = "small"
        if b {
            result = "big"
        }
        assert(result == "big")
    }

    // ============ Pure intrinsic call folding tests ============
    // These test that calls to known-pure intrinsics with constant arguments
    // are evaluated at compile time (e.g., math.sqrt(4.0) -> 2.0)

    test "fold math.sqrt with constant f64" {
        let math = import "std:math"
        let result = math.sqrt(4.0)
        assert(result == 2.0)
    }

    test "fold math.sqrt of 0" {
        let math = import "std:math"
        let result = math.sqrt(0.0)
        assert(result == 0.0)
    }

    test "fold math.sqrt of 1" {
        let math = import "std:math"
        let result = math.sqrt(1.0)
        assert(result == 1.0)
    }

    test "fold math.abs with constant f64" {
        let math = import "std:math"
        let result = math.abs(-5.0)
        assert(result == 5.0)
    }

    test "fold math.abs positive value unchanged" {
        let math = import "std:math"
        let result = math.abs(3.0)
        assert(result == 3.0)
    }

    test "fold math.ceil with constant f64" {
        let math = import "std:math"
        let result = math.ceil(3.2)
        assert(result == 4.0)
    }

    test "fold math.ceil negative" {
        let math = import "std:math"
        let result = math.ceil(-3.8)
        assert(result == -3.0)
    }

    test "fold math.floor with constant f64" {
        let math = import "std:math"
        let result = math.floor(3.9)
        assert(result == 3.0)
    }

    test "fold math.floor negative" {
        let math = import "std:math"
        let result = math.floor(-3.2)
        assert(result == -4.0)
    }

    test "fold math.trunc with constant f64" {
        let math = import "std:math"
        let result = math.trunc(3.9)
        assert(result == 3.0)
    }

    test "fold math.trunc negative" {
        let math = import "std:math"
        let result = math.trunc(-3.9)
        assert(result == -3.0)
    }

    test "fold math.round with constant f64" {
        let math = import "std:math"
        let result = math.round(3.6)
        assert(result == 4.0)
    }

    test "fold math.round down" {
        let math = import "std:math"
        let result = math.round(3.4)
        assert(result == 3.0)
    }

    test "fold math.min with constant f64" {
        let math = import "std:math"
        let result = math.min(3.0, 5.0)
        assert(result == 3.0)
    }

    test "fold math.max with constant f64" {
        let math = import "std:math"
        let result = math.max(3.0, 5.0)
        assert(result == 5.0)
    }

    test "fold destructured sqrt with constant" {
        // Test the direct Call path (destructured import)
        let { sqrt } = import "std:math"
        let result = sqrt(9.0)
        assert(result == 3.0)
    }

    test "fold destructured abs with constant" {
        let { abs } = import "std:math"
        let result = abs(-7.0)
        assert(result == 7.0)
    }

    test "fold destructured min with constants" {
        let { min } = import "std:math"
        let result = min(10.0, 3.0)
        assert(result == 3.0)
    }

    test "fold destructured max with constants" {
        let { max } = import "std:math"
        let result = max(10.0, 3.0)
        assert(result == 10.0)
    }

    test "fold intrinsic with propagated constant" {
        let math = import "std:math"
        let x = 16.0
        let result = math.sqrt(x)
        assert(result == 4.0)
    }

    test "fold chained intrinsic calls" {
        let math = import "std:math"
        // sqrt(abs(-16.0)) = sqrt(16.0) = 4.0
        // Each step should fold independently
        let inner = math.abs(-16.0)
        let result = math.sqrt(inner)
        assert(result == 4.0)
    }

    test "fold integer abs via std:math" {
        let math = import "std:math"
        let x: i64 = -42
        let result = math.abs(x)
        assert(result == 42)
    }

    test "fold lowlevel clz" {
        let ll = import "std:lowlevel"
        let x: u64 = 1
        let result = ll.clz(x)
        assert(result == 63)
    }

    test "fold lowlevel ctz" {
        let ll = import "std:lowlevel"
        let x: u64 = 16
        let result = ll.ctz(x)
        assert(result == 4)
    }

    test "fold lowlevel popcnt" {
        let ll = import "std:lowlevel"
        let x: u64 = 0b10110111
        let result = ll.popcnt(x)
        assert(result == 6)
    }
}

// ============================================================================
// Negative tests: things that should NOT be folded, and edge cases
// ============================================================================

tests "division/modulo by zero should NOT fold (remain runtime)" {
    // The constant folder guards integer div/mod by zero with `if r != 0`,
    // so these must remain as runtime operations. We verify the non-folded
    // code still produces the correct runtime behavior by testing with
    // non-zero divisors that are computed at runtime.

    test "integer division with runtime zero divisor is not folded" {
        // Use a runtime-computed zero to ensure the folder can't see it
        let mut d = 1
        d = d - 1  // d = 0 at runtime, but folder can't track mutable
        // We can't actually call 1 / d here because it would panic at runtime.
        // Instead, verify the folder leaves it alone by checking a guarded version.
        let result = when {
            d != 0 => 10 / d,
            _ => -1,
        }
        assert(result == -1)
    }

    test "integer modulo with runtime zero divisor is not folded" {
        let mut d = 1
        d = d - 1
        let result = when {
            d != 0 => 10 % d,
            _ => -1,
        }
        assert(result == -1)
    }

    test "float division by zero produces infinity" {
        // Float div by zero IS folded (IEEE 754: 1.0/0.0 = inf)
        // Verify folded result matches runtime behavior
        let folded = 1.0 / 0.0
        let rt_zero = 0.0
        let mut z = rt_zero
        z = z * 1.0  // ensure runtime
        let runtime = 1.0 / rt_zero
        // Both should be positive infinity
        assert(folded == runtime)
        assert(folded > 1000000000000.0)
    }

    test "float division by negative zero produces negative infinity" {
        let result = -1.0 / 0.0
        assert(result < -1000000000000.0)
    }

    test "float zero divided by zero produces NaN" {
        let result = 0.0 / 0.0
        // NaN is not equal to itself
        assert(result != result)
    }
}

tests "runtime values mixed with constants should NOT fold" {
    test "function parameter plus constant is not folded" {
        func add_ten(x: i64) -> i64 {
            return x + 10
        }
        // The add inside add_ten cannot be folded because x is a parameter
        assert(add_ten(5) == 15)
        assert(add_ten(0) == 10)
        assert(add_ten(-10) == 0)
    }

    test "mutable variable incremented in loop is not propagated" {
        let mut sum = 0
        let mut i = 0
        while i < 5 {
            sum = sum + i
            i = i + 1
        }
        // sum = 0+1+2+3+4 = 10
        // The folder should NOT propagate the initial value of sum (0) across mutations
        assert(sum == 10)
    }

    test "mutable variable reassignment prevents propagation" {
        let mut x = 100
        let a = x + 1  // should use 100 (but not folded since x is mutable)
        x = 200
        let b = x + 1  // should use 200
        assert(a == 101)
        assert(b == 201)
    }

    test "function return value is not folded" {
        func compute() -> i64 {
            return 42
        }
        let result = compute() + 1
        // compute() is not a constant, so the + 1 should not be folded
        assert(result == 43)
    }

    test "conditional with runtime condition is not eliminated" {
        func pick(flag: bool) -> i64 {
            if flag {
                return 1
            } else {
                return 2
            }
        }
        assert(pick(true) == 1)
        assert(pick(false) == 2)
    }
}

tests "integer overflow edge cases (wrapping behavior at fold time)" {
    // The constant folder uses wrapping_add/wrapping_sub/wrapping_mul.
    // These tests verify that large constant expressions fold correctly
    // and that the wrapping matches what happens at runtime.

    test "large multiplication folds correctly" {
        let result = 1000000 * 1000000
        assert(result == 1000000000000)
    }

    test "i64 max value is representable" {
        let max = 9223372036854775807
        assert(max == 9223372036854775807)
    }

    test "negative overflow in constant subtraction" {
        // -9223372036854775807 - 1 should wrap/be the min value
        let near_min = -9223372036854775807
        let result = near_min - 1
        // This is i64::MIN as computed by wrapping subtraction
        assert(result == -9223372036854775807 - 1)
    }

    test "double negation of large positive" {
        let x = 9223372036854775807
        let result = -(-x)
        assert(result == 9223372036854775807)
    }
}

tests "float edge cases in constant folding" {
    test "zero divided by zero produces NaN at fold time" {
        let result = 0.0 / 0.0
        // NaN != NaN is the canonical NaN check
        assert(result != result)
    }

    test "positive divided by zero produces infinity at fold time" {
        let result = 1.0 / 0.0
        // Infinity is greater than any finite number
        assert(result > 1000000000000.0)
        assert(result == result)  // infinity IS equal to itself
    }

    test "negative divided by zero produces negative infinity at fold time" {
        let result = -1.0 / 0.0
        assert(result < -1000000000000.0)
        assert(result == result)
    }

    test "NaN equality is false at fold time" {
        // 0.0/0.0 folds to NaN, then NaN == NaN folds to false
        let nan_val = 0.0 / 0.0
        let eq_result = nan_val == nan_val
        assert(eq_result == false)
    }

    test "NaN not-equal is true" {
        let nan_val = 0.0 / 0.0
        let ne_result = nan_val != nan_val
        assert(ne_result == true)
    }

    test "NaN propagation in addition at fold time" {
        let nan_val = 0.0 / 0.0
        let result = nan_val + 1.0
        assert(result != result)
    }

    test "NaN propagation in multiplication at fold time" {
        let nan_val = 0.0 / 0.0
        let result = nan_val * 2.0
        assert(result != result)
    }

    test "infinity plus finite is infinity" {
        // 1.0/0.0 folds to inf, inf + 1.0 folds to inf
        let inf = 1.0 / 0.0
        let result = inf + 1.0
        assert(result > 1000000000000.0)
    }

    test "infinity minus infinity is NaN" {
        let inf = 1.0 / 0.0
        let result = inf - inf
        assert(result != result)
    }

    test "negative zero fold" {
        let result = -0.0
        // -0.0 == 0.0 in IEEE 754
        assert(result == 0.0)
    }

    test "f64 NaN comparisons all false except ne" {
        let nan_val = 0.0 / 0.0
        // All ordered comparisons with NaN should be false
        assert((nan_val < 0.0) == false)
        assert((nan_val > 0.0) == false)
        assert((nan_val <= 0.0) == false)
        assert((nan_val >= 0.0) == false)
        assert((nan_val == 0.0) == false)
        // Only != should be true
        assert((nan_val != 0.0) == true)
    }
}

tests "string edge cases in constant folding" {
    test "runtime string concat with function parameter is not folded" {
        func greet(name: string) -> string {
            return "hello " + name
        }
        assert(greet("world") == "hello world")
        assert(greet("vole") == "hello vole")
    }

    test "long string constant concat folds correctly" {
        let a = "abcdefghijklmnopqrstuvwxyz"
        let b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        let result = a + b
        assert(result == "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    }

    test "repeated string concat folds correctly" {
        let result = "abc" + "def" + "ghi" + "jkl" + "mno" + "pqr" + "stu" + "vwx" + "yz"
        assert(result == "abcdefghijklmnopqrstuvwxyz")
    }

    test "string comparison with different lengths" {
        let short = "ab"
        let long = "abc"
        assert((short == long) == false)
        assert((short != long) == true)
    }

    test "mutable string prevents propagation" {
        let mut s = "first"
        let a = s + "!"
        s = "second"
        let b = s + "!"
        assert(a == "first!")
        assert(b == "second!")
    }
}

tests "dead branch edge cases" {
    test "if with non-constant condition is not eliminated" {
        func check(x: i64) -> string {
            if x > 0 {
                return "positive"
            } else {
                return "non-positive"
            }
        }
        assert(check(5) == "positive")
        assert(check(-3) == "non-positive")
        assert(check(0) == "non-positive")
    }

    test "if with side-effecting then branch preserves effect" {
        let mut counter = 0
        let flag = true
        if flag {
            counter = counter + 1
            counter = counter + 1
            counter = counter + 1
        }
        assert(counter == 3)
    }

    test "if with side-effecting else branch preserves effect" {
        let mut counter = 0
        let flag = false
        if flag {
            counter = 100
        } else {
            counter = counter + 5
        }
        assert(counter == 5)
    }

    test "nested if with mixed constant and runtime conditions" {
        let const_flag = true
        func runtime_check(x: i64) -> i64 {
            // Outer if is constant (eliminated), inner if is runtime (preserved)
            if const_flag {
                if x > 10 {
                    return 1
                } else {
                    return 2
                }
            } else {
                return 3
            }
        }
        assert(runtime_check(20) == 1)
        assert(runtime_check(5) == 2)
    }

    test "when with non-constant condition is not eliminated" {
        func categorize(x: i64) -> string {
            return when {
                x < 0 => "negative",
                x == 0 => "zero",
                _ => "positive",
            }
        }
        assert(categorize(-1) == "negative")
        assert(categorize(0) == "zero")
        assert(categorize(1) == "positive")
    }
}

tests "intrinsic edge cases in constant folding" {
    test "math.sqrt of negative is not folded (produces NaN at runtime)" {
        let math = import "std:math"
        // The constant folder returns None for sqrt of negative values
        // So this goes through the runtime path, which returns NaN
        let result = math.sqrt(-1.0)
        assert(result != result)  // NaN check
    }

    test "math.sqrt with runtime argument is not folded" {
        let math = import "std:math"
        func compute_sqrt(x: f64) -> f64 {
            return math.sqrt(x)
        }
        let result = compute_sqrt(25.0)
        assert(result == 5.0)
    }

    test "math.abs with runtime argument is not folded" {
        let math = import "std:math"
        func compute_abs(x: f64) -> f64 {
            return math.abs(x)
        }
        assert(compute_abs(-7.0) == 7.0)
        assert(compute_abs(3.0) == 3.0)
    }

    test "math.min with one runtime arg is not folded" {
        let math = import "std:math"
        func get_min(x: f64) -> f64 {
            return math.min(x, 10.0)
        }
        assert(get_min(5.0) == 5.0)
        assert(get_min(15.0) == 10.0)
    }

    test "math.max with one runtime arg is not folded" {
        let math = import "std:math"
        func get_max(x: f64) -> f64 {
            return math.max(x, 10.0)
        }
        assert(get_max(5.0) == 10.0)
        assert(get_max(15.0) == 15.0)
    }

    test "math.sqrt of 0.0 folds correctly" {
        let math = import "std:math"
        let result = math.sqrt(0.0)
        assert(result == 0.0)
    }

    test "math.floor of negative fraction folds correctly" {
        let math = import "std:math"
        let result = math.floor(-0.1)
        assert(result == -1.0)
    }

    test "math.ceil of negative fraction folds correctly" {
        let math = import "std:math"
        let result = math.ceil(-0.1)
        assert(result == 0.0)
    }

    test "math.round of unambiguous value folds correctly" {
        let math = import "std:math"
        // Use a value that rounds the same in all rounding modes
        let result = math.round(2.7)
        assert(result == 3.0)
    }

    test "math.abs of zero folds correctly" {
        let math = import "std:math"
        let result = math.abs(0.0)
        assert(result == 0.0)
    }

    test "chained intrinsic with runtime input is not folded" {
        let math = import "std:math"
        func chain(x: f64) -> f64 {
            let inner = math.abs(x)
            return math.sqrt(inner)
        }
        assert(chain(-16.0) == 4.0)
        assert(chain(9.0) == 3.0)
    }
}
