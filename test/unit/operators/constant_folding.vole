// Test constant folding optimization pass
// Verifies that constant expressions are evaluated at compile time

tests {
    // ============ Basic constant folding tests ============

    test "fold integer addition" {
        // 2 + 3 should be folded to 5 at compile time
        let result = 2 + 3
        assert(result == 5)
    }

    test "fold integer subtraction" {
        let result = 10 - 3
        assert(result == 7)
    }

    test "fold integer multiplication" {
        let result = 4 * 5
        assert(result == 20)
    }

    test "fold integer division" {
        let result = 20 / 4
        assert(result == 5)
    }

    test "fold integer modulo" {
        let result = 17 % 5
        assert(result == 2)
    }

    test "fold nested integer expression" {
        // ((2 + 3) * 4 - 10) / 2 = (5 * 4 - 10) / 2 = (20 - 10) / 2 = 10 / 2 = 5
        let result = ((2 + 3) * 4 - 10) / 2
        assert(result == 5)
    }

    test "fold float addition" {
        let result = 1.5 + 2.5
        assert(result == 4.0)
    }

    test "fold float subtraction" {
        let result = 5.0 - 2.5
        assert(result == 2.5)
    }

    test "fold float multiplication" {
        let result = 2.5 * 4.0
        assert(result == 10.0)
    }

    test "fold float division" {
        let result = 10.0 / 4.0
        assert(result == 2.5)
    }

    test "fold nested float expression" {
        // (1.0 + 2.0) * (3.0 - 1.0) = 3.0 * 2.0 = 6.0
        let result = (1.0 + 2.0) * (3.0 - 1.0)
        assert(result == 6.0)
    }

    test "fold mixed int/float promotes to float" {
        // 2 + 3.0 should work and fold to 5.0
        let result = 2 + 3.0
        assert(result == 5.0)
    }

    // ============ Unary operator folding ============

    test "fold unary negation int" {
        let result = -5
        assert(result == -5)
    }

    test "fold unary negation float" {
        let result = -3.5
        assert(result == -3.5)
    }

    test "fold double negation" {
        let result = --5
        assert(result == 5)
    }

    test "fold boolean not" {
        let result = !false
        assert(result == true)
    }

    test "fold double boolean not" {
        let result = !!true
        assert(result == true)
    }

    // ============ Comparison folding ============

    test "fold integer equality true" {
        let result = 5 == 5
        assert(result == true)
    }

    test "fold integer equality false" {
        let result = 5 == 6
        assert(result == false)
    }

    test "fold integer less than true" {
        let result = 3 < 5
        assert(result == true)
    }

    test "fold integer less than false" {
        let result = 5 < 3
        assert(result == false)
    }

    test "fold float comparison" {
        let result = 3.14 > 2.71
        assert(result == true)
    }

    // ============ Boolean operation folding ============

    test "fold boolean and true" {
        let result = true && true
        assert(result == true)
    }

    test "fold boolean and false" {
        let result = true && false
        assert(result == false)
    }

    test "fold boolean or true" {
        let result = false || true
        assert(result == true)
    }

    test "fold boolean or false" {
        let result = false || false
        assert(result == false)
    }

    // ============ Bitwise operation folding ============

    test "fold bitwise and" {
        let result = 0b1100 & 0b1010
        assert(result == 0b1000)
    }

    test "fold bitwise or" {
        let result = 0b1100 | 0b1010
        assert(result == 0b1110)
    }

    test "fold bitwise xor" {
        let result = 0b1100 ^ 0b1010
        assert(result == 0b0110)
    }

    test "fold left shift" {
        let result = 1 << 4
        assert(result == 16)
    }

    test "fold right shift" {
        let result = 16 >> 2
        assert(result == 4)
    }

    // ============ Division by constant optimization ============

    test "division by constant float" {
        // x / 4.0 should become x * 0.25
        let x = 20.0
        let result = x / 4.0
        assert(result == 5.0)
    }

    test "division by constant float in expression" {
        // y / 1000.0 should become y * 0.001
        let y = 5000.0
        let result = y / 1000.0
        assert(result == 5.0)
    }

    test "division by power of two unsigned" {
        // x / 8 should become x >> 3 for unsigned
        let x: u64 = 64
        let result = x / 8
        assert(result == 8)
    }

    test "division by power of two in mandelbrot pattern" {
        // This is the pattern from the mandelbrot benchmark
        let size = 4000.0
        let x = 2000.0
        // 2.0 * x / size - 1.5 = 2.0 * 2000 / 4000 - 1.5 = 4000/4000 - 1.5 = 1.0 - 1.5 = -0.5
        let cr = 2.0 * x / size - 1.5
        assert(cr == -0.5)
    }

    // ============ Complex expressions that should fold ============

    test "multiple constant operations" {
        // All of this should fold at compile time
        let a = 10 + 20
        let b = a * 2  // a is not constant, but if we inlined it...
        // For now, just test the direct constant folding
        assert(a == 30)
    }

    test "constant in loop bound (constant expression)" {
        let limit = 5 + 5  // Should fold to 10
        let mut sum = 0
        let mut i = 0
        while i < limit {
            sum = sum + 1
            i = i + 1
        }
        assert(sum == 10)
    }

    test "typed numeric suffix preserved" {
        let x: i32 = 10_i32 + 20_i32
        assert(x == 30_i32)
    }

    test "f32 constant folding" {
        let x: f32 = 1.5_f32 + 2.5_f32
        assert(x == 4.0_f32)
    }

    // ============ Edge cases ============

    test "fold division by 1" {
        let x = 42
        let result = x / 1
        assert(result == 42)
    }

    test "fold multiplication by 1" {
        let x = 42
        let result = x * 1
        assert(result == 42)
    }

    test "fold multiplication by 0" {
        let x = 42
        let result = x * 0
        assert(result == 0)
    }

    test "fold addition of 0" {
        let x = 42
        let result = x + 0
        assert(result == 42)
    }

    test "fold subtraction of 0" {
        let x = 42
        let result = x - 0
        assert(result == 42)
    }

    test "very large constant" {
        let result = 1000000 * 1000000
        assert(result == 1000000000000)
    }

    test "negative constant folding" {
        let result = -10 + 20
        assert(result == 10)
    }

    test "mixed sign constant folding" {
        let result = 10 * -5 + 100
        assert(result == 50)
    }

    // ============ Constant propagation tests ============

    test "propagate integer constant" {
        // The constant `size` should be propagated to the usage
        let size = 4000
        let result = size + 1
        assert(result == 4001)
    }

    test "propagate float constant" {
        // Float constants should also propagate
        let pi = 3.14159
        let result = pi * 2.0
        assert(result > 6.28 && result < 6.29)
    }

    test "propagate boolean constant" {
        let flag = true
        let result = flag && true
        assert(result == true)
    }

    test "propagate to division optimization" {
        // This is the key optimization for mandelbrot:
        // let size = 4000
        // let cr = 2.0 * x / size
        // After propagation: 2.0 * x / 4000
        // After div opt: 2.0 * x * 0.00025
        let size = 4000.0
        let x = 2000.0
        let cr = 2.0 * x / size - 1.5
        // 2.0 * 2000 / 4000 - 1.5 = 4000/4000 - 1.5 = 1.0 - 1.5 = -0.5
        assert(cr == -0.5)
    }

    test "propagate integer to float division" {
        // Integer constant propagated, then division optimized
        let size = 4000
        let x = 2000.0
        // 2.0 * 2000 / 4000 = 1.0
        let result = 2.0 * x / size
        assert(result == 1.0)
    }

    test "no propagation for mutable" {
        // Mutable variables should NOT be propagated
        let mut value = 10
        let a = value + 1  // Should not replace value with 10
        value = 20
        let b = value + 1  // Should definitely use current value of 20
        assert(a == 11)
        assert(b == 21)
    }

    test "propagate typed integer constant" {
        // Use suffix to indicate type, no explicit type annotation
        // (explicit annotation prevents propagation due to potential union storage)
        let size = 100_i32
        let result = size * 2_i32
        assert(result == 200_i32)
    }

    test "propagate typed float constant" {
        // Use suffix to indicate type, no explicit type annotation
        let value = 2.5_f32
        let result = value * 4.0_f32
        assert(result == 10.0_f32)
    }

    test "chained constant propagation" {
        // Constants defined in terms of other constants
        let a = 10
        let b = a + 5  // b = 15
        let c = b * 2  // c = 30
        assert(c == 30)
    }

    test "propagate in loop condition" {
        let limit = 5
        let mut sum = 0
        let mut i = 0
        while i < limit {
            sum = sum + 1
            i = i + 1
        }
        assert(sum == 5)
    }

    test "propagate across multiple uses" {
        let constant = 42
        let a = constant + 1
        let b = constant * 2
        let c = constant - 10
        assert(a == 43)
        assert(b == 84)
        assert(c == 32)
    }

    test "propagate negative constant" {
        let neg = -10
        let result = neg + 20
        assert(result == 10)
    }

    test "propagate constant from expression" {
        // If the initializer is a constant expression, it should be folded
        // and then the folded value should be propagated
        let value = 2 + 3  // Folded to 5
        let result = value * 2  // Propagated as 5 * 2 = 10
        assert(result == 10)
    }

    // ============ String constant folding tests ============

    test "fold string concatenation" {
        // "hello" + " " + "world" should fold to "hello world"
        let result = "hello" + " " + "world"
        assert(result == "hello world")
    }

    test "fold empty string concatenation left" {
        // "" + "hello" should fold to "hello"
        let result = "" + "hello"
        assert(result == "hello")
    }

    test "fold empty string concatenation right" {
        // "hello" + "" should fold to "hello"
        let result = "hello" + ""
        assert(result == "hello")
    }

    test "fold two empty strings" {
        let result = "" + ""
        assert(result == "")
    }

    test "fold string equality true" {
        let result = "abc" == "abc"
        assert(result == true)
    }

    test "fold string equality false" {
        let result = "abc" == "def"
        assert(result == false)
    }

    test "fold string inequality true" {
        let result = "abc" != "def"
        assert(result == true)
    }

    test "fold string inequality false" {
        let result = "abc" != "abc"
        assert(result == false)
    }

    test "fold chained string concatenation" {
        // "a" + "b" + "c" + "d" should fold to "abcd"
        let result = "a" + "b" + "c" + "d"
        assert(result == "abcd")
    }

    test "propagate string constant" {
        let greeting = "hello"
        let result = greeting + " world"
        assert(result == "hello world")
    }

    test "propagate string constant to comparison" {
        let expected = "hello"
        let result = expected == "hello"
        assert(result == true)
    }

    test "chained string constant propagation" {
        let a = "hello"
        let b = a + " "
        let c = b + "world"
        assert(c == "hello world")
    }

    test "no propagation for mutable string" {
        let mut s = "hello"
        let a = s + " world"
        s = "goodbye"
        let b = s + " world"
        assert(a == "hello world")
        assert(b == "goodbye world")
    }

    // ============ Dead branch elimination tests ============

    test "eliminate if true statement with else" {
        // if true { a } else { b } => a
        let mut result = 0
        if true {
            result = 42
        } else {
            result = 99
        }
        assert(result == 42)
    }

    test "eliminate if false statement with else branch" {
        // if false { a } else { b } => b
        let mut result = 0
        if false {
            result = 42
        } else {
            result = 99
        }
        assert(result == 99)
    }

    test "eliminate if true no else" {
        // if true { a } => a (value is the then branch)
        let mut x = 0
        if true {
            x = 42
        }
        assert(x == 42)
    }

    test "eliminate if false no else" {
        // if false { a } => removed (dead code)
        let mut x = 10
        if false {
            x = 42
        }
        assert(x == 10)
    }

    test "eliminate if statement with propagated true constant" {
        // Constant propagation feeds into dead branch elimination
        let debug = true
        let mut result = "release mode"
        if debug {
            result = "debug mode"
        }
        assert(result == "debug mode")
    }

    test "eliminate if statement with propagated false constant" {
        let debug = false
        let mut result = "release mode"
        if debug {
            result = "debug mode"
        }
        assert(result == "release mode")
    }

    test "eliminate if statement with propagated false and else" {
        let verbose = false
        let mut output = "unknown"
        if verbose {
            output = "loud"
        } else {
            output = "quiet"
        }
        assert(output == "quiet")
    }

    test "eliminate nested if statements" {
        // Both levels should be eliminated
        let a = true
        let b = false
        let mut result = 0
        if a {
            if b {
                result = 1
            } else {
                result = 2
            }
        } else {
            result = 3
        }
        assert(result == 2)
    }

    test "eliminate when expression with true condition" {
        // when with constant true arm eliminates to that arm's body
        let result = when {
            true => 42,
            _ => 99,
        }
        assert(result == 42)
    }

    test "eliminate when expression with false condition" {
        // when with constant false arm falls through to wildcard
        let result = when {
            false => 42,
            _ => 99,
        }
        assert(result == 99)
    }

    test "eliminate when with propagated constant" {
        let debug = true
        let result = when {
            debug => "debug mode",
            _ => "release mode",
        }
        assert(result == "debug mode")
    }

    test "eliminate if with computed constant condition" {
        // Condition is a constant expression: 5 > 3 folds to true
        let mut result = "no"
        if 5 > 3 {
            result = "yes"
        }
        assert(result == "yes")
    }

    test "eliminate if with constant boolean expression" {
        // true && false folds to false, so the else branch is taken
        let mut result = 0
        if true && false {
            result = 100
        } else {
            result = 200
        }
        assert(result == 200)
    }

    test "eliminate if false statement with else" {
        let mode = false
        let mut result = "unknown"
        if mode {
            result = "on"
        } else {
            result = "off"
        }
        assert(result == "off")
    }

    test "eliminate dead branch preserves side effects in taken branch" {
        // The taken branch should still execute correctly
        let mut counter = 0
        if true {
            counter = counter + 1
            counter = counter + 1
            counter = counter + 1
        }
        assert(counter == 3)
    }

    test "eliminate dead branch with multiple statements" {
        // The dead branch has multiple statements that should all be eliminated
        let mut x = 0
        if false {
            x = 1
            x = x + 1
            x = x * 2
        }
        assert(x == 0)
    }

    test "chained constant propagation into statement if elimination" {
        // a = 10, b = a > 5 = true, if b { ... } => taken
        let a = 10
        let b = a > 5
        let mut result = "small"
        if b {
            result = "big"
        }
        assert(result == "big")
    }

    // ============ Pure intrinsic call folding tests ============
    // These test that calls to known-pure intrinsics with constant arguments
    // are evaluated at compile time (e.g., math.sqrt(4.0) -> 2.0)

    test "fold math.sqrt with constant f64" {
        let math = import "std:math"
        let result = math.sqrt(4.0)
        assert(result == 2.0)
    }

    test "fold math.sqrt of 0" {
        let math = import "std:math"
        let result = math.sqrt(0.0)
        assert(result == 0.0)
    }

    test "fold math.sqrt of 1" {
        let math = import "std:math"
        let result = math.sqrt(1.0)
        assert(result == 1.0)
    }

    test "fold math.abs with constant f64" {
        let math = import "std:math"
        let result = math.abs(-5.0)
        assert(result == 5.0)
    }

    test "fold math.abs positive value unchanged" {
        let math = import "std:math"
        let result = math.abs(3.0)
        assert(result == 3.0)
    }

    test "fold math.ceil with constant f64" {
        let math = import "std:math"
        let result = math.ceil(3.2)
        assert(result == 4.0)
    }

    test "fold math.ceil negative" {
        let math = import "std:math"
        let result = math.ceil(-3.8)
        assert(result == -3.0)
    }

    test "fold math.floor with constant f64" {
        let math = import "std:math"
        let result = math.floor(3.9)
        assert(result == 3.0)
    }

    test "fold math.floor negative" {
        let math = import "std:math"
        let result = math.floor(-3.2)
        assert(result == -4.0)
    }

    test "fold math.trunc with constant f64" {
        let math = import "std:math"
        let result = math.trunc(3.9)
        assert(result == 3.0)
    }

    test "fold math.trunc negative" {
        let math = import "std:math"
        let result = math.trunc(-3.9)
        assert(result == -3.0)
    }

    test "fold math.round with constant f64" {
        let math = import "std:math"
        let result = math.round(3.6)
        assert(result == 4.0)
    }

    test "fold math.round down" {
        let math = import "std:math"
        let result = math.round(3.4)
        assert(result == 3.0)
    }

    test "fold math.min with constant f64" {
        let math = import "std:math"
        let result = math.min(3.0, 5.0)
        assert(result == 3.0)
    }

    test "fold math.max with constant f64" {
        let math = import "std:math"
        let result = math.max(3.0, 5.0)
        assert(result == 5.0)
    }

    test "fold destructured sqrt with constant" {
        // Test the direct Call path (destructured import)
        let { sqrt } = import "std:math"
        let result = sqrt(9.0)
        assert(result == 3.0)
    }

    test "fold destructured abs with constant" {
        let { abs } = import "std:math"
        let result = abs(-7.0)
        assert(result == 7.0)
    }

    test "fold destructured min with constants" {
        let { min } = import "std:math"
        let result = min(10.0, 3.0)
        assert(result == 3.0)
    }

    test "fold destructured max with constants" {
        let { max } = import "std:math"
        let result = max(10.0, 3.0)
        assert(result == 10.0)
    }

    test "fold intrinsic with propagated constant" {
        let math = import "std:math"
        let x = 16.0
        let result = math.sqrt(x)
        assert(result == 4.0)
    }

    test "fold chained intrinsic calls" {
        let math = import "std:math"
        // sqrt(abs(-16.0)) = sqrt(16.0) = 4.0
        // Each step should fold independently
        let inner = math.abs(-16.0)
        let result = math.sqrt(inner)
        assert(result == 4.0)
    }

    test "fold integer abs via std:math" {
        let math = import "std:math"
        let x: i64 = -42
        let result = math.abs(x)
        assert(result == 42)
    }

    test "fold lowlevel clz" {
        let ll = import "std:lowlevel"
        let x: u64 = 1
        let result = ll.clz(x)
        assert(result == 63)
    }

    test "fold lowlevel ctz" {
        let ll = import "std:lowlevel"
        let x: u64 = 16
        let result = ll.ctz(x)
        assert(result == 4)
    }

    test "fold lowlevel popcnt" {
        let ll = import "std:lowlevel"
        let x: u64 = 0b10110111
        let result = ll.popcnt(x)
        assert(result == 6)
    }
}
