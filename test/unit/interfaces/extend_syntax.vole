interface Greetable {
    func greet() -> string
}

class Dog {
    name: string,
}

extend Dog with Greetable {
    func greet() -> string {
        return "Woof!"
    }
}

func greet_all(g: Greetable) -> string {
    return g.greet()
}

tests "extend Type with Interface" {
    test "extend adds method callable on value" {
        let d = Dog { name: "Rex" }
        assert(d.greet() == "Woof!")
    }

    test "extended type is accepted as interface argument" {
        let d = Dog { name: "Rex" }
        assert(greet_all(d) == "Woof!")
    }

    test "extended type can be stored in interface variable" {
        let g: Greetable = Dog { name: "Rex" }
        assert(g.greet() == "Woof!")
    }
}

interface Measurable {
    func length() -> i64
    func area() -> i64
}

class Rectangle {
    width: i64,
    height: i64,
}

extend Rectangle with Measurable {
    func length() -> i64 {
        return self.width + self.height
    }

    func area() -> i64 {
        return self.width * self.height
    }
}

tests "extend with multi-method interface" {
    test "all interface methods are available after extend" {
        let r = Rectangle { width: 3, height: 4 }
        assert(r.length() == 7)
        assert(r.area() == 12)
    }

    test "multi-method type accepted as interface value" {
        let m: Measurable = Rectangle { width: 5, height: 6 }
        assert(m.area() == 30)
    }
}

interface Tripler {
    func triple() -> i64
}

class Amount {
    value: i64,
}

extend Amount with Tripler {
    func triple() -> i64 => self.value * 3
}

tests "extend with expression-bodied method" {
    test "expression-bodied extend method works" {
        let a = Amount { value: 7 }
        assert(a.triple() == 21)
    }

    test "expression-bodied extend through interface value" {
        let t: Tripler = Amount { value: 14 }
        assert(t.triple() == 42)
    }
}

class Point {
    x: i64,
    y: i64,
}

extend Point {
    func magnitude_sq() -> i64 {
        return self.x * self.x + self.y * self.y
    }
}

tests "extend Type ad-hoc (file-scoped)" {
    test "ad-hoc extension method callable in same file" {
        let p = Point { x: 3, y: 4 }
        assert(p.magnitude_sq() == 25)
    }
}

class Counter {
    value: i64,
}

extend Counter {
    func doubled() -> i64 => self.value * 2
}

tests "extend Type ad-hoc expression body" {
    test "expression-bodied ad-hoc extension method works" {
        let c = Counter { value: 7 }
        assert(c.doubled() == 14)
    }
}

class Box {
    width: i64,
    height: i64,
    depth: i64,
}

extend Box {
    func volume() -> i64 {
        return self.width * self.height * self.depth
    }

    func surface_area() -> i64 {
        return 2 * (self.width * self.height + self.height * self.depth + self.width * self.depth)
    }
}

tests "extend Type ad-hoc multiple methods" {
    test "multiple ad-hoc extension methods on same type" {
        let b = Box { width: 2, height: 3, depth: 4 }
        assert(b.volume() == 24)
        assert(b.surface_area() == 52)
    }
}

interface Printable {
    func display() -> string
}

class Wrapper<T> {
    value: T,
}

extend Wrapper<i64> with Printable {
    func display() -> string => self.value.to_string()
}

tests "extend generic concrete specialization" {
    test "extend Wrapper<i64> with Printable - display returns string" {
        let w = Wrapper { value: 42 }
        assert(w.display() == "42")
    }

    test "extend Wrapper<i64> with Printable - accepted as interface argument" {
        let print_it = (p: Printable) -> string => p.display()
        let w = Wrapper { value: 100 }
        assert(print_it(w) == "100")
    }

    test "extend Wrapper<i64> with Printable - zero value" {
        let w = Wrapper { value: 0 }
        assert(w.display() == "0")
    }
}
