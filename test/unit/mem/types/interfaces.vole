// RC tests for interface values and dynamic dispatch.
//
// Interface values involve heap-allocated vtable pointers alongside the
// underlying class instance. These tests exercise creation, copy,
// reassignment, function passing, and method dispatch on interface values
// to verify RC inc/dec correctness for both the interface wrapper and
// the underlying class instance.

interface Greetable {
    func greet() -> string
}

interface Measurable {
    func measure() -> i64
}

class Dog implements Greetable {
    name: string,

    func greet() -> string {
        return self.name
    }
}

class Cat implements Greetable {
    name: string,
    lives: i64,

    func greet() -> string {
        return self.name
    }
}

class Ruler implements Measurable {
    length: i64,

    func measure() -> i64 {
        return self.length
    }
}

// Interface with multiple methods
interface Describable {
    func describe() -> string
    func tag() -> i64
}

class Widget implements Describable {
    label: string,
    id: i64,

    func describe() -> string {
        return self.label
    }

    func tag() -> i64 {
        return self.id
    }
}

class Gadget implements Describable {
    model: string,
    version: i64,

    func describe() -> string {
        return self.model
    }

    func tag() -> i64 {
        return self.version
    }
}

// Helper functions for interface passing
func accept_greetable(g: Greetable) -> string {
    return g.greet()
}

func accept_measurable(m: Measurable) -> i64 {
    return m.measure()
}

func accept_describable(d: Describable) -> string {
    return d.describe()
}

func accept_describable_tag(d: Describable) -> i64 {
    return d.tag()
}

func return_greetable_dog(name: string) -> Greetable {
    return Dog { name: name }
}

func return_greetable_cat(name: string, lives: i64) -> Greetable {
    return Cat { name: name, lives: lives }
}

func return_describable_widget(label: string, id: i64) -> Describable {
    return Widget { label: label, id: id }
}

func pass_through_greetable(g: Greetable) -> Greetable {
    return g
}

tests "store class as interface variable" {
    test "dog stored as Greetable" {
        let g: Greetable = Dog { name: "Rex" }
        assert(g.greet() == "Rex")
    }

    test "cat stored as Greetable" {
        let g: Greetable = Cat { name: "Whiskers", lives: 9 }
        assert(g.greet() == "Whiskers")
    }

    test "ruler stored as Measurable" {
        let m: Measurable = Ruler { length: 30 }
        assert(m.measure() == 30)
    }

    test "widget stored as Describable" {
        let d: Describable = Widget { label: "sprocket", id: 101 }
        assert(d.describe() == "sprocket")
        assert(d.tag() == 101)
    }
}

tests "pass interface to function parameter" {
    test "pass Greetable dog to function" {
        let g: Greetable = Dog { name: "Buddy" }
        let result = accept_greetable(g)
        assert(result == "Buddy")
        assert(g.greet() == "Buddy")
    }

    test "pass Greetable cat to function" {
        let g: Greetable = Cat { name: "Mittens", lives: 7 }
        let result = accept_greetable(g)
        assert(result == "Mittens")
    }

    test "pass Measurable to function" {
        let m: Measurable = Ruler { length: 100 }
        let result = accept_measurable(m)
        assert(result == 100)
        assert(m.measure() == 100)
    }

    test "pass Describable to function and read both methods" {
        let d: Describable = Widget { label: "cog", id: 42 }
        let desc = accept_describable(d)
        let t = accept_describable_tag(d)
        assert(desc == "cog")
        assert(t == 42)
    }

    // Commented out: segfault when passing concrete class directly where interface parameter expected
    // test "pass concrete class where interface expected" {
    //     let dog = Dog { name: "Fido" }
    //     let result = accept_greetable(dog)
    //     assert(result == "Fido")
    // }
}

tests "call methods on interface value" {
    test "call greet on interface value multiple times" {
        let g: Greetable = Dog { name: "Spot" }
        let r1 = g.greet()
        let r2 = g.greet()
        let r3 = g.greet()
        assert(r1 == "Spot")
        assert(r2 == "Spot")
        assert(r3 == "Spot")
    }

    test "call both methods on Describable interface" {
        let d: Describable = Gadget { model: "gizmo-3000", version: 3 }
        assert(d.describe() == "gizmo-3000")
        assert(d.tag() == 3)
    }

    test "call method result stored in variable" {
        let g: Greetable = Cat { name: "Shadow", lives: 5 }
        let greeting = g.greet()
        assert(greeting == "Shadow")
    }
}

tests "return interface from function" {
    test "return Greetable dog from function" {
        let g = return_greetable_dog("Bruno")
        assert(g.greet() == "Bruno")
    }

    test "return Greetable cat from function" {
        let g = return_greetable_cat("Luna", 9)
        assert(g.greet() == "Luna")
    }

    test "return Describable widget from function" {
        let d = return_describable_widget("bolt", 77)
        assert(d.describe() == "bolt")
        assert(d.tag() == 77)
    }

    test "pass through interface value and read" {
        let g: Greetable = Dog { name: "Max" }
        let returned = pass_through_greetable(g)
        assert(returned.greet() == "Max")
        assert(g.greet() == "Max")
    }

    test "chain return and pass" {
        let g = return_greetable_dog("Daisy")
        let result = accept_greetable(g)
        assert(result == "Daisy")
    }
}

tests "multiple classes implementing same interface" {
    test "dog and cat both implement Greetable" {
        let dog: Greetable = Dog { name: "Rex" }
        let cat: Greetable = Cat { name: "Felix", lives: 9 }
        assert(dog.greet() == "Rex")
        assert(cat.greet() == "Felix")
    }

    test "widget and gadget both implement Describable" {
        let w: Describable = Widget { label: "widget-A", id: 1 }
        let g: Describable = Gadget { model: "gadget-B", version: 2 }
        assert(w.describe() == "widget-A")
        assert(w.tag() == 1)
        assert(g.describe() == "gadget-B")
        assert(g.tag() == 2)
    }

    test "pass different implementors to same function" {
        let dog: Greetable = Dog { name: "Ace" }
        let cat: Greetable = Cat { name: "Cleo", lives: 3 }
        let r1 = accept_greetable(dog)
        let r2 = accept_greetable(cat)
        assert(r1 == "Ace")
        assert(r2 == "Cleo")
    }

    test "multiple instances of different implementors" {
        let d1: Describable = Widget { label: "alpha", id: 10 }
        let d2: Describable = Gadget { model: "beta", version: 20 }
        let d3: Describable = Widget { label: "gamma", id: 30 }
        assert(d1.tag() + d2.tag() + d3.tag() == 60)
    }
}

tests "interface with string-returning methods" {
    test "string return from interface method into variable" {
        let g: Greetable = Dog { name: "Pepper" }
        let s = g.greet()
        assert(s == "Pepper")
    }

    test "string return from interface passed to function" {
        let d: Describable = Widget { label: "spring", id: 5 }
        let desc = accept_describable(d)
        assert(desc == "spring")
    }

    test "multiple string returns from different implementors" {
        let g1: Greetable = Dog { name: "Apollo" }
        let g2: Greetable = Cat { name: "Artemis", lives: 8 }
        let s1 = g1.greet()
        let s2 = g2.greet()
        assert(s1 == "Apollo")
        assert(s2 == "Artemis")
    }

    test "string return reused after interface method call" {
        let d: Describable = Gadget { model: "turbo", version: 7 }
        let desc1 = d.describe()
        let desc2 = d.describe()
        assert(desc1 == "turbo")
        assert(desc2 == "turbo")
    }
}

tests "reassign interface variable to different implementing class" {
    test "reassign Greetable from dog to cat" {
        let mut g: Greetable = Dog { name: "Rover" }
        assert(g.greet() == "Rover")
        g = Cat { name: "Misty", lives: 6 }
        assert(g.greet() == "Misty")
    }

    test "reassign Describable from widget to gadget" {
        let mut d: Describable = Widget { label: "old-widget", id: 1 }
        assert(d.describe() == "old-widget")
        assert(d.tag() == 1)
        d = Gadget { model: "new-gadget", version: 99 }
        assert(d.describe() == "new-gadget")
        assert(d.tag() == 99)
    }

    test "reassign multiple times" {
        let mut g: Greetable = Dog { name: "First" }
        assert(g.greet() == "First")
        g = Cat { name: "Second", lives: 2 }
        assert(g.greet() == "Second")
        g = Dog { name: "Third" }
        assert(g.greet() == "Third")
    }

    test "reassign with function return value" {
        let mut g: Greetable = Dog { name: "Initial" }
        assert(g.greet() == "Initial")
        g = return_greetable_cat("Replaced", 4)
        assert(g.greet() == "Replaced")
    }
}

tests "interface in optional" {
    test "optional interface with value" {
        let iface: Greetable = Dog { name: "Biscuit" }
        let g: Greetable? = iface
        assert(g is Greetable)
    }

    test "optional interface with nil" {
        let g: Greetable? = nil
        assert(g is nil)
    }

    test "optional interface null coalescing with concrete" {
        let g: Greetable? = nil
        let fallback: Greetable = Dog { name: "Default" }
        let result = g ?? fallback
        assert(result.greet() == "Default")
    }

    test "optional interface null coalescing with value present" {
        let iface: Greetable = Cat { name: "Present", lives: 5 }
        let g: Greetable? = iface
        let fallback: Greetable = Dog { name: "Fallback" }
        let result = g ?? fallback
        assert(result.greet() == "Present")
    }

    test "optional Describable with value" {
        let iface: Describable = Widget { label: "maybe-widget", id: 55 }
        let d: Describable? = iface
        assert(d is Describable)
    }

    test "optional Describable nil" {
        let d: Describable? = nil
        assert(d is nil)
    }
}
