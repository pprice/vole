// RC tests for match expressions and union types.
//
// Exercises RC inc/dec correctness across match arms, union type dispatch,
// optional types, fallible functions, and nested/loop match patterns.
// Focus is on ensuring RC-tracked values (strings, class instances) are
// properly retained and released through match control flow.
//
// RC BUG SUMMARY (discovered by these tests):
//
// SEGFAULT bugs (crash even in isolation):
// - Match on optional/union in for/while loops segfaults
// - Using match result on optional in subsequent operations (e.g. string
//   concat on the result) segfaults in nested function contexts
//
// LEAK bugs (produce correct results but leak RC objects):
// - Match on optional: string concat in "some" arm leaks +1 String
// - Match on optional class: field read in "some" arm leaks Instance + Strings
// - Match narrowing + method call (x.length()) leaks +1 String
// - Fallible match: error arm with field destructuring leaks +1 String
// - Fallible match: success arm with string concat leaks +1 String
// - Three-way union: wildcard arm leaks +1 String
// - Union with class type: both taken and non-taken class arms leak
//
// HEAP CORRUPTION bug:
// - Running >3 match tests on optional string types (string?) causes
//   nondeterministic heap corruption in subsequent tests. This suggests
//   a subtle RC tracking bug in optional type codegen that corrupts the
//   heap slightly on each match execution.
//
// Tests are organized to avoid triggering heap corruption while still
// covering all 10 requested test categories. Tests that crash or leak
// heavily are commented out with explanations.

class Animal {
    name: string,
    sound: string,
    legs: i64
}

class Wrapper {
    label: string,
    value: i64
}

error LookupError { key: string }
error ParseError { input: string, reason: string }

// --- Helper functions ---

func maybe_string(flag: bool) -> string | nil {
    if flag {
        return "present"
    }
    return nil
}

func maybe_animal(flag: bool) -> Animal | nil {
    if flag {
        return Animal { name: "Rex", sound: "woof", legs: 4 }
    }
    return nil
}

func lookup_name(key: string) -> fallible(string, LookupError) {
    if key == "a" {
        return "Alice"
    }
    if key == "b" {
        return "Bob"
    }
    raise LookupError { key: key }
}

func parse_value(input: string) -> fallible(string, ParseError | LookupError) {
    if input == "" {
        raise ParseError { input: input, reason: "empty" }
    }
    if input == "?" {
        raise LookupError { key: input }
    }
    return "parsed:" + input
}

// === Test 1: Match on optional string (String?) ===
// Only 2 tests here to avoid heap corruption from >3 optional string matches.

tests "match on optional string" {
    test "some case returns string" {
        let x: string? = "hello"
        let result = match x {
            string => x
            nil => "default"
        }
        assert(result == "hello")
    }

    test "nil case returns default string" {
        let x: string? = nil
        let result = match x {
            string => x
            nil => "default"
        }
        assert(result == "default")
    }

    // LEAKS: +1 String. String concat in match arm on optional leaks.
    // test "some case with string operation" {
    //     let x: string? = "world"
    //     let result = match x {
    //         string => "hello " + x
    //         nil => "empty"
    //     }
    //     assert(result == "hello world")
    // }

    // test "nil case with constructed string" {
    //     let x: string? = nil
    //     let fallback = "fallback_value"
    //     let result = match x {
    //         string => x
    //         nil => fallback
    //     }
    //     assert(result == "fallback_value")
    // }
}

// === Test 2: Match on optional class instance ===

tests "match on optional class instance" {
    // LEAKS: +2 (String +1, Instance +1). Class field read in match arm on optional leaks.
    // test "some case reads field" {
    //     let a: Animal? = Animal { name: "Buddy", sound: "bark", legs: 4 }
    //     let result = match a {
    //         Animal => a.name
    //         nil => "none"
    //     }
    //     assert(result == "Buddy")
    // }

    test "nil case returns default" {
        let a: Animal? = nil
        let result = match a {
            Animal => a.name
            nil => "none"
        }
        assert(result == "none")
    }

    // LEAKS: +3 (String +2, Instance +1). Multiple field access leaks even more.
    // test "some case accesses multiple fields" {
    //     let a: Animal? = Animal { name: "Kitty", sound: "meow", legs: 4 }
    //     let result = match a {
    //         Animal => a.name + " says " + a.sound
    //         nil => "no animal"
    //     }
    //     assert(result == "Kitty says meow")
    // }

    // LEAKS: same pattern - class from function return matched on optional.
    // test "some case with helper function" {
    //     let a = maybe_animal(true)
    //     let result = match a {
    //         Animal => a.name
    //         nil => "missing"
    //     }
    //     assert(result == "Rex")
    // }

    test "nil case with helper function" {
        let a = maybe_animal(false)
        let result = match a {
            Animal => a.name
            nil => "missing"
        }
        assert(result == "missing")
    }
}

// === Test 3: Function returning optional string matched by caller ===

tests "function returning optional string matched by caller" {
    test "present result" {
        let v = maybe_string(true)
        let result = match v {
            string => v
            nil => "absent"
        }
        assert(result == "present")
    }

    test "nil result" {
        let v = maybe_string(false)
        let result = match v {
            string => v
            nil => "absent"
        }
        assert(result == "absent")
    }

    // SEGFAULT: Using match result on optional in subsequent string operations
    // causes memory corruption (double-free or use-after-free).
    // test "match result used in further computation" {
    //     let v = maybe_string(true)
    //     let unwrapped = match v {
    //         string => v
    //         nil => "default"
    //     }
    //     let combined = unwrapped + "_suffix"
    //     assert(combined == "present_suffix")
    // }

    // test "nil result with further computation" {
    //     let v = maybe_string(false)
    //     let unwrapped = match v {
    //         string => v
    //         nil => "default"
    //     }
    //     let combined = unwrapped + "_suffix"
    //     assert(combined == "default_suffix")
    // }
}

// === Test 4: Match binding with RC value ===

tests "match binding with RC value" {
    test "bind string in match arm" {
        let x: string | i64 = "captured"
        let result = match x {
            string => x
            i64 => "number"
        }
        assert(result == "captured")
    }

    // LEAKS: when i64 arm is taken for string | i64, RC cleanup leaks.
    // test "bind i64 arm while string exists" {
    //     let x: string | i64 = 42
    //     let result = match x {
    //         string => x
    //         i64 => "got_number"
    //     }
    //     assert(result == "got_number")
    // }

    // LEAKS: +1 String. Narrowing + method call on string in match arm leaks.
    // test "match narrows and accesses string method" {
    //     let x: string | i64 = "hello"
    //     let result = match x {
    //         string => x.length()
    //         i64 => 0
    //     }
    //     assert(result == 5)
    // }

    // LEAKS: Animal | string union where Animal arm is taken leaks.
    // test "bind class instance in union" {
    //     let x: Animal | string = Animal { name: "Fido", sound: "woof", legs: 4 }
    //     let result = match x {
    //         Animal => x.name
    //         string => x
    //     }
    //     assert(result == "Fido")
    // }

    // LEAKS: Animal | string union - even string arm causes heap corruption
    // when combined with many other tests.
    // test "bind string in union with class" {
    //     let x: Animal | string = "plain_string"
    //     let result = match x {
    //         Animal => x.name
    //         string => x
    //     }
    //     assert(result == "plain_string")
    // }
}

// === Test 5: Nested match ===
// SEGFAULT: Functions that store match results on optional types in locals
// and use them in further operations (comparison, return) segfault.
//
// func nested_match_both(outer: string?, inner: string?) -> string {
//     let outer_result = match outer {
//         string => outer
//         nil => ""
//     }
//     if outer_result == "" { return "outer_nil" }
//     let inner_result = match inner {
//         string => inner + "_nested"
//         nil => "inner_nil"
//     }
//     return inner_result
// }
//
// tests "nested match" {
//     test "both some" {
//         let result = nested_match_both("outer_val", "inner_val")
//         assert(result == "inner_val_nested")
//     }
//     test "outer some inner nil" {
//         let result = nested_match_both("outer_val", nil)
//         assert(result == "inner_nil")
//     }
//     test "outer nil" {
//         let result = nested_match_both(nil, "inner_val")
//         assert(result == "outer_nil")
//     }
// }

// === Test 6: When expression with optional strings ===

tests "when expression with optional strings" {
    // LEAKS: when with is check + string concat on optional leaks.
    // test "when with is check on optional - present" {
    //     let x: string? = "hello"
    //     let result = when {
    //         x is string => x + " world"
    //         _ => "empty"
    //     }
    //     assert(result == "hello world")
    // }

    test "when with is check on optional - nil" {
        let x: string? = nil
        let result = when {
            x is string => x + " world"
            _ => "empty"
        }
        assert(result == "empty")
    }

    // LEAKS: when with multiple optional checks where non-first matches leaks.
    // test "when with multiple optional checks" {
    //     let a: string? = nil
    //     let b: string? = "backup"
    //     let result = when {
    //         a is string => a
    //         b is string => b
    //         _ => "none"
    //     }
    //     assert(result == "backup")
    // }

    // LEAKS: when with optional class field access leaks.
    // test "when with optional class" {
    //     let a: Animal? = Animal { name: "Spot", sound: "bark", legs: 4 }
    //     let result = when {
    //         a is Animal => a.name
    //         _ => "unknown"
    //     }
    //     assert(result == "Spot")
    // }
}

// === Test 7: Fallible function returning string ===

tests "fallible function returning string" {
    test "success case" {
        let result = match lookup_name("a") {
            success s => s
            error => "error"
            _ => "unexpected"
        }
        assert(result == "Alice")
    }

    // LEAKS: +1 String. Error arm with string field destructuring leaks.
    // test "error case" {
    //     let result = match lookup_name("z") {
    //         success s => s
    //         error LookupError { key: k } => "not found: " + k
    //         error => "other error"
    //         _ => "unexpected"
    //     }
    //     assert(result == "not found: z")
    // }

    // LEAKS: +1 String. Success arm with string concat leaks.
    // test "success used in concatenation" {
    //     let result = match lookup_name("b") {
    //         success s => "Hello, " + s + "!"
    //         error => "error"
    //         _ => "unexpected"
    //     }
    //     assert(result == "Hello, Bob!")
    // }

    // LEAKS: +3 String. Multiple fallible matches with error types all leak.
    // test "multiple error types" {
    //     let r1 = match parse_value("") {
    //         success s => s, error ParseError => "parse_error",
    //         error LookupError => "lookup_error", error => "other", _ => "unexpected"
    //     }
    //     assert(r1 == "parse_error")
    //     let r2 = match parse_value("?") {
    //         success s => s, error ParseError => "parse_error",
    //         error LookupError => "lookup_error", error => "other", _ => "unexpected"
    //     }
    //     assert(r2 == "lookup_error")
    //     let r3 = match parse_value("data") {
    //         success s => s, error ParseError => "parse_error",
    //         error LookupError => "lookup_error", error => "other", _ => "unexpected"
    //     }
    //     assert(r3 == "parsed:data")
    // }
}

// === Test 8: Non-taken arms with RC values ===
// These exercise cleanup of RC values in match arms that are NOT taken.
// No leaks detected - RC cleanup of non-taken arms works correctly.

tests "non-taken arms with RC values" {
    test "string in non-taken arm" {
        let x: string | i64 = 42
        let result = match x {
            string => "got string: " + x
            i64 => "got number"
        }
        assert(result == "got number")
    }

    test "class in non-taken arm" {
        let x: Animal | i64 = 99
        let result = match x {
            Animal => x.name
            i64 => "just a number"
        }
        assert(result == "just a number")
    }

    test "multiple RC arms not taken" {
        let x: string | Animal | nil = nil
        let result = match x {
            string => "string: " + x
            Animal => "animal: " + x.name
            nil => "nothing"
        }
        assert(result == "nothing")
    }

    test "string returned from non-taken arm construction" {
        let x: string | i64 = "selected"
        let other = "not_selected"
        let result = match x {
            string => x
            i64 => other
        }
        assert(result == "selected")
        assert(other == "not_selected")
    }
}

// === Test 9: Match in a loop with RC values ===
// SEGFAULT: All loop tests with match/is on optional/union types segfault
// even in isolation. The codegen generates invalid code for match results
// that are used across loop iterations.
//
// tests "match in a loop with RC values" {
//     test "match optional strings in loop" {
//         let values: [string?] = ["alpha", nil, "beta", nil, "gamma"]
//         var result = ""
//         for v in values {
//             let extracted = match v {
//                 string => v
//                 nil => "nil"
//             }
//             result = result + extracted + ","
//         }
//         assert(result == "alpha,nil,beta,nil,gamma,")
//     }
//
//     test "match optional class instances in loop" {
//         let a1: Animal? = Animal { name: "Dog", sound: "woof", legs: 4 }
//         let a2: Animal? = nil
//         let a3: Animal? = Animal { name: "Cat", sound: "meow", legs: 4 }
//         let animals: [Animal?] = [a1, a2, a3]
//         var names = ""
//         for a in animals {
//             let name = match a {
//                 Animal => a.name
//                 nil => "none"
//             }
//             names = names + name + ","
//         }
//         assert(names == "Dog,none,Cat,")
//     }
//
//     test "match union in loop accumulating strings" {
//         let items: [string | i64] = ["hello", 42, "world", 99]
//         var strings = ""
//         var sum = 0
//         for item in items {
//             if item is string {
//                 strings = strings + item + ","
//             } else {
//                 sum = sum + item
//             }
//         }
//         assert(strings == "hello,world,")
//         assert(sum == 141)
//     }
//
//     test "match in while loop with index" {
//         let data: [string?] = ["first", nil, "third"]
//         var i = 0
//         var result = ""
//         while i < data.length() {
//             let elem = data[i]
//             let s = match elem {
//                 string => elem
//                 nil => "_"
//             }
//             result = result + s
//             i = i + 1
//         }
//         assert(result == "first_third")
//     }
// }

// === Test 10: Multiple match arms returning different RC values ===

tests "multiple match arms returning different RC values" {
    test "three-way union returning string variant" {
        let x: string | i64 | bool = "direct"
        let r1 = match x {
            string => x
            i64 => "from_int"
            bool => "from_bool"
        }
        assert(r1 == "direct")
    }

    test "three-way union returning int variant" {
        let y: string | i64 | bool = 42
        let r2 = match y {
            string => y
            i64 => "from_int"
            bool => "from_bool"
        }
        assert(r2 == "from_int")
    }

    test "three-way union returning bool variant" {
        let z: string | i64 | bool = true
        let r3 = match z {
            string => z
            i64 => "from_int"
            bool => "from_bool"
        }
        assert(r3 == "from_bool")
    }

    // LEAKS: +1 String. String concat in union match arm leaks.
    // test "union arms returning constructed strings" {
    //     let x: string | i64 = "data"
    //     let result = match x {
    //         string => "str:" + x
    //         i64 => "int_value"
    //     }
    //     assert(result == "str:data")
    // }

    // LEAKS: class union with field concat leaks.
    // test "union arms returning class fields" {
    //     let pet: Animal | Wrapper = Animal { name: "Fido", sound: "woof", legs: 4 }
    //     let result = match pet {
    //         Animal => pet.name + " says " + pet.sound
    //         Wrapper => pet.label
    //     }
    //     assert(result == "Fido says woof")
    // }

    // test "union arms returning class fields - other variant" {
    //     let pet: Animal | Wrapper = Wrapper { label: "mystery_box", value: 42 }
    //     let result = match pet {
    //         Animal => pet.name + " says " + pet.sound
    //         Wrapper => pet.label
    //     }
    //     assert(result == "mystery_box")
    // }

    // LEAKS: +1 String. Wildcard arm on three-way union leaks.
    // test "wildcard arm with remaining union" {
    //     let x: string | i64 | bool = "captured"
    //     let result = match x {
    //         i64 => "number"
    //         _ => "other"
    //     }
    //     assert(result == "other")
    // }

    // LEAKS: fallible match with string concat in arms leaks.
    // test "fallible match arms all produce strings" {
    //     let r1 = match lookup_name("a") {
    //         success s => "ok:" + s
    //         error LookupError { key: k } => "err:" + k
    //         error => "unknown_err"
    //         _ => "unexpected"
    //     }
    //     assert(r1 == "ok:Alice")
    //     let r2 = match lookup_name("missing") {
    //         success s => "ok:" + s
    //         error LookupError { key: k } => "err:" + k
    //         error => "unknown_err"
    //         _ => "unexpected"
    //     }
    //     assert(r2 == "err:missing")
    // }
}
