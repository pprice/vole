class Score {
    value: i64
}

class UnionBox {
    vals: [i64 | string]
}

class GenericHolder<T> {
    vals: [T]
}

class Nested {
    vals: [[i64 | string]]
}

struct Point {
    x: i64,
    y: i64,
}

sentinel Missing

func sum_numbers(arr: [i64 | string]) -> i64 {
    var sum: i64 = 0
    for item in arr {
        if item is i64 {
            sum = sum + item
        }
    }
    return sum
}

func make_holder<T>(vals: [T]) -> GenericHolder<T> {
    return GenericHolder { vals: vals }
}

tests "for-array inline get coverage" {
    test "primitive array elements in for loop" {
        let arr = [1_i32, 2_i32, 3_i32, 4_i32]
        var sum: i64 = 0
        for item in arr {
            sum = sum + item
        }
        assert(sum == 10)
    }

    test "union array elements in for loop" {
        let arr: [i64 | string] = [1, "two", 3, "four"]
        var nums: i64 = 0
        var words = ""
        for item in arr {
            if item is i64 {
                nums = nums + item
            } else {
                words = words + item + ","
            }
        }
        assert(nums == 4)
        assert(words == "two,four,")
    }

    test "optional array elements in for loop" {
        let arr: [i64?] = [1, nil, 3, nil]
        var sum: i64 = 0
        var nils = 0
        for item in arr {
            if item == nil {
                nils = nils + 1
            } else {
                sum = sum + (item ?? 0)
            }
        }
        assert(sum == 4)
        assert(nils == 2)
    }

    test "class array elements in for loop" {
        let arr = [Score { value: 5 }, Score { value: 7 }, Score { value: 9 }]
        var sum = 0
        for item in arr {
            sum = sum + item.value
        }
        assert(sum == 21)
    }

    test "struct array elements in for loop" {
        let arr = [Point { x: 1, y: 10 }, Point { x: 2, y: 20 }]
        var sum = 0
        for item in arr {
            sum = sum + item.x + item.y
        }
        assert(sum == 33)
    }

    test "tuple array elements in for loop" {
        let arr: [[i64, i64]] = [[1, 10], [2, 20], [3, 30]]
        var sum = 0
        for item in arr {
            sum = sum + item[0] + item[1]
        }
        assert(sum == 66)
    }

    test "union array literal in class field is safe for for-loop inline get" {
        let b = UnionBox { vals: [1, "x", 2, "y"] }
        var sum: i64 = 0
        for item in b.vals {
            if item is i64 {
                sum = sum + item
            }
        }
        assert(sum == 3)
    }

    test "union array literal passed to typed function arg is safe" {
        let vals: [i64 | string] = [1, "two", 3]
        assert(sum_numbers(vals) == 4)
    }

    test "nested union arrays in class field are safe" {
        let n = Nested { vals: [[1, "a"], [2, "b"]] }
        var sum: i64 = 0
        for inner in n.vals {
            for item in inner {
                if item is i64 {
                    sum = sum + item
                }
            }
        }
        assert(sum == 3)
    }

    test "generic T union array in class field is safe" {
        let vals: [i64 | string] = [1, "x", 2, "y"]
        let h = make_holder(vals)
        var sum: i64 = 0
        for item in h.vals {
            if item is i64 {
                sum = sum + item
            }
        }
        assert(sum == 3)
    }

    test "generic container of T (array of union arrays) is safe" {
        let vals: [[i64 | string]] = [[1, "x"], [2, "y"]]
        let h = make_holder(vals)
        var sum: i64 = 0
        for inner in h.vals {
            for item in inner {
                if item is i64 {
                    sum = sum + item
                }
            }
        }
        assert(sum == 3)
    }

    test "sentinel union arrays use boxed fallback and stay correct" {
        let arr: [i64 | Missing] = [1, Missing, 2]
        var sum: i64 = 0
        var missing = 0
        for item in arr {
            if item is i64 {
                sum = sum + item
            } else {
                missing = missing + 1
            }
        }
        assert(sum == 3)
        assert(missing == 1)
    }
}
