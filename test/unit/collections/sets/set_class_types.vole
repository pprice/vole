// Test: Set with class types (methods, RC fields)
// Exercises Set<T> where T is a class with methods or RC fields.
let { Set } = import "std:collections/set"

class Color {
    r: i64,
    g: i64,
    b: i64,

    func brightness() -> i64 {
        return self.r + self.g + self.b
    }
}

implement Hashable for Color {
    func hash() -> i64 {
        return self.r * 65536 + self.g * 256 + self.b
    }
}

implement Equatable for Color {
    func equals(other: Color) -> bool {
        return self.r == other.r && self.g == other.g && self.b == other.b
    }
}

class Tag {
    label: string,
    priority: i64,
}

implement Hashable for Tag {
    func hash() -> i64 {
        return self.label.hash() * 31 + self.priority
    }
}

implement Equatable for Tag {
    func equals(other: Tag) -> bool {
        return self.label.equals(other.label) && self.priority == other.priority
    }
}

tests {
    // ---- Class with methods ----

    test "set<Color> basic ops" {
        let s = Set.new<Color>()
        let red = Color { r: 255, g: 0, b: 0 }
        let green = Color { r: 0, g: 255, b: 0 }
        let blue = Color { r: 0, g: 0, b: 255 }

        assert(s.add(red))
        assert(s.add(green))
        assert(s.add(blue))
        assert(s.len() == 3)

        assert(s.contains(red))
        assert(s.contains(green))
        assert(s.contains(blue))

        // Equal-but-different instance
        let red2 = Color { r: 255, g: 0, b: 0 }
        assert(s.contains(red2))
        assert(!s.add(red2))
        assert(s.len() == 3)

        // Methods still work
        assert(red.brightness() == 255)
    }

    test "set<Color> intersection and difference" {
        let red = Color { r: 255, g: 0, b: 0 }
        let green = Color { r: 0, g: 255, b: 0 }
        let blue = Color { r: 0, g: 0, b: 255 }
        let yellow = Color { r: 255, g: 255, b: 0 }

        let a = Set.new<Color>()
        _ = a.add(red)
        _ = a.add(green)
        _ = a.add(blue)

        let b = Set.new<Color>()
        _ = b.add(green)
        _ = b.add(blue)
        _ = b.add(yellow)

        let inter = a.intersection(b)
        assert(inter.len() == 2)
        let check_green = Color { r: 0, g: 255, b: 0 }
        let check_blue = Color { r: 0, g: 0, b: 255 }
        let check_red = Color { r: 255, g: 0, b: 0 }
        assert(inter.contains(check_green))
        assert(inter.contains(check_blue))
        assert(!inter.contains(check_red))

        let diff = a.difference(b)
        assert(diff.len() == 1)
        let check_red2 = Color { r: 255, g: 0, b: 0 }
        assert(diff.contains(check_red2))
    }

    // ---- Class with RC fields (string) ----

    test "set<Tag> basic ops with string fields" {
        let s = Set.new<Tag>()
        let t1 = Tag { label: "urgent", priority: 1 }
        let t2 = Tag { label: "low", priority: 3 }
        let t3 = Tag { label: "medium", priority: 2 }

        assert(s.add(t1))
        assert(s.add(t2))
        assert(s.add(t3))
        assert(s.len() == 3)

        assert(s.contains(t1))
        assert(s.contains(t2))
        assert(s.contains(t3))

        // Equal-but-different instance
        let t1_copy = Tag { label: "urgent", priority: 1 }
        assert(s.contains(t1_copy))
        assert(!s.add(t1_copy))

        // Same label, different priority should not match
        let t1_diff = Tag { label: "urgent", priority: 2 }
        assert(!s.contains(t1_diff))
    }

    test "set<Tag> remove" {
        let s = Set.new<Tag>()
        let t1 = Tag { label: "alpha", priority: 1 }
        let t2 = Tag { label: "beta", priority: 2 }
        let t3 = Tag { label: "gamma", priority: 3 }
        _ = s.add(t1)
        _ = s.add(t2)
        _ = s.add(t3)
        assert(s.len() == 3)

        let t2_check = Tag { label: "beta", priority: 2 }
        assert(s.remove(t2_check))
        assert(s.len() == 2)
        let t2_check2 = Tag { label: "beta", priority: 2 }
        assert(!s.contains(t2_check2))
        assert(s.contains(t1))
        assert(s.contains(t3))
    }

    // ---- Additional coverage ----

    test "set<Color> is_empty" {
        let s = Set.new<Color>()
        assert(s.is_empty())

        let c = Color { r: 1, g: 2, b: 3 }
        _ = s.add(c)
        assert(!s.is_empty())
    }

    test "set<Color> remove missing" {
        let s = Set.new<Color>()
        let c = Color { r: 10, g: 20, b: 30 }
        _ = s.add(c)

        let missing = Color { r: 99, g: 99, b: 99 }
        assert(!s.remove(missing))
        assert(s.len() == 1)
    }

    test "set<Tag> clear with RC fields" {
        let s = Set.new<Tag>()
        let t1 = Tag { label: "first", priority: 1 }
        let t2 = Tag { label: "second", priority: 2 }
        _ = s.add(t1)
        _ = s.add(t2)
        assert(s.len() == 2)

        s.clear()
        assert(s.len() == 0)
        assert(s.is_empty())
        let check = Tag { label: "first", priority: 1 }
        assert(!s.contains(check))
    }

    test "set<Color> symmetric_difference" {
        let red = Color { r: 255, g: 0, b: 0 }
        let green = Color { r: 0, g: 255, b: 0 }
        let blue = Color { r: 0, g: 0, b: 255 }
        let white = Color { r: 255, g: 255, b: 255 }

        let a = Set.new<Color>()
        _ = a.add(red)
        _ = a.add(green)
        _ = a.add(blue)

        let b = Set.new<Color>()
        _ = b.add(green)
        _ = b.add(blue)
        _ = b.add(white)

        let sd = a.symmetric_difference(b)
        assert(sd.len() == 2)
        let check_red = Color { r: 255, g: 0, b: 0 }
        let check_white = Color { r: 255, g: 255, b: 255 }
        let check_green = Color { r: 0, g: 255, b: 0 }
        assert(sd.contains(check_red))
        assert(sd.contains(check_white))
        assert(!sd.contains(check_green))
    }

    test "set<Color> is_subset and is_superset" {
        let red = Color { r: 255, g: 0, b: 0 }
        let green = Color { r: 0, g: 255, b: 0 }
        let blue = Color { r: 0, g: 0, b: 255 }

        let small = Set.new<Color>()
        _ = small.add(red)
        _ = small.add(green)

        let big = Set.new<Color>()
        _ = big.add(red)
        _ = big.add(green)
        _ = big.add(blue)

        assert(small.is_subset(big))
        assert(!small.is_superset(big))
        assert(!big.is_subset(small))
        assert(big.is_superset(small))
    }

    test "set<Color> is_disjoint" {
        let red = Color { r: 255, g: 0, b: 0 }
        let green = Color { r: 0, g: 255, b: 0 }
        let blue = Color { r: 0, g: 0, b: 255 }
        let white = Color { r: 255, g: 255, b: 255 }

        let a = Set.new<Color>()
        _ = a.add(red)
        _ = a.add(green)

        let b = Set.new<Color>()
        _ = b.add(blue)
        _ = b.add(white)

        assert(a.is_disjoint(b))

        _ = b.add(red)
        assert(!a.is_disjoint(b))
    }

    // NOTE: Set.iter() segfaults (vol-i5za), iter tests omitted until fixed.
}
