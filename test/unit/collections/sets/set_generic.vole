// Test: Generic Set with non-i64 element types
// Exercises Set<T> with string elements, custom Hashable+Equatable types,
// and set operations (union, intersection) on generic instantiations.
let { Set } = import "std:collections/set"

class Point {
    x: i64,
    y: i64,
}

implement Hashable for Point {
    func hash() -> i64 {
        return self.x * 31 + self.y
    }
}

implement Equatable for Point {
    func equals(other: Point) -> bool {
        return self.x == other.x && self.y == other.y
    }
}

tests {
    test "set<string> basic ops" {
        let s = Set.new<string>()
        assert(s.add("hello"))
        assert(s.add("world"))
        assert(s.add("foo"))

        assert(s.len() == 3)
        assert(s.contains("hello"))
        assert(s.contains("world"))
        assert(s.contains("foo"))
        assert(!s.contains("bar"))
        assert(!s.is_empty())
    }

    test "set<string> add duplicate returns false" {
        let s = Set.new<string>()
        assert(s.add("apple"))
        assert(s.add("banana"))
        assert(!s.add("apple"))  // duplicate
        assert(!s.add("banana")) // duplicate
        assert(s.len() == 2)
    }

    test "set<string> remove" {
        let s = Set.new<string>()
        _ = s.add("one")
        _ = s.add("two")
        _ = s.add("three")
        assert(s.len() == 3)

        assert(s.remove("two"))
        assert(s.len() == 2)
        assert(!s.contains("two"))
        assert(s.contains("one"))
        assert(s.contains("three"))

        assert(!s.remove("missing"))
        assert(s.len() == 2)
    }

    test "set<Point> custom type" {
        let s = Set.new<Point>()
        let p1 = Point { x: 1, y: 2 }
        let p2 = Point { x: 3, y: 4 }
        let p3 = Point { x: 5, y: 6 }

        assert(s.add(p1))
        assert(s.add(p2))
        assert(s.add(p3))

        assert(s.len() == 3)
        assert(s.contains(p1))
        assert(s.contains(p2))
        assert(s.contains(p3))

        let p_missing = Point { x: 99, y: 99 }
        assert(!s.contains(p_missing))
    }

    test "set<Point> equality-based contains" {
        let s = Set.new<Point>()
        let p_add = Point { x: 10, y: 20 }
        _ = s.add(p_add)

        // Create a different instance with the same x,y values
        let p_check = Point { x: 10, y: 20 }
        assert(s.contains(p_check))

        // Adding the equal-but-different instance should return false (already exists)
        assert(!s.add(p_check))
        assert(s.len() == 1)

        // A point with different values should not be contained
        let p_other = Point { x: 10, y: 21 }
        assert(!s.contains(p_other))
    }

    test "set<i64> union" {
        let a = Set.new<i64>()
        _ = a.add(1)
        _ = a.add(2)
        _ = a.add(3)

        let b = Set.new<i64>()
        _ = b.add(3)
        _ = b.add(4)
        _ = b.add(5)

        let u = a.union(b)
        assert(u.len() == 5)
        assert(u.contains(1))
        assert(u.contains(2))
        assert(u.contains(3))
        assert(u.contains(4))
        assert(u.contains(5))
    }

    test "set<string> intersection" {
        let a = Set.new<string>()
        _ = a.add("alpha")
        _ = a.add("beta")
        _ = a.add("gamma")

        let b = Set.new<string>()
        _ = b.add("beta")
        _ = b.add("gamma")
        _ = b.add("delta")

        let i = a.intersection(b)
        assert(i.len() == 2)
        assert(!i.contains("alpha"))
        assert(i.contains("beta"))
        assert(i.contains("gamma"))
        assert(!i.contains("delta"))
    }

    // ---- Point set operations ----

    test "set<Point> union and difference" {
        let p1 = Point { x: 1, y: 1 }
        let p2 = Point { x: 2, y: 2 }
        let p3 = Point { x: 3, y: 3 }
        let p4 = Point { x: 4, y: 4 }

        let a = Set.new<Point>()
        _ = a.add(p1)
        _ = a.add(p2)
        _ = a.add(p3)

        let b = Set.new<Point>()
        _ = b.add(p2)
        _ = b.add(p3)
        _ = b.add(p4)

        let u = a.union(b)
        assert(u.len() == 4)
        let check_p1 = Point { x: 1, y: 1 }
        let check_p4 = Point { x: 4, y: 4 }
        assert(u.contains(check_p1))
        assert(u.contains(check_p4))

        let d = a.difference(b)
        assert(d.len() == 1)
        let check_p1b = Point { x: 1, y: 1 }
        let check_p2 = Point { x: 2, y: 2 }
        assert(d.contains(check_p1b))
        assert(!d.contains(check_p2))
    }

    // ---- Additional coverage ----

    test "set<string> clear" {
        let s = Set.new<string>()
        _ = s.add("a")
        _ = s.add("b")
        _ = s.add("c")
        assert(s.len() == 3)

        s.clear()
        assert(s.len() == 0)
        assert(s.is_empty())
        assert(!s.contains("a"))
    }

    test "set<string> symmetric_difference" {
        let a = Set.new<string>()
        _ = a.add("alpha")
        _ = a.add("beta")
        _ = a.add("gamma")

        let b = Set.new<string>()
        _ = b.add("beta")
        _ = b.add("gamma")
        _ = b.add("delta")

        let sd = a.symmetric_difference(b)
        assert(sd.len() == 2)
        assert(sd.contains("alpha"))
        assert(!sd.contains("beta"))
        assert(!sd.contains("gamma"))
        assert(sd.contains("delta"))
    }

    test "set<string> is_subset and is_superset" {
        let a = Set.new<string>()
        _ = a.add("x")
        _ = a.add("y")

        let b = Set.new<string>()
        _ = b.add("x")
        _ = b.add("y")
        _ = b.add("z")

        assert(a.is_subset(b))
        assert(!a.is_superset(b))
        assert(!b.is_subset(a))
        assert(b.is_superset(a))
    }

    test "set<string> is_disjoint" {
        let a = Set.new<string>()
        _ = a.add("cat")
        _ = a.add("dog")

        let b = Set.new<string>()
        _ = b.add("fish")
        _ = b.add("bird")

        assert(a.is_disjoint(b))

        _ = b.add("cat")
        assert(!a.is_disjoint(b))
    }

    // NOTE: Set.iter() segfaults (vol-i5za), iter tests omitted until fixed.

    test "set<Point> remove missing" {
        let s = Set.new<Point>()
        let p1 = Point { x: 1, y: 2 }
        _ = s.add(p1)

        let p_missing = Point { x: 99, y: 99 }
        assert(!s.remove(p_missing))
        assert(s.len() == 1)
    }
}
