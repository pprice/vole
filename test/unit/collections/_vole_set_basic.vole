// Tests for pure Vole Set core (std:collections/set)

let { Array } = import "std:array"

sentinel Empty
sentinel Deleted


class SetEntry<T> {
    value: T,
}

class VoleSet<T: Hashable + Equatable> {
    buckets: [SetEntry<T> | Empty | Deleted],
    size: i64,
    tomb_count: i64,

    statics {
        func new() -> VoleSet<T> {
            return VoleSet.with_capacity<T>(8)
        }

        func with_capacity(capacity: i64) -> VoleSet<T> {
            let cap = VoleSet.next_power_of_2(capacity)
            let buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
            return VoleSet {
                buckets: buckets,
                size: 0,
                tomb_count: 0,
            }
        }

        func next_power_of_2(n: i64) -> i64 {
            if n <= 8 {
                return 8
            }

            let mut power = 8
            while power < n {
                power = power * 2
            }
            return power
        }
    }

    func add(value: T) -> bool {
        if self.needs_rehash() {
            self.rehash()
        }

        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.add_on_entry(existing, value)
            Empty => self.add_on_empty(idx, value)
            Deleted => self.add_on_deleted(idx, value)
        }
    }

    func contains(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => existing.equals(value)
            Empty => false
            Deleted => false
        }
    }

    func remove(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.remove_entry(idx, existing, value)
            Empty => false
            Deleted => false
        }
    }

    func clear() {
        let cap = self.buckets.length()
        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
        self.size = 0
        self.tomb_count = 0
    }

    func len() -> i64 {
        return self.size
    }

    func is_empty() -> bool {
        // Work around generic self-field comparison issue by using a local first.
        let s = self.size
        return s == 0
    }

    func find_slot(value: T) -> i64 {
        let cap = self.buckets.length()
        let mut idx = value.hash() & (cap - 1)
        let mut first_deleted = -1
        let mut probes = 0

        while probes < cap {
            let bucket = self.buckets[idx]

            let mut same_value = false
            let mut saw_deleted = false
            let mut saw_empty = false

            match bucket {
                SetEntry { value: existing } => same_value = existing.equals(value)
                Deleted => saw_deleted = true
                Empty => saw_empty = true
            }

            if same_value {
                return idx
            } else if saw_deleted {
                if first_deleted == -1 {
                    first_deleted = idx
                }
            } else if saw_empty {
                if first_deleted != -1 {
                    return first_deleted
                }
                return idx
            }

            idx = (idx + 1) & (cap - 1)
            probes = probes + 1
        }

        if first_deleted != -1 {
            return first_deleted
        }

        return idx
    }

    func needs_rehash() -> bool {
        let cap = self.buckets.length()
        let used = self.size + self.tomb_count
        return (used * 100) / cap > 70
    }

    func rehash() {
        let old_buckets = self.buckets
        let old_cap = old_buckets.length()
        let new_cap = old_cap * 2

        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(new_cap, Empty)
        self.size = 0
        self.tomb_count = 0

        for bucket in old_buckets {
            match bucket {
                SetEntry { value } => self.insert_no_rehash(value)
                Empty => self.rehash_noop()
                Deleted => self.rehash_noop()
            }
        }
    }

    func rehash_noop() {
        let _x = 0
    }

    func insert_no_rehash(value: T) {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        match bucket {
            SetEntry { value: existing } => self.insert_on_entry(idx, existing, value)
            Empty => self.insert_on_empty(idx, value)
            Deleted => self.insert_on_deleted(idx, value)
        }
    }

    func insert_on_empty(idx: i64, value: T) {
        self.write_entry(idx, value)
        self.size = self.size + 1
    }

    func insert_on_deleted(idx: i64, value: T) {
        self.write_entry(idx, value)
        self.size = self.size + 1
        self.tomb_count = self.tomb_count - 1
    }

    func add_on_entry(existing: T, value: T) -> bool {
        if existing.equals(value) {
            return false
        }
        return false
    }

    func insert_on_entry(idx: i64, existing: T, value: T) {
        if !existing.equals(value) {
            self.write_entry(idx, value)
        }
    }

    func write_entry(idx: i64, value: T) {
        self.buckets[idx] = SetEntry { value: value }
    }

    func add_on_empty(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        return true
    }

    func add_on_deleted(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        self.tomb_count = self.tomb_count - 1
        return true
    }

    func remove_entry(idx: i64, existing: T, value: T) -> bool {
        if !existing.equals(value) {
            return false
        }

        self.buckets[idx] = Deleted
        self.size = self.size - 1
        self.tomb_count = self.tomb_count + 1
        return true
    }

    func iter() -> Iterator<T> {
        return SetIterator {
            buckets: self.buckets,
            index: 0,
        }
    }
}

class SetIterator<T> implements Iterator<T> {
    buckets: [SetEntry<T> | Empty | Deleted],
    index: i64,
}

implement Iterator<T> for SetIterator<T> {
    func next() -> T | Done {
        while self.index < self.buckets.length() {
            let bucket = self.buckets[self.index]
            self.index = self.index + 1
            let mut found = false
            match bucket {
                SetEntry { value } => found = true
                Empty => found = false
                Deleted => found = false
            }
            if found {
                return match bucket {
                    SetEntry { value } => value
                    Empty => Done {}
                    Deleted => Done {}
                }
            }
        }
        return Done {}
    }
}



tests {
    test "vole_set::new creates empty set" {
        let s = VoleSet.new<i64>()
        assert(s.len() == 0)
        assert(s.is_empty())
    }

    test "vole_set::add and contains i64" {
        let s = VoleSet.new<i64>()
        assert(s.add(42))
        assert(s.contains(42))
        assert(!s.contains(7))
        assert(s.len() == 1)
    }

    test "vole_set::add duplicate returns false" {
        let s = VoleSet.new<i64>()
        assert(s.add(5))
        assert(!s.add(5))
        assert(s.len() == 1)
    }

    test "vole_set::remove existing returns true" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)

        assert(s.remove(2))
        assert(!s.contains(2))
        assert(s.contains(1))
        assert(s.contains(3))
        assert(s.len() == 2)
    }

    test "vole_set::remove missing returns false" {
        let s = VoleSet.new<i64>()
        _ = s.add(9)
        assert(!s.remove(404))
        assert(s.len() == 1)
    }

    test "vole_set::clear resets set" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)

        s.clear()
        assert(s.len() == 0)
        assert(s.is_empty())
        assert(!s.contains(1))
    }

    test "vole_set::with_capacity" {
        let s = VoleSet.with_capacity<i64>(100)
        assert(s.len() == 0)
        assert(s.is_empty())

        _ = s.add(7)
        assert(s.contains(7))
    }

    test "vole_set::rehash preserves entries" {
        let s = VoleSet.new<i64>()

        let mut i = 0
        while i < 40 {
            _ = s.add(i)
            i = i + 1
        }

        assert(s.len() == 40)

        let mut j = 0
        while j < 40 {
            assert(s.contains(j))
            j = j + 1
        }
    }

    test "vole_set::string values" {
        let s = VoleSet.new<string>()
        assert(s.add("alpha"))
        assert(s.add("beta"))
        assert(!s.add("alpha"))

        assert(s.contains("alpha"))
        assert(s.contains("beta"))
        assert(!s.contains("gamma"))
        assert(s.len() == 2)
    }

    test "vole_set::reuses deleted slots" {
        let s = VoleSet.new<i64>()
        _ = s.add(10)
        _ = s.add(20)
        _ = s.add(30)
        assert(s.remove(20))

        assert(s.add(40))
        assert(!s.contains(20))
        assert(s.contains(10))
        assert(s.contains(30))
        assert(s.contains(40))
        assert(s.len() == 3)
    }

    test "vole_set::iter count" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)
        assert(s.iter().count() == 3)
    }

    test "vole_set::iter collect" {
        let s = VoleSet.new<i64>()
        _ = s.add(10)
        _ = s.add(20)
        _ = s.add(30)
        assert(s.iter().collect().length() == 3)
    }

    test "vole_set::for-in loop" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)
        let mut sum = 0
        for v in s.iter() {
            sum = sum + v
        }
        assert(sum == 6)
    }

    test "vole_set::iter on empty set" {
        let s = VoleSet.new<i64>()
        assert(s.iter().count() == 0)

        let mut ran = false
        for _v in s.iter() {
            ran = true
        }
        assert(!ran)
    }

    test "vole_set::iter after mutations" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)
        _ = s.remove(2)

        assert(s.iter().count() == 2)
        let mut sum = 0
        for v in s.iter() {
            sum = sum + v
        }
        assert(sum == 4)
    }

    test "vole_set::iter chained operations" {
        let s = VoleSet.new<i64>()
        _ = s.add(1)
        _ = s.add(2)
        _ = s.add(3)
        _ = s.add(4)
        _ = s.add(5)

        let evens = s.iter().filter((x) => x % 2 == 0).count()
        assert(evens == 2)

        let doubled = s.iter().map((x) => x * 2).collect()
        assert(doubled.length() == 5)
    }

    // TODO(vol-fmtt): Set operations (union, intersection, difference, etc.)
}
