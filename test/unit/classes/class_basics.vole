// Class basics tests

class Point {
    x: i32,
    y: i32,

    func sum() -> i32 {
        return self.x + self.y
    }

    // Expression-bodied method using self
    func product() -> i32 => self.x * self.y

    // Expression-bodied with inferred return type
    func doubled() => Point { x: self.x * 2, y: self.y * 2 }
}

tests "classes" {
    test "basic instantiation" {
        let p = Point { x: 10, y: 20 }
        assert(p.x == 10)
        assert(p.y == 20)
    }

    test "field access" {
        let p = Point { x: 5, y: 7 }
        assert(p.x + p.y == 12)
    }

    test "method call" {
        let p = Point { x: 10, y: 20 }
        assert(p.sum() == 30)
    }

    test "expression-bodied method with self" {
        let p = Point { x: 3, y: 4 }
        assert(p.product() == 12)
    }

    test "expression-bodied method returning class" {
        let p = Point { x: 5, y: 7 }
        let d = p.doubled()
        assert(d.x == 10)
        assert(d.y == 14)
    }

    test "class fields are mutable" {
        let p = Point { x: 1, y: 2 }
        p.x = 10
        assert(p.x == 10)
        assert(p.y == 2)
    }

    test "class multiple field mutations" {
        let p = Point { x: 1, y: 2 }
        p.x = 100
        p.y = 200
        assert(p.x == 100)
        assert(p.y == 200)
    }

    test "class field mutation preserves methods" {
        let p = Point { x: 3, y: 4 }
        p.x = 10
        assert(p.sum() == 14)
    }
}
