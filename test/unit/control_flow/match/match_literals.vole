// Test match with literal patterns

tests "integer literal patterns" {
    test "match first arm" {
        let x = 1
        let result = match x {
            1 => 100
            2 => 200
            _ => 999
        }
        assert(result == 100)
    }

    test "match second arm" {
        let x = 2
        let result = match x {
            1 => 100
            2 => 200
            _ => 999
        }
        assert(result == 200)
    }

    test "match wildcard fallback" {
        let x = 99
        let result = match x {
            1 => 100
            2 => 200
            _ => 999
        }
        assert(result == 999)
    }

    test "match negative integers" {
        let x = -5
        let result = match x {
            -10 => 1
            -5 => 2
            0 => 3
            _ => 4
        }
        assert(result == 2)
    }

    test "match on expression" {
        let a = 2
        let b = 3
        let result = match a + b {
            5 => 100
            _ => 0
        }
        assert(result == 100)
    }
}

tests "identifier binding patterns" {
    test "bind value with identifier" {
        let x = 42
        let result = match x {
            n => n * 2
        }
        assert(result == 84)
    }

    test "identifier after literals" {
        let x = 5
        let result = match x {
            1 => 100
            2 => 200
            n => n * 10
        }
        assert(result == 50)
    }

    test "use binding in expression" {
        let x = 7
        let result = match x {
            0 => 0
            n => n + n
        }
        assert(result == 14)
    }
}

tests "nested match" {
    test "nested match expression" {
        let x = 1
        let y = 2
        let result = match x {
            1 => match y {
                2 => 12
                _ => 10
            }
            _ => 0
        }
        assert(result == 12)
    }
}

tests "i32 match patterns" {
    test "match i32 with suffixed literals" {
        let x: i32 = 10_i32
        let result = match x {
            10_i32 => 100_i32
            20_i32 => 200_i32
            _ => 0_i32
        }
        assert(result == 100_i32)
    }

    test "match i32 with unsuffixed literals" {
        let x: i32 = 42_i32
        let result = match x {
            1 => 10_i32
            42 => 420_i32
            _ => 0_i32
        }
        assert(result == 420_i32)
    }

    test "match i32 wildcard fallback" {
        let x: i32 = 99_i32
        let result = match x {
            1_i32 => 10_i32
            2_i32 => 20_i32
            _ => 0_i32
        }
        assert(result == 0_i32)
    }

    test "match i32 from function return" {
        func get_i32() -> i32 { return 7_i32 }
        let result = match get_i32() {
            7_i32 => 70_i32
            _ => 0_i32
        }
        assert(result == 70_i32)
    }
}

tests "i16 match patterns" {
    test "match i16 with suffixed literals" {
        let x: i16 = 5_i16
        let result = match x {
            5_i16 => 50_i16
            _ => 0_i16
        }
        assert(result == 50_i16)
    }

    test "match i16 with unsuffixed literals" {
        let x: i16 = 3_i16
        let result = match x {
            1 => 10_i16
            3 => 30_i16
            _ => 0_i16
        }
        assert(result == 30_i16)
    }
}

tests "extreme value match patterns" {
    test "match with i64::MAX" {
        // Regression test for overflow bug in switch analysis
        // Computing range size for extreme values used to panic
        let x = 9223372036854775807_i64  // i64::MAX
        let result = match x {
            -1000_i64 => 2_i64
            0_i64 => 3_i64
            1000_i64 => 4_i64
            9223372036854775807_i64 => 5_i64  // i64::MAX
            _ => 0_i64
        }
        assert(result == 5_i64)
    }

    test "match with large negative values" {
        let min_i64 = 0_i64 - 9223372036854775807_i64 - 1_i64  // i64::MIN
        let x = min_i64
        let result = match x {
            0_i64 => 2_i64
            9223372036854775807_i64 => 3_i64
            _ => 1_i64
        }
        assert(result == 1_i64)
    }

    test "match with large value spread" {
        // Range too large for switch table, should fall back to if-chain
        let x = 100_i64
        let result = match x {
            -9000000000000000000_i64 => 1_i64
            100_i64 => 2_i64
            200_i64 => 3_i64
            9000000000000000000_i64 => 4_i64
            _ => 0_i64
        }
        assert(result == 2_i64)
    }
}
