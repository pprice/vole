// Lambda tests

// Module-level lambdas with type annotations:
let simpleLambda = (x: i64) => x * 2
let noParams = () => 5
let multiParams = (a: i64, b: i64) => a + b

tests "lambdas" {
    test "simple lambda (module level)" {
        assert(simpleLambda(5) == 10)
    }

    test "no params (module level)" {
        assert(noParams() == 5)
    }

    test "multiple params (module level)" {
        assert(multiParams(2, 3) == 5)
    }

    test "lambda inside test" {
        let double = (n: i64) => n * 2
        assert(double(5) == 10)
    }

    test "multi-param lambda inside test" {
        let add = (a: i64, b: i64) => a + b
        assert(add(10, 20) == 30)
    }

    test "block body" {
        let complex = (x: i64) -> i64 => {
            let y = x * 2
            return y + 1
        }
        assert(complex(5) == 11)
    }

    test "higher order" {
        let apply = (f: (i64) -> i64, x: i64) => f(x)
        let double = (n: i64) => n * 2
        assert(apply(double, 5) == 10)
    }

    test "returned lambda" {
        let makeAdder = (n: i64) -> (i64) -> i64 => (x: i64) => x + n
        let add5 = makeAdder(5)
        assert(add5(10) == 15)
    }

    test "closure capture" {
        let x = 10
        let addX = (n: i64) => n + x
        assert(addX(5) == 15)
    }

    test "mutable closure" {
        var count = 0
        let inc = () -> i64 => {
            count = count + 1
            return count
        }
        assert(inc() == 1)
        assert(inc() == 2)
        assert(inc() == 3)
    }
}

tests "type annotations" {
    test "parameter types" {
        let add = (x: i32, y: i32) => x + y
        let a: i32 = 10
        let b: i32 = 20
        assert(add(a, b) == 30)
    }

    test "return type" {
        let typed = (x: i32, y: i32) -> i32 => x + y
        let a: i32 = 5
        let b: i32 = 3
        assert(typed(a, b) == 8)
    }

    test "subtraction" {
        let sub = (a: i32, b: i32) -> i32 => a - b
        let x: i32 = 10
        let y: i32 = 5
        assert(sub(x, y) == 5)
    }
}

func applyFn(fn: (i32) -> i32, x: i32) -> i32 {
    return fn(x)
}

func sum_closure_array(fns: [() -> i64]) -> i64 {
    var total = 0
    var i = 0
    while i < fns.length() {
        total = total + fns[i]()
        i = i + 1
    }
    return total
}

tests "lambda inference" {
    test "bidirectional inference" {
        // Lambda infers x is i32 from function parameter type
        // Use x + x to avoid type widening from literal
        let result = applyFn((x) => x + x, 5)
        assert(result == 10)
    }

    test "closure array literal passed directly to typed parameter" {
        let total = sum_closure_array([
            () -> i64 => { return 1 },
            () -> i64 => { return 2 },
            () -> i64 => { return 3 },
        ])
        assert(total == 6)
    }
}

tests "void and nil returns" {
    test "implicit void lambda block" {
        let doNothing = (x: i64) => {
            let y = x + 1
        }
        doNothing(1)
        assert(true)
    }

    test "explicit void lambda block" {
        let doNothing = (x: i64) -> void => {
            let y = x + 1
        }
        doNothing(1)
        assert(true)
    }

    test "return nil lambda block" {
        let returnNil = () -> nil => {
            return nil
        }
        assert(returnNil() == nil)
    }

    test "inferred nil return lambda block" {
        let returnNil = () => {
            return nil
        }
        assert(returnNil() == nil)
    }

    // Single expression variants
    test "nil expression lambda" {
        let returnNil = () -> nil => nil
        assert(returnNil() == nil)
    }

    test "inferred nil expression lambda" {
        let returnNil = () => nil
        assert(returnNil() == nil)
    }

    // Block body with return - inferred return type
    test "inferred return type from block" {
        let double = (x: i64) => {
            return x * 2
        }
        assert(double(21) == 42)
    }

    test "explicit return type block" {
        let double = (x: i64) -> i64 => {
            return x * 2
        }
        assert(double(21) == 42)
    }

    test "inferred i32 return from block" {
        let add = (a: i32, b: i32) => {
            return a + b
        }
        let x: i32 = 10
        let y: i32 = 20
        assert(add(x, y) == 30)
    }
}

// Regression: closure capture inside when-expression branches (vol-0d5w).
// Constant folding was replacing when-expressions with the taken arm's body
// but preserving the when-expression's NodeId, causing codegen to fail to
// find the lambda's capture analysis.
func closure_in_when() -> () -> i64 {
    let items = "a,b,c".split(",").collect()
    return when {
        false => () -> i64 => 0
        _ => () -> i64 => items.iter().count()
    }
}

func closure_in_when_true_arm() -> () -> i64 {
    let x = 42
    return when {
        true => () -> i64 => x
        _ => () -> i64 => 0
    }
}

func closure_in_when_runtime_cond(flag: bool) -> () -> i64 {
    let captured = 99
    return when {
        flag => () -> i64 => captured
        _ => () -> i64 => 0
    }
}

tests "closure capture in when" {
    test "captures local in when wildcard branch" {
        let f = closure_in_when()
        assert(f() == 3)
    }

    test "captures local in when true branch" {
        let f = closure_in_when_true_arm()
        assert(f() == 42)
    }

    test "captures local in when runtime condition" {
        let f = closure_in_when_runtime_cond(true)
        assert(f() == 99)
        let g = closure_in_when_runtime_cond(false)
        assert(g() == 0)
    }
}

tests "fallible lambda returns" {
    test "lambda returning optional" {
        let maybe = (x: i64) -> i64? => {
            if x > 0 {
                return x * 2
            }
            return nil
        }
        let result = maybe(5)
        assert(result == 10)
    }

    test "lambda returning nil" {
        let maybe = (x: i64) -> i64? => {
            if x > 0 {
                return x * 2
            }
            return nil
        }
        let result = maybe(-1)
        assert(result == nil)
    }
}
