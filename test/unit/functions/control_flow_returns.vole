// Test: control flow analysis for missing return detection
// Functions where all branches return should NOT produce E2083

// If/else where both branches return
func if_else_returns(x: i64) -> i64 {
    if x > 0 {
        return 1
    } else {
        return -1
    }
}

// Nested: if/else inside if/else
func nested_if_returns(x: i64) -> string {
    if x > 0 {
        if x > 100 {
            return "big"
        } else {
            return "small"
        }
    } else {
        return "negative"
    }
}

// Raise terminates a path (in fallible function)
error DivError {}

func safe_div(a: i64, b: i64) -> fallible(i64, DivError) {
    if b == 0 {
        raise DivError {}
    } else {
        return a / b
    }
}

// If/else where one branch returns and other raises
error BadInput {}

func validate_positive(x: i64) -> fallible(i64, BadInput) {
    if x <= 0 {
        raise BadInput {}
    } else {
        return x
    }
}

// Deeply nested if/else with returns
func classify(x: i64) -> string {
    if x < 0 {
        return "negative"
    } else {
        if x == 0 {
            return "zero"
        } else {
            if x < 10 {
                return "small"
            } else {
                return "large"
            }
        }
    }
}

// Bare unreachable in else branch (v-5c4b)
func unreachable_in_else(x: bool) -> i64 {
    if x {
        return 42
    } else {
        unreachable
    }
}

// Bare unreachable in then branch (v-5c4b)
func unreachable_in_then(x: bool) -> i64 {
    if x {
        unreachable
    } else {
        return 99
    }
}

// Bare unreachable in both branches with implicit return (v-5c4b)
func unreachable_with_early_return(x: bool) -> i64 {
    if x {
        return 7
    } else {
        return 14
    }
    unreachable
}

tests {
    test "if/else both return" {
        assert(if_else_returns(5) == 1)
        assert(if_else_returns(-3) == -1)
    }

    test "nested if/else returns" {
        assert(nested_if_returns(200) == "big")
        assert(nested_if_returns(50) == "small")
        assert(nested_if_returns(-5) == "negative")
    }

    test "raise terminates path" {
        let result = safe_div(10, 2)
        match result {
            success v => assert(v == 5)
            error _ => assert(false)
            _ => assert(false)
        }
    }

    test "one branch returns, other raises" {
        let result = validate_positive(42)
        match result {
            success v => assert(v == 42)
            error _ => assert(false)
            _ => assert(false)
        }
    }

    test "bare unreachable in else branch" {
        assert(unreachable_in_else(true) == 42)
    }

    test "bare unreachable in then branch" {
        assert(unreachable_in_then(false) == 99)
    }

    test "unreachable after exhaustive if/else" {
        assert(unreachable_with_early_return(true) == 7)
        assert(unreachable_with_early_return(false) == 14)
    }

    test "deeply nested returns" {
        assert(classify(-5) == "negative")
        assert(classify(0) == "zero")
        assert(classify(5) == "small")
        assert(classify(100) == "large")
    }
}
