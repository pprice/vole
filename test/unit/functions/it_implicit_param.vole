// Tests for implicit `it` parameter in lambda-expecting positions.
// When a call site expects a function type `(T) -> U` and the argument
// expression contains the identifier `it`, sema synthesizes `it => expr`.

// Single-arg function accepting a transformation
func apply_fn(f: (i64) -> i64) -> i64 {
    return f(5)
}

// Single-arg function accepting a predicate
func apply_pred(f: (i64) -> bool) -> i64 {
    if f(7) {
        return 1
    }
    return 0
}

// Two-arg: value and transformer
func apply_with_val(f: (i64) -> i64, x: i64) -> i64 {
    return f(x)
}

class Person {
    name: string,
    age: i64,
}

tests "implicit it parameter" {
    test "it in arithmetic expression" {
        let result = apply_fn(it * 2)
        assert(result == 10)
    }

    test "it in comparison predicate" {
        let result = apply_pred(it > 0)
        assert(result == 1)
    }

    test "it in addition" {
        let result = apply_fn(it + 10)
        assert(result == 15)
    }

    test "it with multiple uses in same expression" {
        let result = apply_fn(it * it)
        assert(result == 25)
    }

    test "it in map" {
        let nums = [1_i64, 2_i64, 3_i64]
        let doubled = nums.map(it * 2).collect()
        assert(doubled[0] == 2)
        assert(doubled[1] == 4)
        assert(doubled[2] == 6)
    }

    test "it in filter" {
        let nums = [1_i64, 2_i64, 3_i64, 4_i64, 5_i64]
        let evens = nums.filter(it % 2 == 0).collect()
        assert(evens[0] == 2)
        assert(evens[1] == 4)
    }

    test "it in for_each" {
        let nums = [1_i64, 2_i64, 3_i64]
        // for_each with it: apply an implicit lambda to each element (no mutable captures)
        // Uses implicit it => it * 1 which is a no-op transform
        nums.for_each(it * 1)
        assert(true) // verify it compiles and runs without error
    }

    test "explicit lambda still works alongside it" {
        let result = apply_fn(x => x * 3)
        assert(result == 15)
    }

    test "it field access: map it.age on class instances" {
        // Uses .iter() to avoid unrelated direct-array-map bug with struct values
        let people = [Person { name: "Alice", age: 30_i64 }, Person { name: "Bob", age: 25_i64 }, Person { name: "Carol", age: 41_i64 }]
        let ages = people.iter().map(it.age).collect()
        assert(ages.length() == 3)
        assert(ages[0] == 30)
        assert(ages[1] == 25)
        assert(ages[2] == 41)
    }

    test "chained calls: filter then map each with its own it context" {
        let nums = [1_i64, -2_i64, 3_i64, -4_i64, 5_i64]
        let result = nums.filter(it > 0).map(it * 2).collect()
        assert(result.length() == 3)
        assert(result[0] == 2)
        assert(result[1] == 6)
        assert(result[2] == 10)
    }

    test "it as normal variable (soft keyword, not reserved)" {
        let it = 42_i64
        assert(it == 42)
    }

    test "it as variable does not synthesize implicit lambda" {
        // When `it` is in scope as a variable, it is used as a regular identifier
        // and does not trigger implicit lambda synthesis
        let it = 10_i64
        let doubled = it * 2
        assert(doubled == 20)
    }
}
