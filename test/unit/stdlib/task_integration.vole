// Integration smoke test: exercises all Task APIs together.
// Verifies that Task.run, join, cancel, all, stream, state, select,
// parallel, and Channel interoperate correctly.

let { Task, Channel, SelectResult, parallel } = import "std:task"

tests {
    // =========================================================================
    // Cross-API composition
    // =========================================================================

    test "run + all: task spawns sub-tasks via all" {
        let t = Task.run(() -> i64 => {
            let fns: [() -> i64] = [
                () -> i64 => { return 10 },
                () -> i64 => { return 20 },
                () -> i64 => { return 30 },
            ]
            let results = Task.all(fns)
            return results[0] + results[1] + results[2]
        })
        assert(t.join() == 60)
    }

    test "stream + collect: producer task emits into iterator" {
        let s = Task.stream((emit: (i64) -> void) => {
            emit(1)
            emit(2)
            emit(3)
            emit(4)
            emit(5)
        })
        let arr = s.collect()
        assert(arr.length() == 5)
        let mut sum = 0
        for v in arr.iter() {
            sum = sum + v
        }
        assert(sum == 15)
    }

    test "state actor fed by multiple tasks" {
        let counter = Task.state(0, (count: i64, msg: i64) -> i64 => {
            return count + msg
        })
        let t1 = Task.run(() -> i64 => {
            counter.send(10)
            return 0
        })
        let t2 = Task.run(() -> i64 => {
            counter.send(20)
            return 0
        })
        let t3 = Task.run(() -> i64 => {
            counter.send(30)
            return 0
        })
        _ = t1.join()
        _ = t2.join()
        _ = t3.join()
        let result = counter.close_and_join()
        assert(result == 60)
    }

    test "parallel transform and sum" {
        let items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let results = parallel(items, 4, (x: i64) -> i64 => { return x * x })
        assert(results.length() == 10)
        let mut sum = 0
        for v in results.iter() {
            sum = sum + v
        }
        // 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81 + 100 = 385
        assert(sum == 385)
    }

    test "task produces channel value consumed by main" {
        let ch = Channel.buffered(2)
        let t = Task.run(() -> i64 => {
            ch.send(42)
            return 0
        })
        // join ensures the task runs and sends before we receive
        _ = t.join()
        assert(ch.receive() == 42)
    }

    test "multiple cancel is safe" {
        let t = Task.run(() -> i64 => { return 99 })
        t.cancel()
        t.cancel()
        t.cancel()
        assert(t.is_done())
    }

    test "all with single item returns single result" {
        let fns: [() -> i64] = [() -> i64 => { return 42 }]
        let r = Task.all(fns)
        assert(r.length() == 1)
        assert(r[0] == 42)
    }

    test "task join after task completes" {
        let t = Task.run(() -> i64 => { return 7 })
        let v1 = t.join()
        assert(v1 == 7)
        assert(t.is_done())
    }

    test "select3 with all channels ready picks lowest" {
        let ch1 = Channel.buffered(2)
        let ch2 = Channel.buffered(2)
        let ch3 = Channel.buffered(2)
        ch1.send(1)
        ch2.send(2)
        ch3.send(3)
        let r = Task.select3(ch1, ch2, ch3, 0)
        assert(!r.timed_out)
        assert(r.channel_index == 0)
        assert(r.value == 1)
        assert(ch2.receive() == 2)
        assert(ch3.receive() == 3)
    }

    test "channel producer + select consumer" {
        let ch1 = Channel.buffered(4)
        let ch2 = Channel.buffered(4)

        // Pre-buffer data in both channels (no close, so select works cleanly)
        let p1 = Task.run(() -> i64 => {
            ch1.send(100)
            ch1.send(200)
            return 0
        })
        let p2 = Task.run(() -> i64 => {
            ch2.send(300)
            return 0
        })

        // Wait for producers to finish
        _ = p1.join()
        _ = p2.join()

        // Select picks ch1 first (lowest index, has data), then ch1 again,
        // then ch2 (only ch2 has data left).
        let r1 = Task.select2(ch1, ch2, 0)
        assert(!r1.timed_out)
        assert(r1.channel_index == 0)
        assert(r1.value == 100)

        let r2 = Task.select2(ch1, ch2, 0)
        assert(!r2.timed_out)
        assert(r2.channel_index == 0)
        assert(r2.value == 200)

        let r3 = Task.select2(ch1, ch2, 0)
        assert(!r3.timed_out)
        assert(r3.channel_index == 1)
        assert(r3.value == 300)
    }

    test "nested all: task calling all which spawns sub-tasks" {
        let t = Task.run(() -> i64 => {
            let fns: [() -> i64] = [
                () -> i64 => { return 100 },
                () -> i64 => { return 200 },
                () -> i64 => { return 300 },
                () -> i64 => { return 400 },
                () -> i64 => { return 500 },
            ]
            let results = Task.all(fns)
            let mut sum = 0
            let mut i = 0
            while i < results.length() {
                sum = sum + results[i]
                i = i + 1
            }
            return sum
        })
        assert(t.join() == 1500)
    }
}
