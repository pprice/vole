// Test for std:time module

let time = import "std:time"

// =============================================================================
// Duration tests
// =============================================================================

tests "Duration constructors" {
    test "Duration.nanos creates correct duration" {
        let d = time.Duration.nanos(1000)
        assert(d.as_nanos() == 1000)
    }

    test "Duration.micros creates correct duration" {
        let d = time.Duration.micros(5)
        assert(d.as_nanos() == 5000)
    }

    test "Duration.ms creates correct duration" {
        let d = time.Duration.ms(10)
        assert(d.as_nanos() == 10000000)
        assert(d.as_ms() == 10)
    }

    test "Duration.seconds creates correct duration" {
        let d = time.Duration.seconds(3)
        assert(d.as_nanos() == 3000000000)
        assert(d.as_seconds() == 3)
    }

    test "Duration.minutes creates correct duration" {
        let d = time.Duration.minutes(2)
        assert(d.as_seconds() == 120)
        assert(d.as_minutes() == 2)
    }

    test "Duration.hours creates correct duration" {
        let d = time.Duration.hours(1)
        assert(d.as_seconds() == 3600)
        assert(d.as_hours() == 1)
    }

    test "Duration.days creates correct duration" {
        let d = time.Duration.days(1)
        assert(d.as_hours() == 24)
    }

    test "Duration.weeks creates correct duration" {
        let d = time.Duration.weeks(1)
        assert(d.as_days() == 7)
    }

    test "Duration.zero creates zero duration" {
        let d = time.Duration.zero()
        assert(d.as_nanos() == 0)
    }
}

tests "Duration getters" {
    test "as_nanos returns nanoseconds" {
        let d = time.Duration.nanos(12345)
        assert(d.as_nanos() == 12345)
    }

    test "as_micros truncates correctly" {
        let d = time.Duration.nanos(5500)
        assert(d.as_micros() == 5)
    }

    test "as_ms truncates correctly" {
        let d = time.Duration.nanos(15500000)
        assert(d.as_ms() == 15)
    }

    test "as_seconds truncates correctly" {
        let d = time.Duration.ms(2500)
        assert(d.as_seconds() == 2)
    }

    test "as_minutes truncates correctly" {
        let d = time.Duration.seconds(150)
        assert(d.as_minutes() == 2)
    }

    test "as_hours truncates correctly" {
        let d = time.Duration.minutes(150)
        assert(d.as_hours() == 2)
    }

    test "as_days truncates correctly" {
        let d = time.Duration.hours(50)
        assert(d.as_days() == 2)
    }
}

tests "Duration arithmetic" {
    test "add combines durations" {
        let d1 = time.Duration.seconds(10)
        let d2 = time.Duration.seconds(5)
        let result = d1.add(d2)
        assert(result.as_seconds() == 15)
    }

    test "subtract removes duration" {
        let d1 = time.Duration.seconds(10)
        let d2 = time.Duration.seconds(3)
        let result = d1.subtract(d2)
        assert(result.as_seconds() == 7)
    }

    test "multiply scales duration" {
        let d = time.Duration.seconds(5)
        let result = d.multiply(3)
        assert(result.as_seconds() == 15)
    }

    test "divide shrinks duration" {
        let d = time.Duration.seconds(15)
        let result = d.divide(3)
        assert(result.as_seconds() == 5)
    }
}

tests "Duration utilities" {
    test "abs returns absolute value for negative" {
        let d = time.Duration.nanos(-1000)
        let result = d.abs()
        assert(result.as_nanos() == 1000)
    }

    test "abs returns same value for positive" {
        let d = time.Duration.nanos(1000)
        let result = d.abs()
        assert(result.as_nanos() == 1000)
    }

    test "is_negative returns true for negative duration" {
        let d = time.Duration.nanos(-1000)
        assert(d.is_negative() == true)
    }

    test "is_negative returns false for positive duration" {
        let d = time.Duration.nanos(1000)
        assert(d.is_negative() == false)
    }

    test "is_zero returns true for zero duration" {
        let d = time.Duration.zero()
        assert(d.is_zero() == true)
    }

    test "is_zero returns false for non-zero duration" {
        let d = time.Duration.nanos(1)
        assert(d.is_zero() == false)
    }

    test "is_positive returns true for positive duration" {
        let d = time.Duration.nanos(1000)
        assert(d.is_positive() == true)
    }

    test "negate reverses sign" {
        let d = time.Duration.seconds(5)
        let result = d.negate()
        assert(result.as_seconds() == -5)
    }
}

// =============================================================================
// Timestamp tests
// =============================================================================

tests "Timestamp constructors" {
    test "Timestamp.now returns reasonable value" {
        let ts = time.Timestamp.now()
        // Should be after 2020 (in seconds since epoch)
        assert(ts.unix() > 1577836800)
    }

    test "Timestamp.from_unix creates correct timestamp" {
        let ts = time.Timestamp.from_unix(1000)
        assert(ts.unix() == 1000)
    }

    test "Timestamp.from_unix_ms creates correct timestamp" {
        let ts = time.Timestamp.from_unix_ms(1500000)
        assert(ts.unix_ms() == 1500000)
        assert(ts.unix() == 1500)
    }

    test "Timestamp.epoch returns epoch" {
        let ts = time.Timestamp.epoch()
        assert(ts.unix() == 0)
    }

    test "Timestamp.parse parses valid ISO 8601" {
        let ts = time.Timestamp.parse("2024-01-15T12:30:45Z")
        // Check it parses (not nil) by comparing with expected unix time
        // 2024-01-15T12:30:45Z = 1705321845 seconds since epoch
        assert(ts != nil)
    }

    test "Timestamp.parse returns nil for invalid" {
        let ts = time.Timestamp.parse("not-a-date")
        assert(ts == nil)
    }

    test "Timestamp.from_parts creates valid timestamp" {
        let ts = time.Timestamp.from_parts(2024, 6, 15, 10, 30, 0)
        assert(ts != nil)
    }
}

tests "Timestamp getters" {
    test "unix returns seconds" {
        let ts = time.Timestamp.from_unix(12345)
        assert(ts.unix() == 12345)
    }

    test "unix_ms returns milliseconds" {
        let ts = time.Timestamp.from_unix_ms(12345678)
        assert(ts.unix_ms() == 12345678)
    }

    test "unix_nanos returns nanoseconds" {
        let ts = time.Timestamp.from_unix(1)
        assert(ts.unix_nanos() == 1000000000)
    }

    test "offset returns timezone offset" {
        let ts = time.Timestamp.from_unix(0)
        assert(ts.offset() == 0)
    }

    test "with_offset changes offset" {
        let ts = time.Timestamp.from_unix(0)
        let ts2 = ts.with_offset(60)
        assert(ts2.offset() == 60)
    }
}

tests "Timestamp date components" {
    test "year returns correct year" {
        // 2024-01-15T12:30:45Z = 1705321845 unix
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.year() == 2024)
    }

    test "month returns correct month" {
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.month() == 1)
    }

    test "day returns correct day" {
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.day() == 15)
    }
}

tests "Timestamp time components" {
    test "hour returns correct hour" {
        // 2024-01-15T12:30:45Z = 1705321845 unix
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.hour() == 12)
    }

    test "minute returns correct minute" {
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.minute() == 30)
    }

    test "second returns correct second" {
        let ts = time.Timestamp.from_unix(1705321845)
        assert(ts.second() == 45)
    }
}

tests "Timestamp arithmetic" {
    test "add increases timestamp" {
        let ts = time.Timestamp.from_unix(1000)
        let d = time.Duration.seconds(100)
        let result = ts.add(d)
        assert(result.unix() == 1100)
    }

    test "subtract decreases timestamp" {
        let ts = time.Timestamp.from_unix(1000)
        let d = time.Duration.seconds(100)
        let result = ts.subtract(d)
        assert(result.unix() == 900)
    }

    test "since returns duration between timestamps" {
        let ts1 = time.Timestamp.from_unix(1000)
        let ts2 = time.Timestamp.from_unix(800)
        let diff = ts1.since(ts2)
        assert(diff.as_seconds() == 200)
    }

    test "distance returns absolute duration" {
        let ts1 = time.Timestamp.from_unix(800)
        let ts2 = time.Timestamp.from_unix(1000)
        let diff = ts1.distance(ts2)
        assert(diff.as_seconds() == 200)
    }
}

tests "Timestamp calendar arithmetic" {
    test "add_days adds correct number of days" {
        let ts = time.Timestamp.from_unix(0)
        let result = ts.add_days(1)
        assert(result.unix() == 86400)
    }

    // Note: add_months and add_years tests using from_parts would need
    // type narrowing support. Testing with from_unix for now.
    test "add_months advances by months" {
        // January 1, 2024 00:00:00 UTC = 1704067200
        let ts = time.Timestamp.from_unix(1704067200)
        let result = ts.add_months(1)
        // After adding 1 month, should be February
        assert(result.month() == 2)
    }

    test "add_years advances by years" {
        // January 1, 2024 00:00:00 UTC = 1704067200
        let ts = time.Timestamp.from_unix(1704067200)
        let result = ts.add_years(1)
        // After adding 1 year, should be 2025
        assert(result.year() == 2025)
    }
}

tests "Timestamp formatting" {
    test "to_iso formats correctly" {
        // January 1, 2024 10:30:45 UTC
        // Calculate: 1704067200 (Jan 1) + 10*3600 + 30*60 + 45 = 1704105045
        let ts = time.Timestamp.from_unix(1704105045)
        let iso = ts.to_iso()
        // UTC uses "Z" suffix
        assert(iso == "2024-01-01T10:30:45Z")
    }
}

tests "Timestamp comparisons" {
    test "is_before returns true when earlier" {
        let ts1 = time.Timestamp.from_unix(100)
        let ts2 = time.Timestamp.from_unix(200)
        assert(ts1.is_before(ts2) == true)
    }

    test "is_before returns false when later" {
        let ts1 = time.Timestamp.from_unix(200)
        let ts2 = time.Timestamp.from_unix(100)
        assert(ts1.is_before(ts2) == false)
    }

    test "is_after returns true when later" {
        let ts1 = time.Timestamp.from_unix(200)
        let ts2 = time.Timestamp.from_unix(100)
        assert(ts1.is_after(ts2) == true)
    }

    test "equals returns true for same instant" {
        let ts1 = time.Timestamp.from_unix(1000)
        let ts2 = time.Timestamp.from_unix(1000)
        assert(ts1.equals(ts2) == true)
    }

    test "equals returns false for different instants" {
        let ts1 = time.Timestamp.from_unix(1000)
        let ts2 = time.Timestamp.from_unix(2000)
        assert(ts1.equals(ts2) == false)
    }
}

// =============================================================================
// Struct equality tests (structs support == natively)
// =============================================================================

tests "Duration struct equality" {
    test "equal durations compare equal" {
        assert(time.Duration.seconds(5) == time.Duration.seconds(5))
    }

    test "different durations compare not equal" {
        assert(time.Duration.seconds(5) != time.Duration.seconds(10))
    }

    test "zero equals nanos(0)" {
        assert(time.Duration.zero() == time.Duration.nanos(0))
    }

    test "millis equality" {
        assert(time.Duration.ms(100) == time.Duration.ms(100))
    }

    test "different units same value" {
        assert(time.Duration.seconds(1) == time.Duration.ms(1000))
    }
}

tests "Timestamp struct equality" {
    test "same epoch timestamps compare equal" {
        assert(time.Timestamp.epoch() == time.Timestamp.from_unix(0))
    }

    test "same unix timestamps compare equal" {
        assert(time.Timestamp.from_unix(1000) == time.Timestamp.from_unix(1000))
    }

    test "different timestamps compare not equal" {
        assert(time.Timestamp.from_unix(1000) != time.Timestamp.from_unix(2000))
    }

    test "same time different offset not equal" {
        let ts1 = time.Timestamp.from_unix(1000)
        let ts2 = ts1.with_offset(60)
        assert(ts1 != ts2)
    }
}

tests "Bounded implementations" {
    test "Duration bounded min and max values" {
        let min_d = time.Duration.min_value()
        let max_d = time.Duration.max_value()

        assert(min_d.as_nanos() == -9223372036854775807 - 1)
        assert(max_d.as_nanos() == 9223372036854775807)
        assert(min_d.as_nanos() < max_d.as_nanos())
    }

    test "Timestamp bounded min and max values" {
        let min_ts = time.Timestamp.min_value()
        let max_ts = time.Timestamp.max_value()

        assert(min_ts.unix_nanos() == -9223372036854775807 - 1)
        assert(max_ts.unix_nanos() == 9223372036854775807)
        assert(min_ts.offset() == 0)
        assert(max_ts.offset() == 0)
        assert(min_ts.unix_nanos() < max_ts.unix_nanos())
    }
}
