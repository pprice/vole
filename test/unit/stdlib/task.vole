let { Task, Channel, SelectResult } = import "std:task"

tests {
    test "run and join returns closure result" {
        let t = Task.run(() -> i64 => { return 42 })
        assert(t.join() == 42)
    }

    test "join returns captured value" {
        let x = 10
        let t = Task.run(() -> i64 => { return x + 5 })
        assert(t.join() == 15)
    }

    test "multiple tasks run and join" {
        let t1 = Task.run(() -> i64 => { return 1 })
        let t2 = Task.run(() -> i64 => { return 2 })
        let t3 = Task.run(() -> i64 => { return 3 })
        assert(t1.join() + t2.join() + t3.join() == 6)
    }

    test "is_done after join" {
        let t = Task.run(() -> i64 => { return 99 })
        let result = t.join()
        assert(t.is_done())
        assert(result == 99)
    }

    test "cancel before run prevents execution" {
        let t = Task.run(() -> i64 => { return 77 })
        t.cancel()
        assert(t.is_done())
    }

    test "all with single function" {
        let fns: [() -> i64] = [() -> i64 => { return 42 }]
        let results = Task.all(fns)
        assert(results.length() == 1)
        assert(results[0] == 42)
    }

    test "all with multiple functions" {
        let fns: [() -> i64] = [
            () -> i64 => { return 1 },
            () -> i64 => { return 2 },
            () -> i64 => { return 3 },
        ]
        let results = Task.all(fns)
        assert(results.length() == 3)
        assert(results[0] == 1)
        assert(results[1] == 2)
        assert(results[2] == 3)
    }

    test "all with empty array" {
        let fns: [() -> i64] = []
        let results = Task.all(fns)
        assert(results.length() == 0)
    }

    test "all preserves order" {
        let fns: [() -> i64] = [
            () -> i64 => { return 100 },
            () -> i64 => { return 200 },
            () -> i64 => { return 300 },
        ]
        let results = Task.all(fns)
        assert(results[0] == 100)
        assert(results[1] == 200)
        assert(results[2] == 300)
    }

    test "all with captured values" {
        let base = 10
        let fns: [() -> i64] = [
            () -> i64 => { return base + 1 },
            () -> i64 => { return base + 2 },
        ]
        let results = Task.all(fns)
        assert(results[0] == 11)
        assert(results[1] == 12)
    }

    test "stream produces values consumed by for loop" {
        let mut sum = 0
        let s = Task.stream((emit: (i64) -> void) => {
            emit(1)
            emit(2)
            emit(3)
        })
        for v in s {
            sum = sum + v
        }
        assert(sum == 6)
    }

    test "stream works with collect" {
        let s = Task.stream((emit: (i64) -> void) => {
            emit(10)
            emit(20)
            emit(30)
        })
        let result = s.collect()
        assert(result.length() == 3)
        assert(result[0] == 10)
        assert(result[1] == 20)
        assert(result[2] == 30)
    }

    test "stream with captured values" {
        let base = 100
        let s = Task.stream((emit: (i64) -> void) => {
            emit(base + 1)
            emit(base + 2)
        })
        let result = s.collect()
        assert(result[0] == 101)
        assert(result[1] == 102)
    }

    test "empty stream produces no values" {
        let s = Task.stream((emit: (i64) -> void) => {
            // produce nothing
        })
        let result = s.collect()
        assert(result.length() == 0)
    }

    test "state actor accumulates messages" {
        let counter = Task.state(0, (count: i64, msg: i64) -> i64 => {
            return count + msg
        })
        counter.send(1)
        counter.send(2)
        counter.send(3)
        let result = counter.close_and_join()
        assert(result == 6)
    }

    test "state actor with initial value" {
        let counter = Task.state(100, (count: i64, msg: i64) -> i64 => {
            return count + msg
        })
        counter.send(10)
        counter.send(20)
        let result = counter.close_and_join()
        assert(result == 130)
    }

    test "state actor with no messages returns initial" {
        let actor = Task.state(42, (s: i64, m: i64) -> i64 => {
            return s + m
        })
        let result = actor.close_and_join()
        assert(result == 42)
    }

    test "state actor multiply handler" {
        let product = Task.state(1, (acc: i64, msg: i64) -> i64 => {
            return acc * msg
        })
        product.send(2)
        product.send(3)
        product.send(4)
        let result = product.close_and_join()
        assert(result == 24)
    }

    test "state actor max handler" {
        let max_actor = Task.state(0, (best: i64, msg: i64) -> i64 => {
            if msg > best { return msg }
            return best
        })
        max_actor.send(3)
        max_actor.send(7)
        max_actor.send(2)
        max_actor.send(9)
        max_actor.send(1)
        let result = max_actor.close_and_join()
        assert(result == 9)
    }

    test "parallel map doubles values" {
        let results = Task.parallel<i64>([1, 2, 3, 4, 5], (x: i64) -> i64 => { return x * 2 })
        assert(results.length() == 5)
        let mut sum = 0
        for v in results.iter() {
            sum = sum + v
        }
        assert(sum == 30)
    }

    test "parallel with single item" {
        let results = Task.parallel<i64>([10], (x: i64) -> i64 => { return x + 1 })
        assert(results.length() == 1)
        assert(results[0] == 11)
    }

    test "parallel with multiple items" {
        let results = Task.parallel<i64>([5, 10], (x: i64) -> i64 => { return x * 10 })
        assert(results.length() == 2)
        let mut sum = 0
        for v in results.iter() {
            sum = sum + v
        }
        assert(sum == 150)
    }

    test "parallel identity transform" {
        let results = Task.parallel<i64>([7, 14, 21], (x: i64) -> i64 => { return x })
        assert(results.length() == 3)
        let mut sum = 0
        for v in results.iter() {
            sum = sum + v
        }
        assert(sum == 42)
    }

    test "buffered channel send and receive" {
        let ch = Channel.buffered<i64>(4)
        assert(ch.send(42))
        assert(ch.send(99))
        assert(ch.receive() == 42)
        assert(ch.receive() == 99)
    }

    test "buffered channel FIFO order" {
        let ch = Channel.buffered<i64>(8)
        ch.send(1)
        ch.send(2)
        ch.send(3)
        ch.send(4)
        ch.send(5)
        assert(ch.receive() == 1)
        assert(ch.receive() == 2)
        assert(ch.receive() == 3)
        assert(ch.receive() == 4)
        assert(ch.receive() == 5)
    }

    test "channel close" {
        let ch = Channel.buffered<i64>(4)
        assert(!ch.is_closed())
        ch.close()
        assert(ch.is_closed())
    }

    test "send on closed returns false" {
        let ch = Channel.buffered<i64>(4)
        ch.close()
        assert(!ch.send(42))
    }

    test "try_receive drains then returns Done on close" {
        let ch = Channel.buffered<i64>(4)
        ch.send(10)
        ch.send(20)
        ch.close()
        let first = ch.try_receive()
        let second = ch.try_receive()
        let done = ch.try_receive()
        assert(first is i64)
        assert(second is i64)
        if first is i64 {
            assert(first == 10)
        }
        if second is i64 {
            assert(second == 20)
        }
        assert(done is Done)
    }

    test "double close is no-op" {
        let ch = Channel.buffered<i64>(4)
        ch.close()
        ch.close()
        assert(ch.is_closed())
    }

    test "channel new creates unbuffered" {
        let ch = Channel.new<i64>()
        assert(!ch.is_closed())
        ch.close()
        assert(ch.is_closed())
    }

    test "channel iter drains buffered values" {
        let ch = Channel.buffered<i64>(4)
        ch.send(10)
        ch.send(20)
        ch.send(30)
        ch.close()
        let mut sum = 0
        for v in ch.iter() {
            sum = sum + v
        }
        assert(sum == 60)
    }

    test "channel iter on empty closed channel yields nothing" {
        let ch = Channel.buffered<i64>(4)
        ch.close()
        let mut count = 0
        for v in ch.iter() {
            count = count + 1
        }
        assert(count == 0)
    }

    test "channel iter collect" {
        let ch = Channel.buffered<i64>(4)
        ch.send(1)
        ch.send(2)
        ch.send(3)
        ch.close()
        let arr = ch.iter().collect()
        assert(arr.length() == 3)
        assert(arr[0] == 1)
        assert(arr[1] == 2)
        assert(arr[2] == 3)
    }

    // =========================================================================
    // Zero-value sentinel tests â€” verify that literal 0 is not confused
    // with "channel closed" in iterators and state actors.
    // =========================================================================

    test "channel iter correctly receives literal zero" {
        let ch = Channel.buffered<i64>(4)
        ch.send(0)
        ch.send(1)
        ch.send(0)
        ch.close()
        let arr = ch.iter().collect()
        assert(arr.length() == 3)
        assert(arr[0] == 0)
        assert(arr[1] == 1)
        assert(arr[2] == 0)
    }

    test "channel iter with only zeros" {
        let ch = Channel.buffered<i64>(4)
        ch.send(0)
        ch.send(0)
        ch.send(0)
        ch.close()
        let mut count = 0
        for v in ch.iter() {
            assert(v == 0)
            count = count + 1
        }
        assert(count == 3)
    }

    test "stream iterator correctly receives literal zero" {
        let s = Task.stream((emit: (i64) -> void) => {
            emit(0)
            emit(1)
            emit(0)
        })
        let result = s.collect()
        assert(result.length() == 3)
        assert(result[0] == 0)
        assert(result[1] == 1)
        assert(result[2] == 0)
    }

    test "stream iterator with only zeros" {
        let s = Task.stream((emit: (i64) -> void) => {
            emit(0)
            emit(0)
            emit(0)
        })
        let mut count = 0
        for v in s {
            assert(v == 0)
            count = count + 1
        }
        assert(count == 3)
    }

    test "state actor processes zero messages correctly" {
        let counter = Task.state(0, (count: i64, msg: i64) -> i64 => {
            return count + 1
        })
        counter.send(0)
        counter.send(0)
        counter.send(0)
        let result = counter.close_and_join()
        assert(result == 3)
    }

    test "state actor with zero initial and zero messages" {
        let actor = Task.state(0, (s: i64, m: i64) -> i64 => {
            return s + m + 1
        })
        actor.send(0)
        actor.send(0)
        let result = actor.close_and_join()
        assert(result == 2)
    }

    // =========================================================================
    // Generic StateActor<T> tests (non-i64 types)
    // =========================================================================

    test "state actor with string concatenation" {
        let actor = Task.state("hello", (current: string, msg: string) -> string => {
            return current + " " + msg
        })
        actor.send("world")
        actor.send("from")
        actor.send("vole")
        let result = actor.close_and_join()
        assert(result == "hello world from vole")
    }

    test "state actor with string no messages returns initial" {
        let actor = Task.state("initial", (s: string, m: string) -> string => {
            return s + m
        })
        let result = actor.close_and_join()
        assert(result == "initial")
    }

    test "state actor with bool toggles" {
        let actor = Task.state(false, (current: bool, msg: bool) -> bool => {
            if msg { return !current }
            return current
        })
        actor.send(true)   // false -> true
        actor.send(true)   // true -> false
        actor.send(true)   // false -> true
        let result = actor.close_and_join()
        assert(result == true)
    }

    test "state actor with bool no messages returns initial" {
        let actor = Task.state(true, (s: bool, m: bool) -> bool => {
            return s
        })
        let result = actor.close_and_join()
        assert(result == true)
    }

    test "task f64 join" {
        let t = Task.run(() -> f64 => { return 3.14 })
        let result = t.join()
        assert(result == 3.14)
    }

    test "task all f64" {
        let fns: [() -> f64] = [
            () -> f64 => { return 1.1 },
            () -> f64 => { return 2.2 },
            () -> f64 => { return 3.3 },
        ]
        let results = Task.all(fns)
        assert(results.length() == 3)
        assert(results[0] == 1.1)
        assert(results[1] == 2.2)
        assert(results[2] == 3.3)
    }

    test "state actor f64 accumulates" {
        let actor = Task.state(0.0, (acc: f64, msg: f64) -> f64 => {
            return acc + msg
        })
        actor.send(1.5)
        actor.send(2.5)
        actor.send(3.0)
        let result = actor.close_and_join()
        assert(result == 7.0)
    }

    test "state actor f64 no messages returns initial" {
        let actor = Task.state(3.14, (s: f64, m: f64) -> f64 => {
            return s + m
        })
        let result = actor.close_and_join()
        assert(result == 3.14)
    }

    // =========================================================================
    // Task.select tests
    // =========================================================================

    test "select2 returns first available buffered channel" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        ch2.send(42)
        let result = Task.select2(ch1, ch2, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 1)
        assert(result.value == 42)
    }

    test "select2 lowest index wins when both ready" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        ch1.send(10)
        ch2.send(20)
        let result = Task.select2(ch1, ch2, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 0)
        assert(result.value == 10)
    }

    test "select2 with task producing value" {
        let ch1 = Channel.buffered<i64>(1)
        let ch2 = Channel.buffered<i64>(1)
        let t = Task.run(() -> i64 => {
            ch2.send(99)
            return 0
        })
        let result = Task.select2(ch1, ch2, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 1)
        assert(result.value == 99)
        _ = t.join()
    }

    test "select2 with closed channel" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        ch1.close()
        let result = Task.select2(ch1, ch2, 0)
        assert(!result.timed_out)
        // Closed channel is "ready" (recv returns 0)
        assert(result.channel_index == 0)
    }

    test "select3 returns correct index" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        let ch3 = Channel.buffered<i64>(4)
        ch3.send(77)
        let result = Task.select3(ch1, ch2, ch3, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 2)
        assert(result.value == 77)
    }

    test "select3 lowest index wins" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        let ch3 = Channel.buffered<i64>(4)
        ch1.send(1)
        ch2.send(2)
        ch3.send(3)
        let result = Task.select3(ch1, ch2, ch3, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 0)
        assert(result.value == 1)
    }

    test "select2 blocks until data arrives" {
        let ch1 = Channel.buffered<i64>(1)
        let ch2 = Channel.buffered<i64>(1)
        // Spawn a task that sends to ch1 after some work
        let t = Task.run(() -> i64 => {
            ch1.send(42)
            return 0
        })
        let result = Task.select2(ch1, ch2, 0)
        assert(!result.timed_out)
        assert(result.channel_index == 0)
        assert(result.value == 42)
        _ = t.join()
    }

    test "select2 with timeout returns timed_out" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        // Use a very short timeout (1 nanosecond)
        // Since no task is producing data, this should time out.
        // From within a task, this will block and then timeout.
        let t = Task.run(() -> i64 => {
            let result = Task.select2(ch1, ch2, 1)
            if result.timed_out { return 1 }
            return 0
        })
        let v = t.join()
        assert(v == 1)
    }

    test "select2 multiple rounds" {
        let ch1 = Channel.buffered<i64>(4)
        let ch2 = Channel.buffered<i64>(4)
        ch1.send(10)
        ch2.send(20)

        // First select: ch1 wins (lowest index)
        let r1 = Task.select2(ch1, ch2, 0)
        assert(r1.channel_index == 0)
        assert(r1.value == 10)

        // Second select: only ch2 has data now
        let r2 = Task.select2(ch1, ch2, 0)
        assert(r2.channel_index == 1)
        assert(r2.value == 20)
    }
}
