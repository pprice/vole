// Integration test: HTTP client-server simulation.
//
// Simulates a 10MB POST body sent via a buffered(4) channel.
// Uses i64 chunk markers and exercises backpressure,
// correct data flow, and scheduler fairness.
// The pattern tests backpressure
// (bounded buffer), correct data flow (ordered chunks), and
// scheduler fairness (2560 iterations with cooperative yield
// on channel blocking).

let { Task, Channel } = import "std:task"

tests {
    test "client sends 2560 chunks through buffered(4) channel" {
        let CHUNK_SIZE = 4096
        let TOTAL_SIZE = 10485760 // 10 MB
        let CHUNK_COUNT = TOTAL_SIZE / CHUNK_SIZE // 2560

        // Buffered channel: at most 4 chunks in flight.
        let body_ch = Channel.buffered<i64>(4)

        // Client task: sends 2560 chunk markers.
        let client = Task.run(() -> i64 => {
            var sent = 0
            while sent < CHUNK_COUNT {
                body_ch.send(sent)
                sent = sent + 1
            }
            body_ch.close()
            return sent
        })

        // Server task: accumulates all chunks, verifies order and total.
        let server = Task.run(() -> i64 => {
            var total_chunks = 0
            var expected = 0
            while true {
                let r = body_ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    assert(r == expected)
                    expected = expected + 1
                    total_chunks = total_chunks + 1
                }
            }
            return total_chunks
        })

        // Wait for both to complete.
        let chunks_sent = client.join()
        let chunks_received = server.join()

        assert(chunks_sent == CHUNK_COUNT)
        assert(chunks_received == CHUNK_COUNT)
        assert(chunks_sent == 2560)
    }

    test "producer-consumer with computed values" {
        let ch = Channel.buffered<i64>(4)

        // Producer: computes squares 1..100
        let producer = Task.run(() -> i64 => {
            var i = 1
            while i <= 100 {
                ch.send(i * i)
                i = i + 1
            }
            ch.close()
            return 100
        })

        // Consumer: sums all squares
        let consumer = Task.run(() -> i64 => {
            var sum = 0
            while true {
                let r = ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    sum = sum + r
                }
            }
            return sum
        })

        let count = producer.join()
        let total = consumer.join()

        assert(count == 100)
        // Sum of squares 1^2 + 2^2 + ... + 100^2 = 100*101*201/6 = 338350
        assert(total == 338350)
    }

    test "pipeline: producer -> transformer -> consumer" {
        let raw_ch = Channel.buffered<i64>(4)
        let processed_ch = Channel.buffered<i64>(4)

        // Producer: sends raw values 1..50
        let producer = Task.run(() -> i64 => {
            var i = 1
            while i <= 50 {
                raw_ch.send(i)
                i = i + 1
            }
            raw_ch.close()
            return 50
        })

        // Transformer: doubles each value
        let transformer = Task.run(() -> i64 => {
            var count = 0
            while true {
                let r = raw_ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    processed_ch.send(r * 2)
                    count = count + 1
                }
            }
            processed_ch.close()
            return count
        })

        // Consumer: sums the transformed values
        let consumer = Task.run(() -> i64 => {
            var sum = 0
            while true {
                let r = processed_ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    sum = sum + r
                }
            }
            return sum
        })

        let produced = producer.join()
        let transformed = transformer.join()
        let total = consumer.join()

        assert(produced == 50)
        assert(transformed == 50)
        // Sum of 2*1 + 2*2 + ... + 2*50 = 2 * (50*51/2) = 2550
        assert(total == 2550)
    }

    test "fan-out fan-in: multiple workers process items" {
        let work_ch = Channel.buffered<i64>(8)
        let result_ch = Channel.buffered<i64>(20)

        // Dispatcher: sends 20 work items
        let dispatcher = Task.run(() -> i64 => {
            var i = 1
            while i <= 20 {
                work_ch.send(i)
                i = i + 1
            }
            work_ch.close()
            return 20
        })

        // Worker 1: processes items from work channel
        let worker1 = Task.run(() -> i64 => {
            var count = 0
            while true {
                let r = work_ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    result_ch.send(r * 10)
                    count = count + 1
                }
            }
            return count
        })

        // Worker 2: also processes items from work channel
        let worker2 = Task.run(() -> i64 => {
            var count = 0
            while true {
                let r = work_ch.try_receive()
                if r is Done { break }
                if r is i64 {
                    result_ch.send(r * 10)
                    count = count + 1
                }
            }
            return count
        })

        // Wait for dispatcher and workers to finish
        _ = dispatcher.join()
        let w1 = worker1.join()
        let w2 = worker2.join()
        result_ch.close()

        // Total items processed by both workers should be 20
        assert(w1 + w2 == 20)

        // Sum all results from the result channel
        var total = 0
        while true {
            let r = result_ch.try_receive()
            if r is Done { break }
            if r is i64 {
                total = total + r
            }
        }
        // Sum of 10*1 + 10*2 + ... + 10*20 = 10 * (20*21/2) = 2100
        assert(total == 2100)
    }
}
