// Isolation test: Generic static method calls on module-imported types
// Related to vol-4wn9 and vol-dknq
//
// Generic static methods like Set.new<T>() and Set.with_capacity<T>()
// work fine when called directly from user code. The bug triggers when
// module-internal code calls these static methods (e.g., Set.union()
// internally calls Set.new<T>() to create the result set).
let { Set } = import "std:collections/set"

tests {
    // Direct static calls work fine in isolation (sanity check)
    test "Set.new<i64>() direct static call works" {
        let s = Set.new<i64>()
        assert(s.is_empty())
        assert(s.len() == 0)
    }

    test "Set.with_capacity<i64>() direct static call works" {
        let s = Set.with_capacity<i64>(16)
        assert(s.is_empty())
    }

    // Internal static calls via module methods — the actual bug
    test "Set.union() calls Set.new<T>() internally" {
        let a = Set.new<i64>()
        _ = a.add(10)
        _ = a.add(20)

        let b = Set.new<i64>()
        _ = b.add(20)
        _ = b.add(30)

        let u = a.union(b)
        assert(u.len() == 3)
    }

    test "Set.intersection() calls Set.new<T>() internally" {
        let a = Set.new<i64>()
        _ = a.add(1)
        _ = a.add(2)

        let b = Set.new<i64>()
        _ = b.add(2)
        _ = b.add(3)

        let i = a.intersection(b)
        assert(i.len() == 1)
        assert(i.contains(2))
    }

    test "Set.difference() calls Set.new<T>() internally" {
        let a = Set.new<i64>()
        _ = a.add(1)
        _ = a.add(2)

        let b = Set.new<i64>()
        _ = b.add(2)

        let d = a.difference(b)
        assert(d.len() == 1)
        assert(d.contains(1))
    }

    test "Set.symmetric_difference() calls Set.new<T>() internally" {
        let a = Set.new<i64>()
        _ = a.add(1)
        _ = a.add(2)

        let b = Set.new<i64>()
        _ = b.add(2)
        _ = b.add(3)

        let sd = a.symmetric_difference(b)
        assert(sd.len() == 2)
        assert(sd.contains(1))
        assert(sd.contains(3))
    }

    // String type variant — different monomorphization
    test "Set<string>.union() calls Set.new<T>() internally" {
        let a = Set.new<string>()
        _ = a.add("alpha")
        _ = a.add("beta")

        let b = Set.new<string>()
        _ = b.add("beta")
        _ = b.add("gamma")

        let u = a.union(b)
        assert(u.len() == 3)
        assert(u.contains("alpha"))
        assert(u.contains("beta"))
        assert(u.contains("gamma"))
    }
}
