// Tests for module-qualified class literals
// This tests the ability to use `module.RecordType { fields }` syntax
//
// Note: These tests are intentionally isolated from std:time function tests
// to avoid module type identity issues when both test files run together.

// Define a local module for testing to avoid conflicts with std:time tests
class LocalRecord {
    x: i64,
    y: i64
}

func local_sum(r: LocalRecord) -> i64 {
    return r.x + r.y
}

// Also test with std:time to verify cross-module works
let time = import "std:time"

tests {
    test "module-qualified class literal - Duration" {
        // Create a Duration using module-qualified syntax
        let d = time.Duration { nanos: 1000000 }  // 1ms in nanoseconds
        assert(d.nanos == 1000000)
    }

    test "module-qualified class literal - Timestamp" {
        // Create a Timestamp using module-qualified syntax
        let t = time.Timestamp { nanos: 0, offset_mins: 60 }  // Unix epoch with +1hr offset
        assert(t.nanos == 0)
        assert(t.offset_mins == 60)
    }

    test "qualified literal field access chain" {
        // Create and immediately access field
        let n = time.Duration { nanos: 42 }.nanos
        assert(n == 42)
    }

    test "local class literal works" {
        // Test that local (non-qualified) class literals still work
        let r = LocalRecord { x: 10, y: 20 }
        assert(r.x == 10)
        assert(r.y == 20)
    }

    test "local class with function" {
        // Test local classes work with functions
        let r = LocalRecord { x: 5, y: 7 }
        assert(local_sum(r) == 12)
    }
}
