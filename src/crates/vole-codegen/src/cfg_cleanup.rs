// src/codegen/cfg_cleanup.rs
//
// CFG cleanup pass to eliminate trampoline blocks.
//
// A trampoline block is a block that contains only a single `jump` instruction
// and has no block parameters. These are generated by naive IR construction
// (e.g., if/else always creates 3 blocks even for trivial branches).
//
// This pass:
// 1. Identifies trampoline blocks (single jump, no params, no side effects)
// 2. Rewrites all references to point to the final target
// 3. The unused blocks become dead and are cleaned up by unreachable code elimination

use cranelift_codegen::ir::{Block, Function, Opcode};
use rustc_hash::FxHashMap;

/// Clean up trampoline blocks in the function.
///
/// This pass rewrites branch targets to bypass trampoline blocks - blocks that
/// contain only an unconditional jump and no block parameters.
///
/// After this pass, Cranelift's normal unreachable code elimination will
/// remove the now-unreferenced trampoline blocks.
pub fn cleanup_cfg(func: &mut Function) {
    // Step 1: Find all trampoline blocks and their targets
    let trampolines = find_trampolines(func);
    if trampolines.is_empty() {
        return;
    }

    // Step 2: Resolve chains (trampoline -> trampoline -> real target)
    let resolved = resolve_trampoline_chains(&trampolines);

    // Step 3: Rewrite all branch/jump targets
    rewrite_terminators(func, &resolved);
}

/// Find all trampoline blocks in the function.
///
/// A trampoline block is one that:
/// - Has no block parameters
/// - Contains exactly one instruction
/// - That instruction is an unconditional jump
fn find_trampolines(func: &Function) -> FxHashMap<Block, Block> {
    let mut trampolines = FxHashMap::default();

    for block in func.layout.blocks() {
        // Skip blocks with parameters - they're not simple trampolines
        if !func.dfg.block_params(block).is_empty() {
            continue;
        }

        // Check if block has exactly one instruction
        let first_inst = func.layout.first_inst(block);
        let last_inst = func.layout.last_inst(block);

        if first_inst != last_inst {
            // More than one instruction
            continue;
        }

        let Some(inst) = first_inst else {
            // Empty block (shouldn't happen in valid IR)
            continue;
        };

        // Check if it's a simple unconditional jump
        let opcode = func.dfg.insts[inst].opcode();
        if opcode != Opcode::Jump {
            continue;
        }

        // Get the jump target
        let destinations = func.dfg.insts[inst]
            .branch_destination(&func.dfg.jump_tables, &func.dfg.exception_tables);
        if destinations.len() != 1 {
            continue;
        }

        let target = destinations[0].block(&func.dfg.value_lists);

        // Check that the jump has no arguments (no phi values to pass)
        if destinations[0].len(&func.dfg.value_lists) > 0 {
            continue;
        }

        trampolines.insert(block, target);
    }

    trampolines
}

/// Resolve trampoline chains to their final targets.
///
/// If block A jumps to B and B jumps to C, we want A to jump directly to C.
/// Cycles are detected and those trampolines are not included in the result.
fn resolve_trampoline_chains(trampolines: &FxHashMap<Block, Block>) -> FxHashMap<Block, Block> {
    let mut resolved = FxHashMap::default();

    for (&trampoline, &initial_target) in trampolines {
        let mut target = initial_target;
        let mut visited = vec![trampoline];
        let mut is_cycle = false;

        // Follow the chain until we hit a non-trampoline or a cycle
        while let Some(&next) = trampolines.get(&target) {
            if visited.contains(&target) {
                // Cycle detected - don't rewrite this trampoline
                is_cycle = true;
                break;
            }
            visited.push(target);
            target = next;
        }

        // Only add to resolved if we found a valid final target (not a cycle)
        if !is_cycle {
            resolved.insert(trampoline, target);
        }
    }

    resolved
}

/// Rewrite all terminator instructions to bypass trampolines.
fn rewrite_terminators(func: &mut Function, trampolines: &FxHashMap<Block, Block>) {
    // Collect all instructions with their rewrite targets first
    let rewrites: Vec<(cranelift_codegen::ir::Inst, Vec<(Block, Block)>)> = func
        .layout
        .blocks()
        .filter_map(|block| {
            let inst = func.layout.last_inst(block)?;
            let destinations = func.dfg.insts[inst]
                .branch_destination(&func.dfg.jump_tables, &func.dfg.exception_tables);
            let block_rewrites: Vec<_> = destinations
                .iter()
                .filter_map(|dest| {
                    let current = dest.block(&func.dfg.value_lists);
                    trampolines.get(&current).map(|&new| (current, new))
                })
                .collect();
            if block_rewrites.is_empty() {
                None
            } else {
                Some((inst, block_rewrites))
            }
        })
        .collect();

    // Apply rewrites using the DFG's fields directly
    for (inst, block_rewrites) in rewrites {
        let dfg = &mut func.dfg;
        for (old_block, new_block) in block_rewrites {
            for dest in dfg.insts[inst]
                .branch_destination_mut(&mut dfg.jump_tables, &mut dfg.exception_tables)
            {
                if dest.block(&dfg.value_lists) == old_block {
                    dest.set_block(new_block, &mut dfg.value_lists);
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cranelift::prelude::*;

    fn create_test_function() -> Function {
        let mut func = Function::new();
        func.signature.returns.push(AbiParam::new(types::I64));
        func
    }

    #[test]
    fn test_find_no_trampolines() {
        let func = create_test_function();
        let trampolines = find_trampolines(&func);
        assert!(trampolines.is_empty());
    }

    #[test]
    fn test_resolve_simple_chain() {
        let mut trampolines = FxHashMap::default();
        // Simulate: block0 -> block1 -> block2 (final)
        let b0 = Block::from_u32(0);
        let b1 = Block::from_u32(1);
        let b2 = Block::from_u32(2);
        trampolines.insert(b0, b1);
        trampolines.insert(b1, b2);

        let resolved = resolve_trampoline_chains(&trampolines);

        // Both should resolve to block2
        assert_eq!(resolved.get(&b0), Some(&b2));
        assert_eq!(resolved.get(&b1), Some(&b2));
    }

    #[test]
    fn test_resolve_cycle_detection() {
        let mut trampolines = FxHashMap::default();
        // Simulate a cycle: block0 -> block1 -> block0
        let b0 = Block::from_u32(0);
        let b1 = Block::from_u32(1);
        trampolines.insert(b0, b1);
        trampolines.insert(b1, b0);

        let resolved = resolve_trampoline_chains(&trampolines);

        // Cycles should not be rewritten (would cause infinite loops)
        assert_eq!(resolved.get(&b0), None);
        assert_eq!(resolved.get(&b1), None);
    }
}
