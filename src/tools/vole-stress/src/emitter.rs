//! Fill phase: Generate Vole source code from the symbol table.
//!
//! The emitter converts the planned declarations into actual Vole source code,
//! generating function bodies and expressions that reference symbols from the
//! complete symbol table.

use rand::Rng;
use std::fmt::Write as _;
use std::io;
use std::path::Path;

use crate::entrypoints::{emit_integration_tests, emit_main};
use crate::expr::{ExprConfig, ExprContext, ExprGenerator};
use crate::stmt::{StmtConfig, StmtContext, StmtGenerator};
use crate::symbols::{
    ClassInfo, FieldInfo, FunctionInfo, ImplementBlockInfo, InterfaceInfo, MethodInfo,
    ModuleSymbols, ParamInfo, PrimitiveType, Symbol, SymbolKind, SymbolTable, TypeInfo, TypeParam,
};

/// Configuration for the emitter phase.
#[derive(Debug, Clone, Default)]
pub struct EmitConfig {
    /// Configuration for statement generation.
    pub stmt_config: StmtConfig,
}

/// Emit all modules to the given output directory.
pub fn emit_all<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    config: &EmitConfig,
    output_dir: &Path,
) -> io::Result<()> {
    for module in table.modules() {
        let code = emit_module(rng, table, module, config);
        let path = output_dir.join(&module.path);
        std::fs::write(path, code)?;
    }

    // Emit main.vole entrypoint
    let main_code = emit_main(rng, table);
    let main_path = output_dir.join("main.vole");
    std::fs::write(main_path, main_code)?;

    // Emit tests.vole integration tests
    let tests_code = emit_integration_tests(rng, table);
    let tests_path = output_dir.join("tests.vole");
    std::fs::write(tests_path, tests_code)?;

    Ok(())
}

/// Emit a single module to a string.
pub fn emit_module<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    module: &ModuleSymbols,
    config: &EmitConfig,
) -> String {
    let mut ctx = EmitContext::new(rng, table, module, config);
    ctx.emit_module();
    ctx.output
}

/// Context for emitting a module.
struct EmitContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    module: &'a ModuleSymbols,
    config: &'a EmitConfig,
    output: String,
    indent: usize,
}

impl<'a, R: Rng> EmitContext<'a, R> {
    fn new(
        rng: &'a mut R,
        table: &'a SymbolTable,
        module: &'a ModuleSymbols,
        config: &'a EmitConfig,
    ) -> Self {
        Self {
            rng,
            table,
            module,
            config,
            output: String::new(),
            indent: 0,
        }
    }

    fn emit_module(&mut self) {
        // Emit file header comment
        self.emit_line(&format!("// Module: {}", self.module.name));
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Emit imports
        self.emit_imports();

        // Emit globals
        for symbol in self.module.globals() {
            self.emit_global(symbol);
        }

        // Emit interfaces
        for symbol in self.module.interfaces() {
            self.emit_interface(symbol);
        }

        // Emit errors
        for symbol in self.module.errors() {
            self.emit_error(symbol);
        }

        // Emit structs
        for symbol in self.module.structs() {
            self.emit_struct(symbol);
        }

        // Emit classes
        for symbol in self.module.classes() {
            self.emit_class(symbol);
        }

        // Emit functions
        for symbol in self.module.functions() {
            self.emit_function(symbol);
        }

        // Emit implement blocks
        for symbol in self.module.implement_blocks() {
            self.emit_implement_block(symbol);
        }

        // Emit module tests
        self.emit_module_tests();
    }

    /// Emit a tests block that exercises the module's functions, classes, and structs.
    fn emit_module_tests(&mut self) {
        // Collect functions, classes, and structs to test
        let functions: Vec<_> = self.module.functions().collect();
        let classes: Vec<_> = self.module.classes().collect();
        let structs: Vec<_> = self.module.structs().collect();

        // Skip if nothing to test
        if functions.is_empty() && classes.is_empty() && structs.is_empty() {
            return;
        }

        self.emit_line("");
        self.emit_line(&format!("tests \"{}\" {{", self.module.name));
        self.indent += 1;

        // Generate tests for each function
        for symbol in &functions {
            self.emit_function_test(symbol);
        }

        // Generate tests for each class
        for symbol in &classes {
            self.emit_class_test(symbol);
        }

        // Generate tests for each struct
        for symbol in &structs {
            self.emit_struct_test(symbol);
        }

        self.indent -= 1;
        self.emit_line("}")
    }

    /// Emit a test for a function.
    fn emit_function_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            // Skip functions with type parameters (generics) - too complex to test simply
            if !info.type_params.is_empty() {
                return;
            }

            self.emit_line(&format!("test \"{} works\" {{", symbol.name));
            self.indent += 1;

            // Generate arguments for the function call
            let args = self.generate_test_args(&info.params);
            let call = format!("{}({})", symbol.name, args);

            // Generate the test body based on return type
            match &info.return_type {
                TypeInfo::Iterator(elem_type) => {
                    // Generator function - exercise with iterator methods
                    let chain = self.generate_iterator_chain(elem_type);
                    self.emit_line(&format!("let _result = {}{}", call, chain));
                    self.emit_line("assert(true)");
                }
                TypeInfo::Fallible { success, .. } => {
                    // Fallible function - wrap in match to handle success/error
                    let default_val = self.generate_test_value(success);
                    self.emit_line(&format!(
                        "let _result = match {} {{ success x => x, error => {}, _ => {} }}",
                        call, default_val, default_val
                    ));
                    self.emit_line("assert(true)");
                }
                TypeInfo::Void => {
                    // Void function - just call it and assert true
                    self.emit_line(&call);
                    self.emit_line("assert(true)");
                }
                TypeInfo::Optional(_) => {
                    // Optional return - check it doesn't panic
                    self.emit_line(&format!("let result = {}", call));
                    self.emit_line("assert(result != nil || result == nil)");
                }
                _ => {
                    // Non-void, non-optional return - just verify call succeeds
                    // (non-optional types can't be compared to nil in Vole)
                    self.emit_line(&format!("let _ = {}", call));
                    self.emit_line("assert(true)");
                }
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Emit a test for a class.
    fn emit_class_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            // Skip classes with type parameters (generics) - too complex to test simply
            if !info.type_params.is_empty() {
                return;
            }

            self.emit_line(&format!("test \"{} construction\" {{", symbol.name));
            self.indent += 1;

            // Generate field values for construction
            let field_values = self.generate_class_field_values(&info.fields);
            self.emit_line(&format!(
                "let instance = {} {{ {} }}",
                symbol.name, field_values
            ));
            // Construction succeeded if we get here
            // (non-optional class instances can't be compared to nil in Vole)
            self.emit_line("assert(true)");

            // Test each method that doesn't have type parameters
            for method in &info.methods {
                let args = self.generate_test_args(&method.params);
                match &method.return_type {
                    TypeInfo::Void => {
                        self.emit_line(&format!("instance.{}({})", method.name, args));
                    }
                    _ => {
                        self.emit_line(&format!(
                            "let _{}_result = instance.{}({})",
                            method.name, method.name, args
                        ));
                    }
                }
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Emit a test for a struct (construction and field access).
    fn emit_struct_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Struct(ref info) = symbol.kind {
            self.emit_line(&format!("test \"{} construction\" {{", symbol.name));
            self.indent += 1;

            // Generate field values for construction
            let field_values = self.generate_struct_field_values(&info.fields);
            self.emit_line(&format!(
                "let instance = {} {{ {} }}",
                symbol.name, field_values
            ));
            // Construction succeeded if we get here
            self.emit_line("assert(true)");

            // Test field access for each field
            for field in &info.fields {
                self.emit_line(&format!(
                    "let _{}_val = instance.{}",
                    field.name, field.name
                ));
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Generate test arguments for function/method parameters.
    fn generate_test_args(&mut self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| self.generate_test_value(&p.param_type))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate a test value for a given type.
    fn generate_test_value(&mut self, ty: &TypeInfo) -> String {
        match ty {
            TypeInfo::Primitive(prim) => self.generate_primitive_test_value(*prim),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Array(elem) => {
                let elem_val = self.generate_test_value(elem);
                format!("[{}]", elem_val)
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                // For union types, generate a value for the first variant
                if let Some(first) = variants.first() {
                    self.generate_test_value(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Class(mod_id, sym_id) => {
                // For class types, construct an instance
                if let Some(symbol) = self.table.get_symbol(*mod_id, *sym_id) {
                    if let SymbolKind::Class(ref class_info) = symbol.kind {
                        if class_info.type_params.is_empty() {
                            let fields = self.generate_class_field_values(&class_info.fields);
                            return format!("{} {{ {} }}", symbol.name, fields);
                        }
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Struct(mod_id, sym_id) => {
                // For struct types, construct an instance
                if let Some(symbol) = self.table.get_symbol(*mod_id, *sym_id) {
                    if let SymbolKind::Struct(ref struct_info) = symbol.kind {
                        let fields = self.generate_struct_field_values(&struct_info.fields);
                        return format!("{} {{ {} }}", symbol.name, fields);
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Function {
                param_types,
                return_type,
            } => {
                // Generate a lambda matching the function type
                let config = ExprConfig::default();
                let mut expr_gen = ExprGenerator::new(self.rng, &config);
                let table = self.table;
                let ctx = ExprContext::new(&[], &[], table);
                expr_gen.generate_lambda(param_types, return_type, &ctx, config.max_depth)
            }
            _ => "nil".to_string(),
        }
    }

    /// Generate a primitive test value.
    fn generate_primitive_test_value(&mut self, prim: PrimitiveType) -> String {
        match prim {
            PrimitiveType::I8 => {
                let val: i8 = self.rng.gen_range(1..50);
                format!("{}_i8", val)
            }
            PrimitiveType::I16 => {
                let val: i16 = self.rng.gen_range(1..100);
                format!("{}_i16", val)
            }
            PrimitiveType::I32 => {
                let val: i32 = self.rng.gen_range(1..50);
                format!("{}_i32", val)
            }
            PrimitiveType::I64 => {
                let val: i64 = self.rng.gen_range(1..100);
                format!("{}_i64", val)
            }
            PrimitiveType::I128 => {
                let val: i64 = self.rng.gen_range(1..1000);
                format!("{}_i128", val)
            }
            PrimitiveType::U8 => {
                let val: u8 = self.rng.gen_range(1..50);
                format!("{}_u8", val)
            }
            PrimitiveType::U16 => {
                let val: u16 = self.rng.gen_range(1..100);
                format!("{}_u16", val)
            }
            PrimitiveType::U32 => {
                let val: u32 = self.rng.gen_range(1..100);
                format!("{}_u32", val)
            }
            PrimitiveType::U64 => {
                let val: u64 = self.rng.gen_range(1..1000);
                format!("{}_u64", val)
            }
            PrimitiveType::F32 => {
                let val: f32 = self.rng.gen_range(1.0_f32..50.0_f32);
                format!("{:.2}_f32", val)
            }
            PrimitiveType::F64 => {
                let val: f64 = self.rng.gen_range(1.0..50.0);
                format!("{:.2}_f64", val)
            }
            PrimitiveType::Bool => "true".to_string(),
            PrimitiveType::String => {
                let id = self.rng.gen_range(0..100);
                format!("\"test{}\"", id)
            }
            PrimitiveType::Nil => "nil".to_string(),
        }
    }

    /// Generate field values for class construction.
    fn generate_class_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate field values for struct construction.
    fn generate_struct_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_imports(&mut self) {
        for import in &self.module.imports {
            if let Some(target) = self.table.get_module(import.target_module) {
                self.emit_line(&format!(
                    "let {} = import \"./{}.vole\"",
                    import.alias, target.name
                ));
            }
        }
        if !self.module.imports.is_empty() {
            self.emit_line("");
        }
    }

    fn emit_global(&mut self, symbol: &Symbol) {
        if let SymbolKind::Global(ref info) = symbol.kind {
            let mutability = if info.is_mutable { "let mut" } else { "let" };
            // Non-mutable globals are exported and must use constant expressions
            // (single literal tokens, no unary negation) so the module analyzer
            // can evaluate them at compile time.
            let value = if info.is_mutable {
                self.literal_for_type(&info.value_type)
            } else {
                self.constant_literal_for_type(&info.value_type)
            };
            self.emit_line(&format!(
                "{} {}: {} = {}",
                mutability,
                symbol.name,
                info.value_type.to_vole_syntax(self.table),
                value
            ));
        }
    }

    fn emit_interface(&mut self, symbol: &Symbol) {
        if let SymbolKind::Interface(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_interface_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            for method in &info.methods {
                self.emit_method_signature(method);
            }
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_interface_header(&self, name: &str, info: &InterfaceInfo) -> String {
        let mut header = String::from("interface ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        // Add extends clause
        if !info.extends.is_empty() {
            let parent_names: Vec<String> = info
                .extends
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !parent_names.is_empty() {
                header.push_str(" extends ");
                header.push_str(&parent_names.join(", "));
            }
        }

        header
    }

    fn emit_error(&mut self, symbol: &Symbol) {
        if let SymbolKind::Error(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("error {} {{}}", symbol.name));
            } else {
                let fields: Vec<String> = info
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.field_type.to_vole_syntax(self.table)))
                    .collect();
                self.emit_line(&format!(
                    "error {} {{ {} }}",
                    symbol.name,
                    fields.join(", ")
                ));
            }
        }
    }

    fn emit_struct(&mut self, symbol: &Symbol) {
        if let SymbolKind::Struct(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("struct {} {{}}", symbol.name));
            } else {
                self.emit_line(&format!("struct {} {{", symbol.name));
                self.indent += 1;
                for field in &info.fields {
                    self.emit_field(field);
                }
                self.indent -= 1;
                self.emit_line("}");
            }
        }
    }

    fn emit_class(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            self.emit_line("");
            self.emit_class_header(symbol, info);
            self.indent += 1;

            // Emit fields
            for field in &info.fields {
                self.emit_field(field);
            }

            // Emit methods
            for method in &info.methods {
                self.emit_method(method);
            }

            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_class_header(&mut self, symbol: &Symbol, info: &ClassInfo) {
        let mut header = String::from("class ");
        header.push_str(&symbol.name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        if !info.implements.is_empty() {
            let iface_names: Vec<String> = info
                .implements
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !iface_names.is_empty() {
                header.push_str(" implements ");
                header.push_str(&iface_names.join(", "));
            }
        }

        header.push_str(" {");
        self.emit_line(&header);
    }

    fn emit_field(&mut self, field: &FieldInfo) {
        self.emit_line(&format!(
            "{}: {},",
            field.name,
            field.field_type.to_vole_syntax(self.table)
        ));
    }

    fn emit_method_signature(&mut self, method: &MethodInfo) {
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!("func {}({}){}", method.name, params, return_type));
    }

    fn emit_method(&mut self, method: &MethodInfo) {
        self.emit_line("");
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!(
            "func {}({}){} {{",
            method.name, params, return_type
        ));
        self.indent += 1;
        self.emit_function_body(&method.return_type, &method.params, None);
        self.indent -= 1;
        self.emit_line("}");
    }

    fn emit_function(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_function_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            self.emit_function_body(&info.return_type, &info.params, Some(&symbol.name));
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_function_header(&self, name: &str, info: &FunctionInfo) -> String {
        let mut header = String::from("func ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        header.push('(');
        header.push_str(&self.format_params(&info.params));
        header.push(')');
        header.push_str(&self.format_return_type(&info.return_type));

        header
    }

    fn emit_function_body(
        &mut self,
        return_type: &TypeInfo,
        params: &[ParamInfo],
        function_name: Option<&str>,
    ) {
        // Generator functions (returning Iterator<T>) get a special body with yield
        if let TypeInfo::Iterator(elem_type) = return_type {
            self.emit_generator_body(elem_type, params);
            return;
        }

        let mut stmt_ctx = StmtContext::with_module(params, self.table, self.module.id);

        // Track the current function name to prevent self-recursion
        stmt_ctx.current_function_name = function_name.map(String::from);

        // If this function has a fallible return type, mark the context as fallible
        if let TypeInfo::Fallible { error, .. } = return_type {
            stmt_ctx.is_fallible = true;
            // Collect fallible functions in this module for try expressions
            stmt_ctx.fallible_error_type = Some(error.as_ref().clone());
        }

        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let lines = stmt_gen.generate_body(return_type, &mut stmt_ctx, 0);

        for line in lines {
            self.emit_line(&line);
        }
    }

    /// Emit a generator function body with a while loop and yield statements.
    ///
    /// Generates a simple bounded loop pattern:
    /// ```vole
    /// let mut i = 0
    /// while i < N {
    ///     yield <expr of elem_type>
    ///     i = i + 1
    /// }
    /// ```
    fn emit_generator_body(&mut self, elem_type: &TypeInfo, params: &[ParamInfo]) {
        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let stmt_ctx = StmtContext::with_module(params, self.table, self.module.id);
        let lines = stmt_gen.generate_generator_body(elem_type, &stmt_ctx);

        for line in lines {
            self.emit_line(&line);
        }
    }

    /// Generate a random iterator method chain for a generator call.
    ///
    /// The element type determines which terminal methods are valid:
    /// - `.sum()` is only valid for numeric element types
    /// - `.count()` is always valid and returns i64
    /// - All other chains end with `.collect()`
    fn generate_iterator_chain(&mut self, elem_type: &TypeInfo) -> String {
        let is_numeric = matches!(
            elem_type,
            TypeInfo::Primitive(PrimitiveType::I64)
                | TypeInfo::Primitive(PrimitiveType::I32)
                | TypeInfo::Primitive(PrimitiveType::F64)
        );

        // Choose a chain pattern
        let pattern = self.rng.gen_range(0..10);
        match pattern {
            0..=3 => {
                // Plain .collect()
                ".collect()".to_string()
            }
            4 => {
                // .take(n).collect()
                let n = self.rng.gen_range(1..=3);
                format!(".take({}).collect()", n)
            }
            5 => {
                // .skip(n).collect()
                let n = self.rng.gen_range(1..=2);
                format!(".skip({}).collect()", n)
            }
            6 => {
                // .count()
                ".count()".to_string()
            }
            7 if is_numeric => {
                // .sum() - only for numeric types
                ".sum()".to_string()
            }
            8 => {
                // .filter(predicate).collect()
                let pred = self.generate_filter_predicate(elem_type);
                format!(".filter({}).collect()", pred)
            }
            9 => {
                // .map(transform).collect()
                let mapper = self.generate_map_lambda(elem_type);
                format!(".map({}).collect()", mapper)
            }
            _ => {
                // Fallback to .collect()
                ".collect()".to_string()
            }
        }
    }

    /// Generate a filter predicate lambda for a given element type.
    fn generate_filter_predicate(&mut self, elem_type: &TypeInfo) -> String {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x > 0_i64".to_string(),
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x > 0_i32".to_string(),
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x > 0.0_f64".to_string(),
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => x".to_string(),
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => true".to_string(),
            _ => "(x) => true".to_string(),
        }
    }

    /// Generate a map transformation lambda for a given element type.
    fn generate_map_lambda(&mut self, elem_type: &TypeInfo) -> String {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x + 1_i64".to_string(),
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x + 1_i32".to_string(),
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x + 1.0_f64".to_string(),
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => !x".to_string(),
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => x".to_string(),
            _ => "(x) => x".to_string(),
        }
    }

    fn format_params(&self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.param_type.to_vole_syntax(self.table)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn format_return_type(&self, return_type: &TypeInfo) -> String {
        match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        }
    }

    fn format_type_params(&self, type_params: &[TypeParam]) -> String {
        type_params
            .iter()
            .map(|tp| {
                if tp.constraints.is_empty() {
                    tp.name.clone()
                } else {
                    let constraint_names: Vec<String> = tp
                        .constraints
                        .iter()
                        .filter_map(|(mod_id, sym_id)| {
                            self.table
                                .get_symbol(*mod_id, *sym_id)
                                .map(|s| s.name.clone())
                        })
                        .collect();
                    format!("{}: {}", tp.name, constraint_names.join(" + "))
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_implement_block(&mut self, symbol: &Symbol) {
        if let SymbolKind::ImplementBlock(ref info) = symbol.kind {
            self.emit_implement_block_inner(info);
        }
    }

    fn emit_implement_block_inner(&mut self, info: &ImplementBlockInfo) {
        // Get interface and target type names
        let iface_name = self
            .table
            .get_symbol(info.interface.0, info.interface.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownInterface".to_string());

        let target_name = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownType".to_string());

        self.emit_line("");
        self.emit_line(&format!("implement {} for {} {{", iface_name, target_name));
        self.indent += 1;

        for method in &info.methods {
            self.emit_method(method);
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.literal_for_primitive(*p),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                // For union types, generate a literal for the first variant
                if let Some(first) = variants.first() {
                    drop(expr_gen);
                    self.literal_for_type(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Array(elem) => {
                drop(expr_gen);
                let elem_val = self.literal_for_type(elem);
                format!("[{}]", elem_val)
            }
            _ => "nil".to_string(),
        }
    }

    /// Generate a constant-safe literal for a type. Only produces values that
    /// the module analyzer recognizes as compile-time constants (no unary
    /// negation, no complex expressions).
    fn constant_literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.constant_literal_for_primitive(*p),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                if let Some(first) = variants.first() {
                    drop(expr_gen);
                    self.constant_literal_for_type(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Array(elem) => {
                drop(expr_gen);
                let elem_val = self.constant_literal_for_type(elem);
                format!("[{}]", elem_val)
            }
            _ => "nil".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent_str, line).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use crate::symbols::ModuleId;
    use rand::SeedableRng;

    #[test]
    fn emit_module_produces_code() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("// Module:"));
        assert!(code.contains("func"));
    }

    #[test]
    fn emit_module_contains_class() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("class Class"));
    }

    #[test]
    fn emit_module_contains_interface() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (1, 1),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("interface IFace"));
    }

    #[test]
    fn emit_is_deterministic() {
        let plan_config = PlanConfig::default();
        let emit_config = EmitConfig::default();

        let mut rng1 = rand::rngs::StdRng::seed_from_u64(12345);
        let table1 = plan(&mut rng1, &plan_config);
        let module1 = table1.get_module(ModuleId(0)).unwrap();
        let code1 = emit_module(&mut rng1, &table1, module1, &emit_config);

        let mut rng2 = rand::rngs::StdRng::seed_from_u64(12345);
        let table2 = plan(&mut rng2, &plan_config);
        let module2 = table2.get_module(ModuleId(0)).unwrap();
        let code2 = emit_module(&mut rng2, &table2, module2, &emit_config);

        assert_eq!(code1, code2);
    }

    #[test]
    fn emit_module_contains_tests_block() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain a tests block
        assert!(code.contains("tests \""));
        // Should contain test declarations
        assert!(code.contains("test \""));
        // Should contain assertions
        assert!(code.contains("assert("));
    }

    #[test]
    fn emit_module_tests_for_functions() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain function tests
        assert!(code.contains("test \"func"));
        assert!(code.contains("works\""));
    }

    #[test]
    fn emit_module_tests_for_classes() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain class construction test
        assert!(code.contains("construction\""));
        assert!(code.contains("let instance ="));
    }

    #[test]
    fn emit_module_contains_struct() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(
            code.contains("struct Struct"),
            "Expected struct declaration in output, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_module_tests_for_structs() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain struct construction test
        assert!(
            code.contains("construction\""),
            "Expected struct construction test, got:\n{}",
            code
        );
        assert!(
            code.contains("let instance ="),
            "Expected struct instance creation, got:\n{}",
            code
        );
    }

    #[test]
    fn generated_code_has_no_undefined_type_params() {
        use crate::profile::get_profile;
        use crate::symbols::{SymbolKind, TypeInfo};

        // Use the problematic seed that exposed the bug
        let profile = get_profile("full").unwrap();
        let seed = 1770226963014480876_u64;
        let mut rng = rand::rngs::StdRng::seed_from_u64(seed);

        let table = plan(&mut rng, &profile.plan);

        // Check at the symbol table level - this is the real source of truth
        for module in table.modules() {
            // Check classes
            for symbol in module.classes() {
                if let SymbolKind::Class(ref info) = symbol.kind {
                    let class_type_params: std::collections::HashSet<_> =
                        info.type_params.iter().map(|tp| &tp.name).collect();

                    // Check fields
                    for field in &info.fields {
                        if let TypeInfo::TypeParam(ref name) = field.field_type {
                            assert!(
                                class_type_params.contains(name),
                                "Class {} field {} uses undefined type param {}. Class type params: {:?}",
                                symbol.name,
                                field.name,
                                name,
                                class_type_params
                            );
                        }
                    }

                    // Check methods
                    for method in &info.methods {
                        for param in &method.params {
                            if let TypeInfo::TypeParam(ref name) = param.param_type {
                                assert!(
                                    class_type_params.contains(name),
                                    "Class {} method {} param {} uses undefined type param {}. Class type params: {:?}",
                                    symbol.name,
                                    method.name,
                                    param.name,
                                    name,
                                    class_type_params
                                );
                            }
                        }
                        if let TypeInfo::TypeParam(ref name) = method.return_type {
                            assert!(
                                class_type_params.contains(name),
                                "Class {} method {} return uses undefined type param {}. Class type params: {:?}",
                                symbol.name,
                                method.name,
                                name,
                                class_type_params
                            );
                        }
                    }
                }
            }

            // Check functions
            for symbol in module.functions() {
                if let SymbolKind::Function(ref info) = symbol.kind {
                    let func_type_params: std::collections::HashSet<_> =
                        info.type_params.iter().map(|tp| &tp.name).collect();

                    for param in &info.params {
                        if let TypeInfo::TypeParam(ref name) = param.param_type {
                            assert!(
                                func_type_params.contains(name),
                                "Function {} param {} uses undefined type param {}. Function type params: {:?}",
                                symbol.name,
                                param.name,
                                name,
                                func_type_params
                            );
                        }
                    }
                    if let TypeInfo::TypeParam(ref name) = info.return_type {
                        assert!(
                            func_type_params.contains(name),
                            "Function {} return uses undefined type param {}. Function type params: {:?}",
                            symbol.name,
                            name,
                            func_type_params
                        );
                    }
                }
            }
        }
    }
}
