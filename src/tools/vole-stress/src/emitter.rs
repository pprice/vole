//! Fill phase: Generate Vole source code from the symbol table.
//!
//! The emitter converts the planned declarations into actual Vole source code,
//! generating function bodies and expressions that reference symbols from the
//! complete symbol table.

use rand::Rng;
use std::fmt::Write as _;
use std::io;
use std::path::Path;

use crate::expr::{ExprConfig, ExprGenerator};
use crate::stmt::{StmtConfig, StmtContext, StmtGenerator};
use crate::symbols::{
    ClassInfo, FieldInfo, FunctionInfo, ImplementBlockInfo, InterfaceInfo, MethodInfo,
    ModuleSymbols, ParamInfo, PrimitiveType, Symbol, SymbolKind, SymbolTable, TypeInfo, TypeParam,
};

/// Configuration for the emitter phase.
#[derive(Debug, Clone, Default)]
pub struct EmitConfig {
    /// Configuration for statement generation.
    pub stmt_config: StmtConfig,
}

/// Emit all modules to the given output directory.
pub fn emit_all<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    config: &EmitConfig,
    output_dir: &Path,
) -> io::Result<()> {
    for module in table.modules() {
        let code = emit_module(rng, table, module, config);
        let path = output_dir.join(&module.path);
        std::fs::write(path, code)?;
    }
    Ok(())
}

/// Emit a single module to a string.
pub fn emit_module<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    module: &ModuleSymbols,
    config: &EmitConfig,
) -> String {
    let mut ctx = EmitContext::new(rng, table, module, config);
    ctx.emit_module();
    ctx.output
}

/// Context for emitting a module.
struct EmitContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    module: &'a ModuleSymbols,
    config: &'a EmitConfig,
    output: String,
    indent: usize,
}

impl<'a, R: Rng> EmitContext<'a, R> {
    fn new(
        rng: &'a mut R,
        table: &'a SymbolTable,
        module: &'a ModuleSymbols,
        config: &'a EmitConfig,
    ) -> Self {
        Self {
            rng,
            table,
            module,
            config,
            output: String::new(),
            indent: 0,
        }
    }

    fn emit_module(&mut self) {
        // Emit file header comment
        self.emit_line(&format!("// Module: {}", self.module.name));
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Emit imports
        self.emit_imports();

        // Emit globals
        for symbol in self.module.globals() {
            self.emit_global(symbol);
        }

        // Emit interfaces
        for symbol in self.module.interfaces() {
            self.emit_interface(symbol);
        }

        // Emit errors
        for symbol in self.module.errors() {
            self.emit_error(symbol);
        }

        // Emit classes
        for symbol in self.module.classes() {
            self.emit_class(symbol);
        }

        // Emit functions
        for symbol in self.module.functions() {
            self.emit_function(symbol);
        }

        // Emit implement blocks
        for symbol in self.module.implement_blocks() {
            self.emit_implement_block(symbol);
        }

        // Emit module tests
        self.emit_module_tests();
    }

    /// Emit a tests block that exercises the module's functions and classes.
    fn emit_module_tests(&mut self) {
        // Collect functions and classes to test
        let functions: Vec<_> = self.module.functions().collect();
        let classes: Vec<_> = self.module.classes().collect();

        // Skip if nothing to test
        if functions.is_empty() && classes.is_empty() {
            return;
        }

        self.emit_line("");
        self.emit_line(&format!("tests \"{}\" {{", self.module.name));
        self.indent += 1;

        // Generate tests for each function
        for symbol in &functions {
            self.emit_function_test(symbol);
        }

        // Generate tests for each class
        for symbol in &classes {
            self.emit_class_test(symbol);
        }

        self.indent -= 1;
        self.emit_line("}")
    }

    /// Emit a test for a function.
    fn emit_function_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            // Skip functions with type parameters (generics) - too complex to test simply
            if !info.type_params.is_empty() {
                return;
            }

            self.emit_line(&format!("test \"{} works\" {{", symbol.name));
            self.indent += 1;

            // Generate arguments for the function call
            let args = self.generate_test_args(&info.params);
            let call = format!("{}({})", symbol.name, args);

            // Generate the test body based on return type
            match &info.return_type {
                TypeInfo::Void => {
                    // Void function - just call it and assert true
                    self.emit_line(&call);
                    self.emit_line("assert(true)");
                }
                TypeInfo::Optional(_) => {
                    // Optional return - check it doesn't panic
                    self.emit_line(&format!("let result = {}", call));
                    self.emit_line("assert(result != nil || result == nil)");
                }
                _ => {
                    // Non-void return - store result and assert not nil
                    self.emit_line(&format!("let result = {}", call));
                    self.emit_line("assert(result != nil)");
                }
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Emit a test for a class.
    fn emit_class_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            // Skip classes with type parameters (generics) - too complex to test simply
            if !info.type_params.is_empty() {
                return;
            }

            self.emit_line(&format!("test \"{} construction\" {{", symbol.name));
            self.indent += 1;

            // Generate field values for construction
            let field_values = self.generate_class_field_values(&info.fields);
            self.emit_line(&format!(
                "let instance = {} {{ {} }}",
                symbol.name, field_values
            ));
            self.emit_line("assert(instance != nil)");

            // Test each method that doesn't have type parameters
            for method in &info.methods {
                let args = self.generate_test_args(&method.params);
                match &method.return_type {
                    TypeInfo::Void => {
                        self.emit_line(&format!("instance.{}({})", method.name, args));
                    }
                    _ => {
                        self.emit_line(&format!(
                            "let _{}_result = instance.{}({})",
                            method.name, method.name, args
                        ));
                    }
                }
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Generate test arguments for function/method parameters.
    fn generate_test_args(&mut self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| self.generate_test_value(&p.param_type))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate a test value for a given type.
    fn generate_test_value(&mut self, ty: &TypeInfo) -> String {
        match ty {
            TypeInfo::Primitive(prim) => self.generate_primitive_test_value(*prim),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Array(elem) => {
                let elem_val = self.generate_test_value(elem);
                format!("[{}]", elem_val)
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Class(mod_id, sym_id) => {
                // For class types, construct an instance
                if let Some(symbol) = self.table.get_symbol(*mod_id, *sym_id) {
                    if let SymbolKind::Class(ref class_info) = symbol.kind {
                        if class_info.type_params.is_empty() {
                            let fields = self.generate_class_field_values(&class_info.fields);
                            return format!("{} {{ {} }}", symbol.name, fields);
                        }
                    }
                }
                "nil".to_string()
            }
            _ => "nil".to_string(),
        }
    }

    /// Generate a primitive test value.
    fn generate_primitive_test_value(&mut self, prim: PrimitiveType) -> String {
        match prim {
            PrimitiveType::I32 => {
                let val: i32 = self.rng.gen_range(1..50);
                format!("{}_i32", val)
            }
            PrimitiveType::I64 => {
                let val: i64 = self.rng.gen_range(1..100);
                format!("{}_i64", val)
            }
            PrimitiveType::F64 => {
                let val: f64 = self.rng.gen_range(1.0..50.0);
                format!("{:.2}_f64", val)
            }
            PrimitiveType::Bool => "true".to_string(),
            PrimitiveType::String => {
                let id = self.rng.gen_range(0..100);
                format!("\"test{}\"", id)
            }
            PrimitiveType::Nil => "nil".to_string(),
        }
    }

    /// Generate field values for class construction.
    fn generate_class_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_imports(&mut self) {
        for import in &self.module.imports {
            if let Some(target) = self.table.get_module(import.target_module) {
                self.emit_line(&format!(
                    "let {} = import \"./{}.vole\"",
                    import.alias, target.name
                ));
            }
        }
        if !self.module.imports.is_empty() {
            self.emit_line("");
        }
    }

    fn emit_global(&mut self, symbol: &Symbol) {
        if let SymbolKind::Global(ref info) = symbol.kind {
            let mutability = if info.is_mutable { "let mut" } else { "let" };
            let value = self.literal_for_type(&info.value_type);
            self.emit_line(&format!(
                "{} {}: {} = {}",
                mutability,
                symbol.name,
                info.value_type.to_vole_syntax(self.table),
                value
            ));
        }
    }

    fn emit_interface(&mut self, symbol: &Symbol) {
        if let SymbolKind::Interface(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_interface_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            for method in &info.methods {
                self.emit_method_signature(method);
            }
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_interface_header(&self, name: &str, info: &InterfaceInfo) -> String {
        let mut header = String::from("interface ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        // Add extends clause
        if !info.extends.is_empty() {
            let parent_names: Vec<String> = info
                .extends
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !parent_names.is_empty() {
                header.push_str(" extends ");
                header.push_str(&parent_names.join(", "));
            }
        }

        header
    }

    fn emit_error(&mut self, symbol: &Symbol) {
        if let SymbolKind::Error(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("error {} {{}}", symbol.name));
            } else {
                let fields: Vec<String> = info
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.field_type.to_vole_syntax(self.table)))
                    .collect();
                self.emit_line(&format!(
                    "error {} {{ {} }}",
                    symbol.name,
                    fields.join(", ")
                ));
            }
        }
    }

    fn emit_class(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            self.emit_line("");
            self.emit_class_header(symbol, info);
            self.indent += 1;

            // Emit fields
            for field in &info.fields {
                self.emit_field(field);
            }

            // Emit methods
            for method in &info.methods {
                self.emit_method(method);
            }

            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_class_header(&mut self, symbol: &Symbol, info: &ClassInfo) {
        let mut header = String::from("class ");
        header.push_str(&symbol.name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        if !info.implements.is_empty() {
            let iface_names: Vec<String> = info
                .implements
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !iface_names.is_empty() {
                header.push_str(" implements ");
                header.push_str(&iface_names.join(", "));
            }
        }

        header.push_str(" {");
        self.emit_line(&header);
    }

    fn emit_field(&mut self, field: &FieldInfo) {
        self.emit_line(&format!(
            "{}: {},",
            field.name,
            field.field_type.to_vole_syntax(self.table)
        ));
    }

    fn emit_method_signature(&mut self, method: &MethodInfo) {
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!("func {}({}){}", method.name, params, return_type));
    }

    fn emit_method(&mut self, method: &MethodInfo) {
        self.emit_line("");
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!(
            "func {}({}){} {{",
            method.name, params, return_type
        ));
        self.indent += 1;
        self.emit_function_body(&method.return_type, &method.params);
        self.indent -= 1;
        self.emit_line("}");
    }

    fn emit_function(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_function_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            self.emit_function_body(&info.return_type, &info.params);
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_function_header(&self, name: &str, info: &FunctionInfo) -> String {
        let mut header = String::from("func ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        header.push('(');
        header.push_str(&self.format_params(&info.params));
        header.push(')');
        header.push_str(&self.format_return_type(&info.return_type));

        header
    }

    fn emit_function_body(&mut self, return_type: &TypeInfo, params: &[ParamInfo]) {
        let mut stmt_ctx = StmtContext::new(params, self.table);
        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let lines = stmt_gen.generate_body(return_type, &mut stmt_ctx, 0);

        for line in lines {
            self.emit_line(&line);
        }
    }

    fn format_params(&self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.param_type.to_vole_syntax(self.table)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn format_return_type(&self, return_type: &TypeInfo) -> String {
        match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        }
    }

    fn format_type_params(&self, type_params: &[TypeParam]) -> String {
        type_params
            .iter()
            .map(|tp| {
                if tp.constraints.is_empty() {
                    tp.name.clone()
                } else {
                    let constraint_names: Vec<String> = tp
                        .constraints
                        .iter()
                        .filter_map(|(mod_id, sym_id)| {
                            self.table
                                .get_symbol(*mod_id, *sym_id)
                                .map(|s| s.name.clone())
                        })
                        .collect();
                    format!("{}: {}", tp.name, constraint_names.join(" + "))
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_implement_block(&mut self, symbol: &Symbol) {
        if let SymbolKind::ImplementBlock(ref info) = symbol.kind {
            self.emit_implement_block_inner(info);
        }
    }

    fn emit_implement_block_inner(&mut self, info: &ImplementBlockInfo) {
        // Get interface and target type names
        let iface_name = self
            .table
            .get_symbol(info.interface.0, info.interface.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownInterface".to_string());

        let target_name = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownType".to_string());

        self.emit_line("");
        self.emit_line(&format!("implement {} for {} {{", iface_name, target_name));
        self.indent += 1;

        for method in &info.methods {
            self.emit_method(method);
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.literal_for_primitive(*p),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Void => "nil".to_string(),
            _ => "nil".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent_str, line).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use crate::symbols::ModuleId;
    use rand::SeedableRng;

    #[test]
    fn emit_module_produces_code() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("// Module:"));
        assert!(code.contains("func"));
    }

    #[test]
    fn emit_module_contains_class() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("class Class"));
    }

    #[test]
    fn emit_module_contains_interface() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (1, 1),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("interface IFace"));
    }

    #[test]
    fn emit_is_deterministic() {
        let plan_config = PlanConfig::default();
        let emit_config = EmitConfig::default();

        let mut rng1 = rand::rngs::StdRng::seed_from_u64(12345);
        let table1 = plan(&mut rng1, &plan_config);
        let module1 = table1.get_module(ModuleId(0)).unwrap();
        let code1 = emit_module(&mut rng1, &table1, module1, &emit_config);

        let mut rng2 = rand::rngs::StdRng::seed_from_u64(12345);
        let table2 = plan(&mut rng2, &plan_config);
        let module2 = table2.get_module(ModuleId(0)).unwrap();
        let code2 = emit_module(&mut rng2, &table2, module2, &emit_config);

        assert_eq!(code1, code2);
    }

    #[test]
    fn emit_module_contains_tests_block() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain a tests block
        assert!(code.contains("tests \""));
        // Should contain test declarations
        assert!(code.contains("test \""));
        // Should contain assertions
        assert!(code.contains("assert("));
    }

    #[test]
    fn emit_module_tests_for_functions() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain function tests
        assert!(code.contains("test \"func"));
        assert!(code.contains("works\""));
    }

    #[test]
    fn emit_module_tests_for_classes() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain class construction test
        assert!(code.contains("construction\""));
        assert!(code.contains("let instance ="));
    }
}
