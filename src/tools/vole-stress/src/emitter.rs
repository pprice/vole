//! Fill phase: Generate Vole source code from the symbol table.
//!
//! The emitter converts the planned declarations into actual Vole source code,
//! generating function bodies and expressions that reference symbols from the
//! complete symbol table.

use rand::Rng;
use std::fmt::Write as _;
use std::io;
use std::path::Path;

use crate::expr::{ExprConfig, ExprGenerator};
use crate::stmt::{StmtConfig, StmtContext, StmtGenerator};
use crate::symbols::{
    ClassInfo, FieldInfo, FunctionInfo, ImplementBlockInfo, InterfaceInfo, MethodInfo,
    ModuleSymbols, ParamInfo, Symbol, SymbolKind, SymbolTable, TypeInfo, TypeParam,
};

/// Configuration for the emitter phase.
#[derive(Debug, Clone, Default)]
pub struct EmitConfig {
    /// Configuration for statement generation.
    pub stmt_config: StmtConfig,
}

/// Emit all modules to the given output directory.
pub fn emit_all<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    config: &EmitConfig,
    output_dir: &Path,
) -> io::Result<()> {
    for module in table.modules() {
        let code = emit_module(rng, table, module, config);
        let path = output_dir.join(&module.path);
        std::fs::write(path, code)?;
    }
    Ok(())
}

/// Emit a single module to a string.
pub fn emit_module<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    module: &ModuleSymbols,
    config: &EmitConfig,
) -> String {
    let mut ctx = EmitContext::new(rng, table, module, config);
    ctx.emit_module();
    ctx.output
}

/// Context for emitting a module.
struct EmitContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    module: &'a ModuleSymbols,
    config: &'a EmitConfig,
    output: String,
    indent: usize,
}

impl<'a, R: Rng> EmitContext<'a, R> {
    fn new(
        rng: &'a mut R,
        table: &'a SymbolTable,
        module: &'a ModuleSymbols,
        config: &'a EmitConfig,
    ) -> Self {
        Self {
            rng,
            table,
            module,
            config,
            output: String::new(),
            indent: 0,
        }
    }

    fn emit_module(&mut self) {
        // Emit file header comment
        self.emit_line(&format!("// Module: {}", self.module.name));
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Emit imports
        self.emit_imports();

        // Emit globals
        for symbol in self.module.globals() {
            self.emit_global(symbol);
        }

        // Emit interfaces
        for symbol in self.module.interfaces() {
            self.emit_interface(symbol);
        }

        // Emit errors
        for symbol in self.module.errors() {
            self.emit_error(symbol);
        }

        // Emit classes
        for symbol in self.module.classes() {
            self.emit_class(symbol);
        }

        // Emit functions
        for symbol in self.module.functions() {
            self.emit_function(symbol);
        }

        // Emit implement blocks
        for symbol in self.module.implement_blocks() {
            self.emit_implement_block(symbol);
        }
    }

    fn emit_imports(&mut self) {
        for import in &self.module.imports {
            if let Some(target) = self.table.get_module(import.target_module) {
                self.emit_line(&format!(
                    "let {} = import \"./{}.vole\"",
                    import.alias, target.name
                ));
            }
        }
        if !self.module.imports.is_empty() {
            self.emit_line("");
        }
    }

    fn emit_global(&mut self, symbol: &Symbol) {
        if let SymbolKind::Global(ref info) = symbol.kind {
            let mutability = if info.is_mutable { "let mut" } else { "let" };
            let value = self.literal_for_type(&info.value_type);
            self.emit_line(&format!(
                "{} {}: {} = {}",
                mutability,
                symbol.name,
                info.value_type.to_vole_syntax(self.table),
                value
            ));
        }
    }

    fn emit_interface(&mut self, symbol: &Symbol) {
        if let SymbolKind::Interface(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_interface_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            for method in &info.methods {
                self.emit_method_signature(method);
            }
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_interface_header(&self, name: &str, info: &InterfaceInfo) -> String {
        let mut header = String::from("interface ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        // Add extends clause
        if !info.extends.is_empty() {
            let parent_names: Vec<String> = info
                .extends
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !parent_names.is_empty() {
                header.push_str(" extends ");
                header.push_str(&parent_names.join(", "));
            }
        }

        header
    }

    fn emit_error(&mut self, symbol: &Symbol) {
        if let SymbolKind::Error(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("error {} {{}}", symbol.name));
            } else {
                let fields: Vec<String> = info
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.field_type.to_vole_syntax(self.table)))
                    .collect();
                self.emit_line(&format!(
                    "error {} {{ {} }}",
                    symbol.name,
                    fields.join(", ")
                ));
            }
        }
    }

    fn emit_class(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            self.emit_line("");
            self.emit_class_header(symbol, info);
            self.indent += 1;

            // Emit fields
            for field in &info.fields {
                self.emit_field(field);
            }

            // Emit methods
            for method in &info.methods {
                self.emit_method(method);
            }

            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_class_header(&mut self, symbol: &Symbol, info: &ClassInfo) {
        let mut header = String::from("class ");
        header.push_str(&symbol.name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        if !info.implements.is_empty() {
            let iface_names: Vec<String> = info
                .implements
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !iface_names.is_empty() {
                header.push_str(" implements ");
                header.push_str(&iface_names.join(", "));
            }
        }

        header.push_str(" {");
        self.emit_line(&header);
    }

    fn emit_field(&mut self, field: &FieldInfo) {
        self.emit_line(&format!(
            "{}: {},",
            field.name,
            field.field_type.to_vole_syntax(self.table)
        ));
    }

    fn emit_method_signature(&mut self, method: &MethodInfo) {
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!("func {}({}){}", method.name, params, return_type));
    }

    fn emit_method(&mut self, method: &MethodInfo) {
        self.emit_line("");
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!(
            "func {}({}){} {{",
            method.name, params, return_type
        ));
        self.indent += 1;
        self.emit_function_body(&method.return_type, &method.params);
        self.indent -= 1;
        self.emit_line("}");
    }

    fn emit_function(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_function_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            self.emit_function_body(&info.return_type, &info.params);
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_function_header(&self, name: &str, info: &FunctionInfo) -> String {
        let mut header = String::from("func ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        header.push('(');
        header.push_str(&self.format_params(&info.params));
        header.push(')');
        header.push_str(&self.format_return_type(&info.return_type));

        header
    }

    fn emit_function_body(&mut self, return_type: &TypeInfo, params: &[ParamInfo]) {
        let mut stmt_ctx = StmtContext::new(params, self.table);
        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let lines = stmt_gen.generate_body(return_type, &mut stmt_ctx, 0);

        for line in lines {
            self.emit_line(&line);
        }
    }

    fn format_params(&self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.param_type.to_vole_syntax(self.table)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn format_return_type(&self, return_type: &TypeInfo) -> String {
        match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        }
    }

    fn format_type_params(&self, type_params: &[TypeParam]) -> String {
        type_params
            .iter()
            .map(|tp| {
                if tp.constraints.is_empty() {
                    tp.name.clone()
                } else {
                    let constraint_names: Vec<String> = tp
                        .constraints
                        .iter()
                        .filter_map(|(mod_id, sym_id)| {
                            self.table
                                .get_symbol(*mod_id, *sym_id)
                                .map(|s| s.name.clone())
                        })
                        .collect();
                    format!("{}: {}", tp.name, constraint_names.join(" + "))
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_implement_block(&mut self, symbol: &Symbol) {
        if let SymbolKind::ImplementBlock(ref info) = symbol.kind {
            self.emit_implement_block_inner(info);
        }
    }

    fn emit_implement_block_inner(&mut self, info: &ImplementBlockInfo) {
        // Get interface and target type names
        let iface_name = self
            .table
            .get_symbol(info.interface.0, info.interface.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownInterface".to_string());

        let target_name = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownType".to_string());

        self.emit_line("");
        self.emit_line(&format!("implement {} for {} {{", iface_name, target_name));
        self.indent += 1;

        for method in &info.methods {
            self.emit_method(method);
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.literal_for_primitive(*p),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Void => "nil".to_string(),
            _ => "nil".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent_str, line).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use crate::symbols::ModuleId;
    use rand::SeedableRng;

    #[test]
    fn emit_module_produces_code() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("// Module:"));
        assert!(code.contains("func"));
    }

    #[test]
    fn emit_module_contains_class() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("class Class"));
    }

    #[test]
    fn emit_module_contains_interface() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (1, 1),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("interface IFace"));
    }

    #[test]
    fn emit_is_deterministic() {
        let plan_config = PlanConfig::default();
        let emit_config = EmitConfig::default();

        let mut rng1 = rand::rngs::StdRng::seed_from_u64(12345);
        let table1 = plan(&mut rng1, &plan_config);
        let module1 = table1.get_module(ModuleId(0)).unwrap();
        let code1 = emit_module(&mut rng1, &table1, module1, &emit_config);

        let mut rng2 = rand::rngs::StdRng::seed_from_u64(12345);
        let table2 = plan(&mut rng2, &plan_config);
        let module2 = table2.get_module(ModuleId(0)).unwrap();
        let code2 = emit_module(&mut rng2, &table2, module2, &emit_config);

        assert_eq!(code1, code2);
    }
}
