//! Fill phase: Generate Vole source code from the symbol table.
//!
//! The emitter converts the planned declarations into actual Vole source code,
//! generating function bodies and expressions that reference symbols from the
//! complete symbol table.

use rand::Rng;
use std::fmt::Write as _;
use std::io;
use std::path::Path;

use crate::entrypoints::{emit_integration_tests, emit_main};
use crate::expr::{ExprConfig, ExprContext, ExprGenerator};
use crate::stmt::{StmtConfig, StmtContext, StmtGenerator};
use crate::symbols::{
    ClassInfo, FieldInfo, FunctionInfo, ImplementBlockInfo, InterfaceInfo, MethodInfo, ModuleId,
    ModuleSymbols, ParamInfo, PrimitiveType, StaticMethodInfo, Symbol, SymbolId, SymbolKind,
    SymbolTable, TypeInfo, TypeParam,
};

/// Configuration for the emitter phase.
#[derive(Debug, Clone)]
pub struct EmitConfig {
    /// Configuration for statement generation.
    pub stmt_config: StmtConfig,
    /// Probability (0.0-1.0) that an import uses destructured syntax.
    /// E.g., `import { func_name, ClassName } from module_path`
    pub destructured_import_probability: f64,
    /// Probability (0.0-1.0) that a function uses expression-body syntax.
    /// E.g., `func double(x: i64) -> i64 => x * 2`
    /// Only applies to non-void, non-generator, non-never functions.
    pub expr_body_probability: f64,
}

impl Default for EmitConfig {
    fn default() -> Self {
        Self {
            stmt_config: StmtConfig::default(),
            destructured_import_probability: 0.0,
            expr_body_probability: 0.0,
        }
    }
}

/// Emit all modules to the given output directory.
pub fn emit_all<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    config: &EmitConfig,
    output_dir: &Path,
) -> io::Result<()> {
    for module in table.modules() {
        let code = emit_module(rng, table, module, config);
        let path = output_dir.join(&module.path);
        std::fs::write(path, code)?;
    }

    // Emit main.vole entrypoint
    let main_code = emit_main(rng, table);
    let main_path = output_dir.join("main.vole");
    std::fs::write(main_path, main_code)?;

    // Emit tests.vole integration tests
    let tests_code = emit_integration_tests(rng, table);
    let tests_path = output_dir.join("tests.vole");
    std::fs::write(tests_path, tests_code)?;

    Ok(())
}

/// Emit a single module to a string.
pub fn emit_module<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    module: &ModuleSymbols,
    config: &EmitConfig,
) -> String {
    let mut ctx = EmitContext::new(rng, table, module, config);
    ctx.emit_module();
    ctx.output
}

/// Context for emitting a module.
struct EmitContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    module: &'a ModuleSymbols,
    config: &'a EmitConfig,
    output: String,
    indent: usize,
    /// The class whose methods are currently being emitted.
    /// Set to prevent mutual recursion in generated method bodies.
    current_class: Option<(ModuleId, SymbolId)>,
}

impl<'a, R: Rng> EmitContext<'a, R> {
    fn new(
        rng: &'a mut R,
        table: &'a SymbolTable,
        module: &'a ModuleSymbols,
        config: &'a EmitConfig,
    ) -> Self {
        Self {
            rng,
            table,
            module,
            config,
            output: String::new(),
            indent: 0,
            current_class: None,
        }
    }

    fn emit_module(&mut self) {
        // Emit file header comment
        self.emit_line(&format!("// Module: {}", self.module.name));
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Emit imports
        self.emit_imports();

        // Emit globals
        for symbol in self.module.globals() {
            self.emit_global(symbol);
        }

        // Emit sentinels
        for symbol in self.module.sentinels() {
            self.emit_line(&format!("sentinel {}", symbol.name));
            self.emit_line("");
        }

        // Emit interfaces
        for symbol in self.module.interfaces() {
            self.emit_interface(symbol);
        }

        // Emit errors
        for symbol in self.module.errors() {
            self.emit_error(symbol);
        }

        // Emit structs
        for symbol in self.module.structs() {
            self.emit_struct(symbol);
        }

        // Emit classes
        for symbol in self.module.classes() {
            self.emit_class(symbol);
        }

        // Emit functions
        for symbol in self.module.functions() {
            self.emit_function(symbol);
        }

        // Emit implement blocks
        for symbol in self.module.implement_blocks() {
            self.emit_implement_block(symbol);
        }

        // Emit module tests
        self.emit_module_tests();
    }

    /// Emit a tests block that exercises the module's functions, classes, and structs.
    fn emit_module_tests(&mut self) {
        // Collect functions, classes, and structs to test
        let functions: Vec<_> = self.module.functions().collect();
        let classes: Vec<_> = self.module.classes().collect();
        let structs: Vec<_> = self.module.structs().collect();

        // Skip if nothing to test
        if functions.is_empty() && classes.is_empty() && structs.is_empty() {
            return;
        }

        self.emit_line("");
        self.emit_line(&format!("tests \"{}\" {{", self.module.name));
        self.indent += 1;

        // Generate tests for each function
        for symbol in &functions {
            self.emit_function_test(symbol);
        }

        // Generate tests for each class
        for symbol in &classes {
            self.emit_class_test(symbol);
        }

        // Generate tests for each struct
        for symbol in &structs {
            self.emit_struct_test(symbol);
        }

        self.indent -= 1;
        self.emit_line("}")
    }

    /// Emit a test for a function.
    fn emit_function_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            // Skip never-returning (diverge) functions - calling them always panics
            if matches!(info.return_type, TypeInfo::Never) {
                return;
            }

            // For generic functions, delegate to specialised test emitter.
            // Only single-type-param unconstrained generics are supported;
            // multi-param or constrained generics are still skipped.
            if !info.type_params.is_empty() {
                self.emit_generic_function_test(symbol, info);
                return;
            }

            self.emit_line(&format!("test \"{} works\" {{", symbol.name));
            self.indent += 1;

            // Generate arguments for the function call
            let args = self.generate_test_args(&info.params);
            let call = format!("{}({})", symbol.name, args);

            // Generate the test body based on return type
            self.emit_call_assertion(&call, &info.return_type);

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Emit a test for a generic function by substituting a concrete type
    /// for its type parameter, then calling with typed arguments.
    ///
    /// Handles single-type-parameter generic functions (both unconstrained and
    /// constrained) where the type param appears in at least one parameter
    /// position (so the compiler can infer the concrete type from arguments).
    ///
    /// For unconstrained generics, substitutes with a random primitive type.
    /// For constrained generics (`T: Interface1 + Interface2`), finds a
    /// non-generic class that implements all constraint interfaces and
    /// substitutes with that class type.
    fn emit_generic_function_test(&mut self, symbol: &Symbol, info: &FunctionInfo) {
        // Only single-type-param generics for now.
        if info.type_params.len() != 1 {
            return;
        }

        let tp_name = &info.type_params[0].name;
        let constraints = &info.type_params[0].constraints;

        // The type param must appear in at least one parameter so the
        // compiler can infer the concrete type from the arguments.
        let tp_in_params = info
            .params
            .iter()
            .any(|p| p.param_type.contains_type_param(tp_name));
        if !tp_in_params {
            return;
        }

        // Pick a concrete type for substitution.
        let concrete_type = if constraints.is_empty() {
            // Unconstrained: use a random primitive type.
            let concrete_prim = PrimitiveType::random_expr_type(self.rng);
            TypeInfo::Primitive(concrete_prim)
        } else {
            // Constrained: find a class implementing all constraint interfaces.
            match self.find_class_satisfying_constraints(constraints) {
                Some(ty) => ty,
                None => return, // No suitable class found, skip test
            }
        };

        // Substitute type param in all parameter types and the return type.
        let concrete_params: Vec<ParamInfo> = info
            .params
            .iter()
            .map(|p| ParamInfo {
                name: p.name.clone(),
                param_type: p.param_type.substitute_type_param(tp_name, &concrete_type),
            })
            .collect();
        let concrete_return = info
            .return_type
            .substitute_type_param(tp_name, &concrete_type);

        // Generate the test.
        self.emit_line(&format!("test \"{} works\" {{", symbol.name));
        self.indent += 1;

        let args = self.generate_test_args(&concrete_params);
        let call = format!("{}({})", symbol.name, args);

        self.emit_call_assertion(&call, &concrete_return);

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    /// Find a non-generic class that implements ALL of the given constraint
    /// interfaces. Returns `TypeInfo::Class(mod_id, sym_id)` if found.
    ///
    /// Only considers classes in the same module as the first constraint
    /// interface (all constraints come from the same module in vole-stress).
    fn find_class_satisfying_constraints(
        &self,
        constraints: &[(ModuleId, SymbolId)],
    ) -> Option<TypeInfo> {
        if constraints.is_empty() {
            return None;
        }

        // All constraints are from the same module in vole-stress
        let module_id = constraints[0].0;
        let module = self.table.get_module(module_id)?;

        // Collect the set of required interface SymbolIds
        let required: std::collections::HashSet<SymbolId> =
            constraints.iter().map(|&(_, sym_id)| sym_id).collect();

        // Find a non-generic class that implements all required interfaces.
        // Check both direct `class.implements` and standalone implement blocks.
        //
        // First, build a map from class SymbolId to set of implemented interfaces
        // (from implement blocks).
        let mut impl_block_map: std::collections::HashMap<
            SymbolId,
            std::collections::HashSet<SymbolId>,
        > = std::collections::HashMap::new();
        for sym in module.implement_blocks() {
            if let SymbolKind::ImplementBlock(ref info) = sym.kind {
                if let Some((iface_mod, iface_sym)) = info.interface {
                    if iface_mod == module_id {
                        let (_, class_sym) = info.target_type;
                        impl_block_map
                            .entry(class_sym)
                            .or_default()
                            .insert(iface_sym);
                    }
                }
            }
        }

        for sym in module.classes() {
            if let SymbolKind::Class(ref info) = sym.kind {
                if !info.type_params.is_empty() {
                    continue; // Skip generic classes
                }

                // Collect all interfaces this class implements (direct + implement blocks)
                let mut implemented: std::collections::HashSet<SymbolId> =
                    std::collections::HashSet::new();
                for &(m, s) in &info.implements {
                    if m == module_id {
                        implemented.insert(s);
                    }
                }
                if let Some(block_ifaces) = impl_block_map.get(&sym.id) {
                    implemented.extend(block_ifaces);
                }

                // Check if this class satisfies all constraints
                if required.iter().all(|r| implemented.contains(r)) {
                    return Some(TypeInfo::Class(module_id, sym.id));
                }
            }
        }

        None
    }

    /// Emit an assertion for a function call based on its return type.
    fn emit_call_assertion(&mut self, call: &str, return_type: &TypeInfo) {
        match return_type {
            TypeInfo::Iterator(elem_type) => {
                // Generator function - exercise with iterator methods
                let chain = self.generate_iterator_chain(elem_type);
                self.emit_line(&format!("let _result = {}{}", call, chain));
                self.emit_line("assert(true)");
            }
            TypeInfo::Fallible { success, .. } => {
                // Fallible function - wrap in match to handle success/error
                let default_val = self.generate_test_value(success);
                self.emit_line(&format!(
                    "let _result = match {} {{ success x => x, error => {}, _ => {} }}",
                    call, default_val, default_val
                ));
                self.emit_line("assert(true)");
            }
            TypeInfo::Void => {
                // Void function - just call it and assert true
                self.emit_line(call);
                self.emit_line("assert(true)");
            }
            TypeInfo::Optional(_) => {
                // Optional return - check it doesn't panic
                self.emit_line(&format!("let result = {}", call));
                self.emit_line("assert(result != nil || result == nil)");
            }
            TypeInfo::Function {
                param_types,
                return_type,
            } => {
                // Function-returning function: bind the closure, call it, verify result
                self.emit_line(&format!("let _closure = {}", call));
                // Generate arguments matching the closure's parameter types
                let closure_args: Vec<String> = param_types
                    .iter()
                    .map(|t| self.generate_test_value(t))
                    .collect();
                let closure_call = format!("_closure({})", closure_args.join(", "));
                // Exercise the returned closure by calling it
                self.emit_call_assertion(&closure_call, return_type);
            }
            _ => {
                // Non-void, non-optional return - just verify call succeeds
                // (non-optional types can't be compared to nil in Vole)
                self.emit_line(&format!("let _ = {}", call));
                self.emit_line("assert(true)");
            }
        }
    }

    /// Emit a test for a class.
    fn emit_class_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            // Skip classes with type parameters (generics) - too complex to test simply
            if !info.type_params.is_empty() {
                return;
            }

            self.emit_line(&format!("test \"{} construction\" {{", symbol.name));
            self.indent += 1;

            // Generate field values for construction
            let field_values = self.generate_class_field_values(&info.fields);
            self.emit_line(&format!(
                "let instance = {} {{ {} }}",
                symbol.name, field_values
            ));
            // Construction succeeded if we get here
            // (non-optional class instances can't be compared to nil in Vole)
            self.emit_line("assert(true)");

            // Test each method that doesn't have type parameters
            for method in &info.methods {
                let args = self.generate_test_args(&method.params);
                match &method.return_type {
                    TypeInfo::Void => {
                        self.emit_line(&format!("instance.{}({})", method.name, args));
                    }
                    _ => {
                        self.emit_line(&format!(
                            "let _{}_result = instance.{}({})",
                            method.name, method.name, args
                        ));
                    }
                }
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Emit a test for a struct (construction and field access).
    fn emit_struct_test(&mut self, symbol: &Symbol) {
        if let SymbolKind::Struct(ref info) = symbol.kind {
            self.emit_line(&format!("test \"{} construction\" {{", symbol.name));
            self.indent += 1;

            // Generate field values for construction
            let field_values = self.generate_struct_field_values(&info.fields);
            self.emit_line(&format!(
                "let instance = {} {{ {} }}",
                symbol.name, field_values
            ));
            // Construction succeeded if we get here
            self.emit_line("assert(true)");

            // Test field access for each field
            for field in &info.fields {
                self.emit_line(&format!(
                    "let _{}_val = instance.{}",
                    field.name, field.name
                ));
            }

            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    /// Generate test arguments for function/method parameters.
    fn generate_test_args(&mut self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| self.generate_test_value(&p.param_type))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate a test value for a given type.
    fn generate_test_value(&mut self, ty: &TypeInfo) -> String {
        match ty {
            TypeInfo::Primitive(prim) => self.generate_primitive_test_value(*prim),
            TypeInfo::Optional(inner) => {
                // Generate a value of the inner type rather than nil,
                // so the value carries type information. This is important
                // when the optional is nested inside a container (e.g., [i64?])
                // where [nil] would be ambiguous.
                self.generate_test_value(inner)
            }
            TypeInfo::Array(elem) => {
                // Minimum 2 elements: method bodies index arrays at 0..=1,
                // so arrays must always have at least 2 elements to prevent OOB panics.
                let elem_val1 = self.generate_test_value(elem);
                let elem_val2 = self.generate_test_value(elem);
                format!("[{}, {}]", elem_val1, elem_val2)
            }
            TypeInfo::Tuple(elems) => {
                let values: Vec<String> =
                    elems.iter().map(|t| self.generate_test_value(t)).collect();
                format!("[{}]", values.join(", "))
            }
            TypeInfo::FixedArray(elem, size) => {
                // Generate repeat literal for fixed array
                let elem_val = self.generate_test_value(elem);
                format!("[{}; {}]", elem_val, size)
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                // For union types, generate a value for the first variant
                if let Some(first) = variants.first() {
                    self.generate_test_value(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Class(mod_id, sym_id) => {
                // For class types, construct an instance
                if let Some(symbol) = self.table.get_symbol(*mod_id, *sym_id) {
                    if let SymbolKind::Class(ref class_info) = symbol.kind {
                        if class_info.type_params.is_empty() {
                            let fields = self.generate_class_field_values(&class_info.fields);
                            return format!("{} {{ {} }}", symbol.name, fields);
                        }
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Struct(mod_id, sym_id) => {
                // For struct types, construct an instance
                if let Some(symbol) = self.table.get_symbol(*mod_id, *sym_id) {
                    if let SymbolKind::Struct(ref struct_info) = symbol.kind {
                        let fields = self.generate_struct_field_values(&struct_info.fields);
                        return format!("{} {{ {} }}", symbol.name, fields);
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Interface(mod_id, sym_id) => {
                // For interface types, find a class that implements it and construct one
                self.generate_interface_test_value(*mod_id, *sym_id)
            }
            TypeInfo::Function {
                param_types,
                return_type,
            } => {
                // Generate a lambda matching the function type
                let config = ExprConfig::default();
                let mut expr_gen = ExprGenerator::new(self.rng, &config);
                let table = self.table;
                let ctx = ExprContext::new(&[], &[], table);
                expr_gen.generate_lambda(param_types, return_type, &ctx, config.max_depth)
            }
            _ => "nil".to_string(),
        }
    }

    /// Generate a primitive test value.
    fn generate_primitive_test_value(&mut self, prim: PrimitiveType) -> String {
        match prim {
            PrimitiveType::I8 => {
                let val: i8 = self.rng.gen_range(1..50);
                format!("{}_i8", val)
            }
            PrimitiveType::I16 => {
                let val: i16 = self.rng.gen_range(1..100);
                format!("{}_i16", val)
            }
            PrimitiveType::I32 => {
                let val: i32 = self.rng.gen_range(1..50);
                format!("{}_i32", val)
            }
            PrimitiveType::I64 => {
                let val: i64 = self.rng.gen_range(1..100);
                format!("{}_i64", val)
            }
            PrimitiveType::I128 => {
                let val: i64 = self.rng.gen_range(1..1000);
                format!("{}_i128", val)
            }
            PrimitiveType::U8 => {
                let val: u8 = self.rng.gen_range(1..50);
                format!("{}_u8", val)
            }
            PrimitiveType::U16 => {
                let val: u16 = self.rng.gen_range(1..100);
                format!("{}_u16", val)
            }
            PrimitiveType::U32 => {
                let val: u32 = self.rng.gen_range(1..100);
                format!("{}_u32", val)
            }
            PrimitiveType::U64 => {
                let val: u64 = self.rng.gen_range(1..1000);
                format!("{}_u64", val)
            }
            PrimitiveType::F32 => {
                let val: f32 = self.rng.gen_range(1.0_f32..50.0_f32);
                format!("{:.2}_f32", val)
            }
            PrimitiveType::F64 => {
                let val: f64 = self.rng.gen_range(1.0..50.0);
                format!("{:.2}_f64", val)
            }
            PrimitiveType::Bool => "true".to_string(),
            PrimitiveType::String => {
                let id = self.rng.gen_range(0..100);
                format!("\"test{}\"", id)
            }
            PrimitiveType::Nil => "nil".to_string(),
        }
    }

    /// Generate a test value for an interface type by finding an implementing class.
    fn generate_interface_test_value(
        &mut self,
        iface_mod: ModuleId,
        iface_sym: SymbolId,
    ) -> String {
        // Find a non-generic class in the same module that implements this interface
        let module = match self.table.get_module(iface_mod) {
            Some(m) => m,
            None => return "nil".to_string(),
        };

        for sym in module.classes() {
            if let SymbolKind::Class(ref info) = sym.kind {
                if info.type_params.is_empty()
                    && info
                        .implements
                        .iter()
                        .any(|&(m, s)| m == iface_mod && s == iface_sym)
                {
                    let fields = self.generate_class_field_values(&info.fields);
                    return format!("{} {{ {} }}", sym.name, fields);
                }
            }
        }
        "nil".to_string()
    }

    /// Generate field values for class construction.
    fn generate_class_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate field values for struct construction.
    fn generate_struct_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_imports(&mut self) {
        for import in &self.module.imports {
            if let Some(target) = self.table.get_module(import.target_module) {
                // Check if we should use destructured imports (based on config probability)
                let use_destructured = self.config.destructured_import_probability > 0.0
                    && self
                        .rng
                        .gen_bool(self.config.destructured_import_probability);

                if use_destructured {
                    // Collect importable symbols: non-generic functions, classes, and structs
                    let importable_names = self.collect_importable_names(target);

                    if !importable_names.is_empty() {
                        // Pick 1-3 names to import (or all if fewer available)
                        let count = self.rng.gen_range(1..=importable_names.len().min(3));
                        let selected: Vec<_> = importable_names.into_iter().take(count).collect();
                        let names_str = selected.join(", ");
                        // Vole uses: let { name1, name2 } = import "path"
                        self.emit_line(&format!(
                            "let {{ {} }} = import \"./{}.vole\"",
                            names_str, target.name
                        ));
                        continue;
                    }
                }

                // Fall back to regular import: let alias = import "path"
                self.emit_line(&format!(
                    "let {} = import \"./{}.vole\"",
                    import.alias, target.name
                ));
            }
        }
        if !self.module.imports.is_empty() {
            self.emit_line("");
        }
    }

    /// Collect names of symbols that can be imported via destructuring.
    /// Returns non-generic functions, non-generic classes, and structs.
    fn collect_importable_names(&self, module: &ModuleSymbols) -> Vec<String> {
        let mut names = Vec::new();

        // Non-generic functions (generic functions cannot be imported yet)
        for symbol in module.functions() {
            if let SymbolKind::Function(ref info) = symbol.kind {
                if info.type_params.is_empty() {
                    names.push(symbol.name.clone());
                }
            }
        }

        // Non-generic classes
        for symbol in module.classes() {
            if let SymbolKind::Class(ref info) = symbol.kind {
                if info.type_params.is_empty() {
                    names.push(symbol.name.clone());
                }
            }
        }

        // Structs (structs don't have generics)
        for symbol in module.structs() {
            names.push(symbol.name.clone());
        }

        names
    }

    fn emit_global(&mut self, symbol: &Symbol) {
        if let SymbolKind::Global(ref info) = symbol.kind {
            let mutability = if info.is_mutable { "let mut" } else { "let" };
            // Non-mutable globals are exported and must use constant expressions
            // (single literal tokens, no unary negation) so the module analyzer
            // can evaluate them at compile time.
            let value = if info.is_mutable {
                self.literal_for_type(&info.value_type)
            } else {
                self.constant_literal_for_type(&info.value_type)
            };
            self.emit_line(&format!(
                "{} {}: {} = {}",
                mutability,
                symbol.name,
                info.value_type.to_vole_syntax(self.table),
                value
            ));
        }
    }

    fn emit_interface(&mut self, symbol: &Symbol) {
        if let SymbolKind::Interface(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_interface_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            for method in &info.methods {
                self.emit_method_signature(method);
            }
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_interface_header(&self, name: &str, info: &InterfaceInfo) -> String {
        let mut header = String::from("interface ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        // Add extends clause
        if !info.extends.is_empty() {
            let parent_names: Vec<String> = info
                .extends
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !parent_names.is_empty() {
                header.push_str(" extends ");
                header.push_str(&parent_names.join(", "));
            }
        }

        header
    }

    fn emit_error(&mut self, symbol: &Symbol) {
        if let SymbolKind::Error(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("error {} {{}}", symbol.name));
            } else {
                let fields: Vec<String> = info
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.field_type.to_vole_syntax(self.table)))
                    .collect();
                self.emit_line(&format!(
                    "error {} {{ {} }}",
                    symbol.name,
                    fields.join(", ")
                ));
            }
        }
    }

    fn emit_struct(&mut self, symbol: &Symbol) {
        if let SymbolKind::Struct(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() && info.static_methods.is_empty() {
                self.emit_line(&format!("struct {} {{}}", symbol.name));
            } else {
                self.emit_line(&format!("struct {} {{", symbol.name));
                self.indent += 1;
                for field in &info.fields {
                    self.emit_field(field);
                }

                // Emit statics block inside the struct body
                if !info.static_methods.is_empty() {
                    self.emit_line("");
                    self.emit_line("statics {");
                    self.indent += 1;
                    for static_method in &info.static_methods {
                        self.emit_static_method(static_method, &symbol.name, &info.fields);
                    }
                    self.indent -= 1;
                    self.emit_line("}");
                }

                self.indent -= 1;
                self.emit_line("}");
            }
        }
    }

    fn emit_class(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            self.emit_line("");
            self.emit_class_header(symbol, info);
            self.indent += 1;

            // Emit fields
            for field in &info.fields {
                self.emit_field(field);
            }

            // Emit methods (track current class to prevent mutual recursion)
            self.current_class = Some((self.module.id, symbol.id));
            for method in &info.methods {
                self.emit_method(method);
            }
            self.current_class = None;

            // Emit statics block inside the class body (not in a separate
            // implement block) — the codegen expects statics blocks to live
            // inside the class declaration where the TypeDefId is available.
            if !info.static_methods.is_empty() {
                self.emit_line("");
                self.emit_line("statics {");
                self.indent += 1;
                for static_method in &info.static_methods {
                    self.emit_static_method(static_method, &symbol.name, &info.fields);
                }
                self.indent -= 1;
                self.emit_line("}");
            }

            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_class_header(&mut self, symbol: &Symbol, info: &ClassInfo) {
        let mut header = String::from("class ");
        header.push_str(&symbol.name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        if !info.implements.is_empty() {
            let iface_names: Vec<String> = info
                .implements
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !iface_names.is_empty() {
                header.push_str(" implements ");
                header.push_str(&iface_names.join(", "));
            }
        }

        header.push_str(" {");
        self.emit_line(&header);
    }

    fn emit_field(&mut self, field: &FieldInfo) {
        self.emit_line(&format!(
            "{}: {},",
            field.name,
            field.field_type.to_vole_syntax(self.table)
        ));
    }

    fn emit_method_signature(&mut self, method: &MethodInfo) {
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!("func {}({}){}", method.name, params, return_type));
    }

    fn emit_method(&mut self, method: &MethodInfo) {
        self.emit_line("");
        let params = self.format_params(&method.params);
        let return_type_str = self.format_return_type(&method.return_type);

        // Check if this method can use expression-body syntax
        if self.can_use_expr_body(&method.return_type)
            && self.rng.gen_bool(self.config.expr_body_probability)
        {
            // Expression-body syntax: func name(...) -> T => expr
            let expr = self.generate_return_expr(&method.return_type, &method.params);
            self.emit_line(&format!(
                "func {}({}){} => {}",
                method.name, params, return_type_str, expr
            ));
        } else {
            // Block-body syntax
            self.emit_line(&format!(
                "func {}({}){} {{",
                method.name, params, return_type_str
            ));
            self.indent += 1;
            // Methods don't have their own type params (they use class type params),
            // but for now we pass empty to avoid complications with class type params.
            self.emit_function_body(
                &method.return_type,
                &method.params,
                Some(&method.name),
                &[],
                None,
            );
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_function(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_function_header(&symbol.name, info);

            // Check if this function can use expression-body syntax
            if self.can_use_expr_body(&info.return_type)
                && self.rng.gen_bool(self.config.expr_body_probability)
            {
                // Expression-body syntax: func name(...) -> T => expr
                let expr = self.generate_return_expr(&info.return_type, &info.params);
                self.emit_line(&format!("{} => {}", header, expr));
            } else {
                // Block-body syntax: func name(...) -> T { ... }
                self.emit_line(&format!("{} {{", header));
                self.indent += 1;
                self.emit_function_body(
                    &info.return_type,
                    &info.params,
                    Some(&symbol.name),
                    &info.type_params,
                    Some(symbol.id),
                );
                self.indent -= 1;
                self.emit_line("}");
            }
        }
    }

    fn format_function_header(&self, name: &str, info: &FunctionInfo) -> String {
        let mut header = String::from("func ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        header.push('(');
        header.push_str(&self.format_params(&info.params));
        header.push(')');
        header.push_str(&self.format_return_type(&info.return_type));

        header
    }

    /// Check if a return type is eligible for expression-body syntax.
    ///
    /// Expression-bodied functions work for:
    /// - Primitive types
    /// - Optional types
    /// - Array types
    /// - Tuple types
    /// - Fixed-size array types
    /// - Class/struct types
    ///
    /// Not eligible:
    /// - Void (no return value to express)
    /// - Iterator (requires yield)
    /// - Never (requires panic/unreachable)
    /// - TypeParam (no way to generate a valid literal for a generic type)
    /// - Fallible (expression must itself be fallible, not just the success type)
    fn can_use_expr_body(&self, return_type: &TypeInfo) -> bool {
        !matches!(
            return_type,
            TypeInfo::Void
                | TypeInfo::Iterator(_)
                | TypeInfo::Never
                | TypeInfo::TypeParam(_)
                | TypeInfo::Fallible { .. }
        )
    }

    /// Generate a simple expression for the return type.
    ///
    /// Used for expression-bodied functions where the entire body is a single
    /// expression. Uses `generate_simple` to avoid complex multi-line expressions
    /// that would break parsing when formatted across multiple lines.
    fn generate_return_expr(&mut self, return_type: &TypeInfo, params: &[ParamInfo]) -> String {
        // For fallible functions, use the success type for expression generation
        let effective_return_type = return_type.success_type().clone();

        let expr_ctx = ExprContext::new(params, &[], self.table);
        let mut expr_gen = ExprGenerator::new(self.rng, &self.config.stmt_config.expr_config);
        expr_gen.generate_simple(&effective_return_type, &expr_ctx)
    }

    fn emit_function_body(
        &mut self,
        return_type: &TypeInfo,
        params: &[ParamInfo],
        function_name: Option<&str>,
        type_params: &[TypeParam],
        function_sym_id: Option<SymbolId>,
    ) {
        // Generator functions (returning Iterator<T>) get a special body with yield
        if let TypeInfo::Iterator(elem_type) = return_type {
            self.emit_generator_body(elem_type, params);
            return;
        }

        // Never-returning functions (diverging) just call panic or unreachable
        if matches!(return_type, TypeInfo::Never) {
            self.emit_never_body();
            return;
        }

        let mut stmt_ctx = StmtContext::with_module(params, self.table, self.module.id);

        // Track the current function name to prevent self-recursion
        stmt_ctx.current_function_name = function_name.map(String::from);

        // Track the current free function's symbol ID to prevent mutual recursion.
        // When set, only free functions with a lower symbol ID may be called.
        stmt_ctx.current_function_sym_id = function_sym_id;

        // Track the current class to prevent mutual recursion between methods
        stmt_ctx.current_class_sym_id = self.current_class;

        // Pass type parameters for generic functions (enables interface method calls)
        stmt_ctx.type_params = type_params.to_vec();

        // If this function has a fallible return type, mark the context as fallible
        if let TypeInfo::Fallible { error, .. } = return_type {
            stmt_ctx.is_fallible = true;
            // Collect fallible functions in this module for try expressions
            stmt_ctx.fallible_error_type = Some(error.as_ref().clone());
        }

        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let lines = stmt_gen.generate_body(return_type, &mut stmt_ctx, 0);

        for line in lines {
            self.emit_line(&line);
        }
    }

    /// Emit a generator function body with a while loop and yield statements.
    ///
    /// Generates a simple bounded loop pattern:
    /// ```vole
    /// let mut i = 0
    /// while i < N {
    ///     yield <expr of elem_type>
    ///     i = i + 1
    /// }
    /// ```
    fn emit_generator_body(&mut self, elem_type: &TypeInfo, params: &[ParamInfo]) {
        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        let stmt_ctx = StmtContext::with_module(params, self.table, self.module.id);
        let lines = stmt_gen.generate_generator_body(elem_type, &stmt_ctx);

        for line in lines {
            self.emit_line(&line);
        }
    }

    /// Emit a never-returning function body.
    ///
    /// Never-returning functions diverge by calling `panic()` or using `unreachable`.
    /// Uses `return` to satisfy the compiler's return analysis.
    /// Randomly chooses between:
    /// - `return panic("message")`
    /// - `return unreachable`
    fn emit_never_body(&mut self) {
        // Randomly choose between panic and unreachable
        if self.rng.gen_bool(0.5) {
            let msg_id = self.rng.gen_range(0..100);
            self.emit_line(&format!("return panic(\"diverge{}\")", msg_id));
        } else {
            self.emit_line("return unreachable");
        }
    }

    /// Generate a random iterator method chain for a generator call.
    ///
    /// The element type determines which terminal methods are valid:
    /// - `.sum()` is only valid for numeric element types
    /// - `.reduce()` is valid for numeric and string types (not bool)
    /// - `.count()` is always valid and returns i64
    /// - All other chains end with `.collect()`
    fn generate_iterator_chain(&mut self, elem_type: &TypeInfo) -> String {
        let is_numeric = matches!(
            elem_type,
            TypeInfo::Primitive(PrimitiveType::I64)
                | TypeInfo::Primitive(PrimitiveType::I32)
                | TypeInfo::Primitive(PrimitiveType::F64)
        );
        let is_reducible = matches!(
            elem_type,
            TypeInfo::Primitive(PrimitiveType::I64)
                | TypeInfo::Primitive(PrimitiveType::I32)
                | TypeInfo::Primitive(PrimitiveType::F64)
                | TypeInfo::Primitive(PrimitiveType::String)
        );

        let is_not_bool = !matches!(elem_type, TypeInfo::Primitive(PrimitiveType::Bool));

        // Choose a chain pattern
        let pattern = self.rng.gen_range(0..24);
        match pattern {
            0..=3 => {
                // Plain .collect()
                ".collect()".to_string()
            }
            4 => {
                // .take(n).collect()
                let n = self.rng.gen_range(1..=3);
                format!(".take({}).collect()", n)
            }
            5 => {
                // .skip(n).collect()
                let n = self.rng.gen_range(1..=2);
                format!(".skip({}).collect()", n)
            }
            6 => {
                // .count()
                ".count()".to_string()
            }
            7 if is_numeric => {
                // .sum() - only for numeric types
                ".sum()".to_string()
            }
            8 => {
                // .filter(predicate).collect()
                let pred = self.generate_filter_predicate(elem_type);
                format!(".filter({}).collect()", pred)
            }
            9 => {
                // .map(transform).collect()
                let mapper = self.generate_map_lambda(elem_type);
                format!(".map({}).collect()", mapper)
            }
            10..=11 if is_reducible => {
                // .reduce(init, (acc, el) => expr) - accumulator closure
                let (init, body) = self.generate_reduce_lambda(elem_type);
                format!(".reduce({}, (acc, el) => {})", init, body)
            }
            12 if is_numeric => {
                // .sorted().collect() - sort then collect (numeric only)
                ".sorted().collect()".to_string()
            }
            13 if is_numeric => {
                // .sorted().sum() - sort then sum (numeric only)
                ".sorted().sum()".to_string()
            }
            14 if is_numeric => {
                // .filter(...).sorted().collect() - filter then sort (numeric only)
                let pred = self.generate_filter_predicate(elem_type);
                format!(".filter({}).sorted().collect()", pred)
            }
            15 if is_numeric => {
                // .sorted().take(N).collect() - sort then take (numeric only)
                let n = self.rng.gen_range(1..=3);
                format!(".sorted().take({}).collect()", n)
            }
            16 => {
                // .enumerate().count() — always valid, any element type
                ".enumerate().count()".to_string()
            }
            17 if is_numeric => {
                // .enumerate().filter((e) => e[1] > 0).count() — numeric elements only
                let pred = match elem_type {
                    TypeInfo::Primitive(PrimitiveType::I64) => "(e) => e[1] > 0_i64",
                    TypeInfo::Primitive(PrimitiveType::I32) => "(e) => e[1] > 0_i32",
                    TypeInfo::Primitive(PrimitiveType::F64) => "(e) => e[1] > 0.0_f64",
                    _ => "(e) => true",
                };
                format!(".enumerate().filter({}).count()", pred)
            }
            18 => {
                // .reverse().collect() — always valid, any element type
                ".reverse().collect()".to_string()
            }
            19 if is_numeric => {
                // .reverse().sum() — numeric only
                ".reverse().sum()".to_string()
            }
            20 if is_not_bool => {
                // .unique().collect() — not valid for bool
                ".unique().collect()".to_string()
            }
            21 if is_not_bool => {
                // .unique().count() — not valid for bool
                ".unique().count()".to_string()
            }
            22 => {
                // .first() — returns T?, always valid for any element type
                ".first()".to_string()
            }
            23 => {
                // .last() — returns T?, always valid for any element type
                ".last()".to_string()
            }
            _ => {
                // Fallback to .collect()
                ".collect()".to_string()
            }
        }
    }

    /// Generate a filter predicate lambda for a given element type.
    fn generate_filter_predicate(&mut self, elem_type: &TypeInfo) -> String {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x > 0_i64".to_string(),
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x > 0_i32".to_string(),
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x > 0.0_f64".to_string(),
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => x".to_string(),
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => true".to_string(),
            _ => "(x) => true".to_string(),
        }
    }

    /// Generate a map transformation lambda for a given element type.
    fn generate_map_lambda(&mut self, elem_type: &TypeInfo) -> String {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x + 1_i64".to_string(),
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x + 1_i32".to_string(),
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x + 1.0_f64".to_string(),
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => !x".to_string(),
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => x".to_string(),
            _ => "(x) => x".to_string(),
        }
    }

    /// Generate a reduce initial value and accumulator body for a given element type.
    ///
    /// Returns `(init_expr, closure_body)`. The closure params are always `acc` and `el`.
    /// Only valid for numeric and string types (not bool).
    fn generate_reduce_lambda(&self, elem_type: &TypeInfo) -> (&'static str, &'static str) {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => ("0", "acc + el"),
            TypeInfo::Primitive(PrimitiveType::I32) => ("0_i32", "acc + el"),
            TypeInfo::Primitive(PrimitiveType::F64) => ("0.0", "acc + el"),
            TypeInfo::Primitive(PrimitiveType::String) => ("\"\"", "acc + el + \" \""),
            _ => ("0", "acc + el"),
        }
    }

    fn format_params(&self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.param_type.to_vole_syntax(self.table)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn format_return_type(&self, return_type: &TypeInfo) -> String {
        match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        }
    }

    fn format_type_params(&self, type_params: &[TypeParam]) -> String {
        type_params
            .iter()
            .map(|tp| {
                if tp.constraints.is_empty() {
                    tp.name.clone()
                } else {
                    let constraint_names: Vec<String> = tp
                        .constraints
                        .iter()
                        .filter_map(|(mod_id, sym_id)| {
                            self.table
                                .get_symbol(*mod_id, *sym_id)
                                .map(|s| s.name.clone())
                        })
                        .collect();
                    format!("{}: {}", tp.name, constraint_names.join(" + "))
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_implement_block(&mut self, symbol: &Symbol) {
        if let SymbolKind::ImplementBlock(ref info) = symbol.kind {
            self.emit_implement_block_inner(info);
        }
    }

    fn emit_implement_block_inner(&mut self, info: &ImplementBlockInfo) {
        let target_name = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownType".to_string());

        // Get target class fields for Self construction (used in standalone implement blocks)
        let target_fields = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .and_then(|s| {
                if let SymbolKind::Class(ref class_info) = s.kind {
                    Some(class_info.fields.clone())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        self.emit_line("");

        // Track the target class to prevent mutual recursion in generated bodies
        self.current_class = Some(info.target_type);

        if let Some((iface_mod_id, iface_sym_id)) = info.interface {
            // Interface implementation: implement Interface for Class
            let iface_name = self
                .table
                .get_symbol(iface_mod_id, iface_sym_id)
                .map(|s| s.name.clone())
                .unwrap_or_else(|| "UnknownInterface".to_string());

            self.emit_line(&format!("implement {} for {} {{", iface_name, target_name));
            self.indent += 1;

            for method in &info.methods {
                self.emit_method(method);
            }
        } else {
            // Standalone implement block: implement Class { ... }
            // Methods can use Self as return type
            self.emit_line(&format!("implement {} {{", target_name));
            self.indent += 1;

            for method in &info.methods {
                self.emit_self_method(method, &target_name, &target_fields);
            }
        }

        self.current_class = None;

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Emit a static method inside a statics block.
    fn emit_static_method(
        &mut self,
        static_method: &StaticMethodInfo,
        class_name: &str,
        class_fields: &[FieldInfo],
    ) {
        self.emit_line("");
        let params = self.format_params(&static_method.params);

        // Static methods return the class type (using ClassName, not Self)
        self.emit_line(&format!(
            "func {}({}) -> {} {{",
            static_method.name, params, class_name
        ));
        self.indent += 1;

        // Generate a simple body that returns the constructed class
        self.emit_static_method_body(&static_method.params, class_name, class_fields);

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Emit the body of a static method that constructs and returns the class.
    fn emit_static_method_body(
        &mut self,
        params: &[ParamInfo],
        class_name: &str,
        class_fields: &[FieldInfo],
    ) {
        // Generate field values for construction
        let field_values = self.generate_static_field_values(class_fields, params);

        // Just return the constructed instance
        self.emit_line(&format!("return {} {{ {} }}", class_name, field_values));
    }

    /// Generate field values for static method construction.
    ///
    /// Uses parameters when their type matches a field type, otherwise
    /// generates a literal value.
    fn generate_static_field_values(
        &mut self,
        fields: &[FieldInfo],
        params: &[ParamInfo],
    ) -> String {
        fields
            .iter()
            .map(|f| {
                // Try to use a parameter with matching type
                let value = params
                    .iter()
                    .find(|p| p.param_type == f.field_type)
                    .map(|p| p.name.clone())
                    .unwrap_or_else(|| self.generate_test_value(&f.field_type));
                format!("{}: {}", f.name, value)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Emit a method that uses Self as return type in a standalone implement block.
    fn emit_self_method(
        &mut self,
        method: &MethodInfo,
        class_name: &str,
        target_fields: &[FieldInfo],
    ) {
        self.emit_line("");
        let params = self.format_params(&method.params);

        // Use Self as return type
        self.emit_line(&format!("func {}({}) -> Self {{", method.name, params));
        self.indent += 1;

        // Generate the body that returns Self
        self.emit_self_returning_body(&method.name, &method.params, class_name, target_fields);

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Emit a function body that returns the implementing class type (for Self return).
    fn emit_self_returning_body(
        &mut self,
        method_name: &str,
        params: &[ParamInfo],
        class_name: &str,
        target_fields: &[FieldInfo],
    ) {
        // First, generate the field values for construction (uses self.rng)
        let field_values = self.generate_self_field_values(target_fields);

        // Now generate the statements using StmtGenerator
        let mut stmt_ctx = StmtContext::with_module(params, self.table, self.module.id);
        // Set the current method name so that method chain generation can
        // exclude this method, preventing infinite recursion (e.g. selfMethod6
        // chaining back to selfMethod6).
        stmt_ctx.current_function_name = Some(method_name.to_string());
        // Track the current class to prevent mutual recursion between methods
        stmt_ctx.current_class_sym_id = self.current_class;
        let mut stmt_gen = StmtGenerator::new(self.rng, &self.config.stmt_config);
        stmt_gen.set_indent(self.indent);

        // Generate a few statements (but not as many as full body since we handle return)
        // Collect all lines first, then emit to avoid borrow issues
        let stmt_count = 1 + (stmt_gen.gen_range_usize(0..2)); // 1-2 statements
        let mut lines = Vec::with_capacity(stmt_count + 1);
        for _ in 0..stmt_count {
            let stmt = stmt_gen.generate_statement(&mut stmt_ctx, 0);
            lines.push(stmt);
        }

        // Add the return statement using the class name (not Self)
        lines.push(format!("return {} {{ {} }}", class_name, field_values));

        // Now emit all the lines
        for line in lines {
            self.emit_line(&line);
        }
    }

    /// Generate field values for class construction.
    fn generate_self_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.generate_test_value(&f.field_type)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.literal_for_primitive(*p),
            TypeInfo::Optional(inner) => {
                // Generate a typed value rather than nil so the literal carries
                // type information when nested inside containers like [T?].
                drop(expr_gen);
                self.literal_for_type(inner)
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                // For union types, generate a literal for the first variant
                if let Some(first) = variants.first() {
                    drop(expr_gen);
                    self.literal_for_type(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Array(elem) => {
                drop(expr_gen);
                // Minimum 2 elements: method bodies index arrays at 0..=1,
                // so arrays must always have at least 2 elements to prevent OOB panics.
                let elem_val1 = self.literal_for_type(elem);
                let elem_val2 = self.literal_for_type(elem);
                format!("[{}, {}]", elem_val1, elem_val2)
            }
            TypeInfo::Tuple(elems) => {
                drop(expr_gen);
                let values: Vec<String> = elems.iter().map(|t| self.literal_for_type(t)).collect();
                format!("[{}]", values.join(", "))
            }
            TypeInfo::FixedArray(elem, size) => {
                drop(expr_gen);
                let elem_val = self.literal_for_type(elem);
                format!("[{}; {}]", elem_val, size)
            }
            _ => "nil".to_string(),
        }
    }

    /// Generate a constant-safe literal for a type. Only produces values that
    /// the module analyzer recognizes as compile-time constants (no unary
    /// negation, no complex expressions).
    fn constant_literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        let config = ExprConfig::default();
        let mut expr_gen = ExprGenerator::new(self.rng, &config);

        match type_info {
            TypeInfo::Primitive(p) => expr_gen.constant_literal_for_primitive(*p),
            TypeInfo::Optional(inner) => {
                // Generate a typed constant rather than nil so the literal carries
                // type information when nested inside containers like [T?].
                drop(expr_gen);
                self.constant_literal_for_type(inner)
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                if let Some(first) = variants.first() {
                    drop(expr_gen);
                    self.constant_literal_for_type(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Array(elem) => {
                drop(expr_gen);
                // Minimum 2 elements: method bodies index arrays at 0..=1,
                // so arrays must always have at least 2 elements to prevent OOB panics.
                let elem_val1 = self.constant_literal_for_type(elem);
                let elem_val2 = self.constant_literal_for_type(elem);
                format!("[{}, {}]", elem_val1, elem_val2)
            }
            TypeInfo::FixedArray(elem, size) => {
                drop(expr_gen);
                let elem_val = self.constant_literal_for_type(elem);
                format!("[{}; {}]", elem_val, size)
            }
            _ => "nil".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        // Handle multi-line statements (e.g., if-else-if chains)
        // by indenting each line
        for part in line.lines() {
            writeln!(self.output, "{}{}", indent_str, part).unwrap();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use crate::symbols::ModuleId;
    use rand::SeedableRng;

    #[test]
    fn emit_module_produces_code() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("// Module:"));
        assert!(code.contains("func"));
    }

    #[test]
    fn emit_module_contains_class() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("class Class"));
    }

    #[test]
    fn emit_module_contains_interface() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (1, 1),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("interface IFace"));
    }

    #[test]
    fn emit_is_deterministic() {
        let plan_config = PlanConfig::default();
        let emit_config = EmitConfig::default();

        let mut rng1 = rand::rngs::StdRng::seed_from_u64(12345);
        let table1 = plan(&mut rng1, &plan_config);
        let module1 = table1.get_module(ModuleId(0)).unwrap();
        let code1 = emit_module(&mut rng1, &table1, module1, &emit_config);

        let mut rng2 = rand::rngs::StdRng::seed_from_u64(12345);
        let table2 = plan(&mut rng2, &plan_config);
        let module2 = table2.get_module(ModuleId(0)).unwrap();
        let code2 = emit_module(&mut rng2, &table2, module2, &emit_config);

        assert_eq!(code1, code2);
    }

    #[test]
    fn emit_module_contains_tests_block() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain a tests block
        assert!(code.contains("tests \""));
        // Should contain test declarations
        assert!(code.contains("test \""));
        // Should contain assertions
        assert!(code.contains("assert("));
    }

    #[test]
    fn emit_module_tests_for_functions() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain function tests
        assert!(code.contains("test \"func"));
        assert!(code.contains("works\""));
    }

    #[test]
    fn emit_module_tests_for_classes() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain class construction test
        assert!(code.contains("construction\""));
        assert!(code.contains("let instance ="));
    }

    #[test]
    fn emit_module_contains_struct() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(
            code.contains("struct Struct"),
            "Expected struct declaration in output, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_module_tests_for_structs() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain struct construction test
        assert!(
            code.contains("construction\""),
            "Expected struct construction test, got:\n{}",
            code
        );
        assert!(
            code.contains("let instance ="),
            "Expected struct instance creation, got:\n{}",
            code
        );
    }

    #[test]
    fn generated_code_has_no_undefined_type_params() {
        use crate::profile::get_profile;
        use crate::symbols::{SymbolKind, TypeInfo};

        // Use the problematic seed that exposed the bug
        let profile = get_profile("full").unwrap();
        let seed = 1770226963014480876_u64;
        let mut rng = rand::rngs::StdRng::seed_from_u64(seed);

        let table = plan(&mut rng, &profile.plan);

        // Check at the symbol table level - this is the real source of truth
        for module in table.modules() {
            // Check classes
            for symbol in module.classes() {
                if let SymbolKind::Class(ref info) = symbol.kind {
                    let class_type_params: std::collections::HashSet<_> =
                        info.type_params.iter().map(|tp| &tp.name).collect();

                    // Check fields
                    for field in &info.fields {
                        if let TypeInfo::TypeParam(ref name) = field.field_type {
                            assert!(
                                class_type_params.contains(name),
                                "Class {} field {} uses undefined type param {}. Class type params: {:?}",
                                symbol.name,
                                field.name,
                                name,
                                class_type_params
                            );
                        }
                    }

                    // Check methods
                    for method in &info.methods {
                        for param in &method.params {
                            if let TypeInfo::TypeParam(ref name) = param.param_type {
                                assert!(
                                    class_type_params.contains(name),
                                    "Class {} method {} param {} uses undefined type param {}. Class type params: {:?}",
                                    symbol.name,
                                    method.name,
                                    param.name,
                                    name,
                                    class_type_params
                                );
                            }
                        }
                        if let TypeInfo::TypeParam(ref name) = method.return_type {
                            assert!(
                                class_type_params.contains(name),
                                "Class {} method {} return uses undefined type param {}. Class type params: {:?}",
                                symbol.name,
                                method.name,
                                name,
                                class_type_params
                            );
                        }
                    }
                }
            }

            // Check functions
            for symbol in module.functions() {
                if let SymbolKind::Function(ref info) = symbol.kind {
                    let func_type_params: std::collections::HashSet<_> =
                        info.type_params.iter().map(|tp| &tp.name).collect();

                    for param in &info.params {
                        if let TypeInfo::TypeParam(ref name) = param.param_type {
                            assert!(
                                func_type_params.contains(name),
                                "Function {} param {} uses undefined type param {}. Function type params: {:?}",
                                symbol.name,
                                param.name,
                                name,
                                func_type_params
                            );
                        }
                    }
                    if let TypeInfo::TypeParam(ref name) = info.return_type {
                        assert!(
                            func_type_params.contains(name),
                            "Function {} return uses undefined type param {}. Function type params: {:?}",
                            symbol.name,
                            name,
                            func_type_params
                        );
                    }
                }
            }
        }
    }

    #[test]
    fn emit_destructured_imports_when_probability_is_one() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 2,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2), // At least some functions to import
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (1, 1), // At least one struct to import
            type_params_per_function: (0, 0), // Non-generic so they can be imported
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();

        // Enable destructured imports at 100%
        let emit_config = EmitConfig {
            destructured_import_probability: 1.0,
            ..Default::default()
        };

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should use destructured import syntax: let { name } = import "path"
        assert!(
            code.contains("let {") && code.contains("} = import"),
            "Expected destructured import syntax, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_regular_imports_when_probability_is_zero() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 2,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (1, 1),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();

        // Disable destructured imports
        let emit_config = EmitConfig {
            destructured_import_probability: 0.0,
            ..Default::default()
        };

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should NOT use destructured import syntax.
        // Check for `} = import` which is the destructured import pattern
        // (`let { Name } = import "path"`), NOT `let {` which also matches
        // struct destructuring (`let { field: var } = expr`).
        assert!(
            !code.contains("} = import"),
            "Expected regular import syntax (no destructuring), got:\n{}",
            code
        );

        // Should have regular import: let name = import "path"
        assert!(
            code.contains("let mod_l") && code.contains(" = import"),
            "Expected regular import syntax, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_expression_bodied_functions_when_probability_is_one() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (3, 3), // Non-void returning functions
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();

        // Enable expression-bodied functions at 100%
        let emit_config = EmitConfig {
            expr_body_probability: 1.0,
            ..Default::default()
        };

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain expression-bodied function syntax: func name(...) -> T => expr
        // The pattern is "-> T => " where T is the return type
        assert!(
            code.contains(" => ")
                && code
                    .lines()
                    .any(|l| l.contains("func ") && l.contains(" => ")),
            "Expected expression-bodied function syntax (=> expr), got:\n{}",
            code
        );
    }

    #[test]
    fn emit_block_bodied_functions_when_probability_is_zero() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (3, 3),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();

        // Disable expression-bodied functions
        let emit_config = EmitConfig {
            expr_body_probability: 0.0,
            ..Default::default()
        };

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Count lines with "func" that also have "=> " (expression-bodied)
        // vs lines with "func" that have " {" (block-bodied)
        let func_lines: Vec<&str> = code
            .lines()
            .filter(|l| l.contains("func ") && !l.trim().starts_with("//"))
            .collect();

        // With 0.0 probability, no functions should use expression-body syntax
        for line in &func_lines {
            // Check this isn't a lambda (which uses => but isn't an expression-bodied function)
            if !line.contains("(") || !line.contains("->") {
                continue;
            }
            // Skip lambdas by checking if this is at function declaration level
            if line.trim().starts_with("func ") {
                assert!(
                    !line.contains(") => "),
                    "Expected block-bodied function (no => expr), got: {}",
                    line
                );
            }
        }
    }

    #[test]
    fn expression_bodied_methods_work() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (0, 0),
            methods_per_class: (2, 2),
            type_params_per_class: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();

        // Enable expression-bodied functions at 100%
        let emit_config = EmitConfig {
            expr_body_probability: 1.0,
            ..Default::default()
        };

        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain expression-bodied method syntax in class methods
        // Methods can return void, so not all will be expression-bodied
        // Just verify the code is valid and contains class + method declarations
        assert!(
            code.contains("class "),
            "Expected class declaration, got:\n{}",
            code
        );
        assert!(
            code.contains("func method"),
            "Expected method declaration, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_statics_block() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            structs_per_module: (0, 0),
            type_params_per_class: (0, 0),
            fields_per_class: (2, 2),
            methods_per_class: (0, 0),
            static_methods_per_class: (2, 2), // Force 2 static methods
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);

        // Verify the class has static methods in the symbol table
        let module = table.get_module(ModuleId(0)).unwrap();
        let has_statics = module.classes().any(|s| {
            if let SymbolKind::Class(ref info) = s.kind {
                !info.static_methods.is_empty()
            } else {
                false
            }
        });
        assert!(
            has_statics,
            "Expected class to have static methods in symbol table"
        );

        // Now emit the module and check the output
        let emit_config = EmitConfig::default();
        let code = emit_module(&mut rng, &table, module, &emit_config);

        // Should contain statics block
        assert!(
            code.contains("statics {"),
            "Expected statics block in output:\n{}",
            code
        );
        assert!(
            code.contains("func static"),
            "Expected static method in output:\n{}",
            code
        );
    }
}
