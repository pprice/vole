//! Fill phase: Generate Vole source code from the symbol table.
//!
//! The emitter converts the planned declarations into actual Vole source code,
//! generating function bodies and expressions that reference symbols from the
//! complete symbol table.

use rand::Rng;
use std::fmt::Write as _;
use std::io;
use std::path::Path;

use crate::symbols::{
    ClassInfo, FieldInfo, FunctionInfo, ImplementBlockInfo, InterfaceInfo, MethodInfo,
    ModuleSymbols, ParamInfo, PrimitiveType, Symbol, SymbolKind, SymbolTable, TypeInfo, TypeParam,
};

/// Configuration for the emitter phase.
#[derive(Debug, Clone)]
pub struct EmitConfig {
    /// Maximum expression depth for generated expressions.
    pub max_expr_depth: usize,
    /// Number of statements per function body.
    pub statements_per_function: (usize, usize),
}

impl Default for EmitConfig {
    fn default() -> Self {
        Self {
            max_expr_depth: 3,
            statements_per_function: (2, 5),
        }
    }
}

/// Emit all modules to the given output directory.
pub fn emit_all<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    config: &EmitConfig,
    output_dir: &Path,
) -> io::Result<()> {
    for module in table.modules() {
        let code = emit_module(rng, table, module, config);
        let path = output_dir.join(&module.path);
        std::fs::write(path, code)?;
    }
    Ok(())
}

/// Emit a single module to a string.
pub fn emit_module<R: Rng>(
    rng: &mut R,
    table: &SymbolTable,
    module: &ModuleSymbols,
    config: &EmitConfig,
) -> String {
    let mut ctx = EmitContext::new(rng, table, module, config);
    ctx.emit_module();
    ctx.output
}

/// Context for emitting a module.
struct EmitContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    module: &'a ModuleSymbols,
    config: &'a EmitConfig,
    output: String,
    indent: usize,
}

impl<'a, R: Rng> EmitContext<'a, R> {
    fn new(
        rng: &'a mut R,
        table: &'a SymbolTable,
        module: &'a ModuleSymbols,
        config: &'a EmitConfig,
    ) -> Self {
        Self {
            rng,
            table,
            module,
            config,
            output: String::new(),
            indent: 0,
        }
    }

    fn emit_module(&mut self) {
        // Emit file header comment
        self.emit_line(&format!("// Module: {}", self.module.name));
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Emit imports
        self.emit_imports();

        // Emit globals
        for symbol in self.module.globals() {
            self.emit_global(symbol);
        }

        // Emit interfaces
        for symbol in self.module.interfaces() {
            self.emit_interface(symbol);
        }

        // Emit errors
        for symbol in self.module.errors() {
            self.emit_error(symbol);
        }

        // Emit classes
        for symbol in self.module.classes() {
            self.emit_class(symbol);
        }

        // Emit functions
        for symbol in self.module.functions() {
            self.emit_function(symbol);
        }

        // Emit implement blocks
        for symbol in self.module.implement_blocks() {
            self.emit_implement_block(symbol);
        }
    }

    fn emit_imports(&mut self) {
        for import in &self.module.imports {
            if let Some(target) = self.table.get_module(import.target_module) {
                self.emit_line(&format!(
                    "let {} = import \"./{}.vole\"",
                    import.alias, target.name
                ));
            }
        }
        if !self.module.imports.is_empty() {
            self.emit_line("");
        }
    }

    fn emit_global(&mut self, symbol: &Symbol) {
        if let SymbolKind::Global(ref info) = symbol.kind {
            let mutability = if info.is_mutable { "let mut" } else { "let" };
            let value = self.literal_for_type(&info.value_type);
            self.emit_line(&format!(
                "{} {}: {} = {}",
                mutability,
                symbol.name,
                info.value_type.to_vole_syntax(self.table),
                value
            ));
        }
    }

    fn emit_interface(&mut self, symbol: &Symbol) {
        if let SymbolKind::Interface(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_interface_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            for method in &info.methods {
                self.emit_method_signature(method);
            }
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_interface_header(&self, name: &str, info: &InterfaceInfo) -> String {
        let mut header = String::from("interface ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        // Add extends clause
        if !info.extends.is_empty() {
            let parent_names: Vec<String> = info
                .extends
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !parent_names.is_empty() {
                header.push_str(" extends ");
                header.push_str(&parent_names.join(", "));
            }
        }

        header
    }

    fn emit_error(&mut self, symbol: &Symbol) {
        if let SymbolKind::Error(ref info) = symbol.kind {
            self.emit_line("");
            if info.fields.is_empty() {
                self.emit_line(&format!("error {} {{}}", symbol.name));
            } else {
                let fields: Vec<String> = info
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.field_type.to_vole_syntax(self.table)))
                    .collect();
                self.emit_line(&format!(
                    "error {} {{ {} }}",
                    symbol.name,
                    fields.join(", ")
                ));
            }
        }
    }

    fn emit_class(&mut self, symbol: &Symbol) {
        if let SymbolKind::Class(ref info) = symbol.kind {
            self.emit_line("");
            self.emit_class_header(symbol, info);
            self.indent += 1;

            // Emit fields
            for field in &info.fields {
                self.emit_field(field);
            }

            // Emit methods
            for method in &info.methods {
                self.emit_method(method);
            }

            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn emit_class_header(&mut self, symbol: &Symbol, info: &ClassInfo) {
        let mut header = String::from("class ");
        header.push_str(&symbol.name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        if !info.implements.is_empty() {
            let iface_names: Vec<String> = info
                .implements
                .iter()
                .filter_map(|(mod_id, sym_id)| {
                    self.table
                        .get_symbol(*mod_id, *sym_id)
                        .map(|s| s.name.clone())
                })
                .collect();
            if !iface_names.is_empty() {
                header.push_str(" implements ");
                header.push_str(&iface_names.join(", "));
            }
        }

        header.push_str(" {");
        self.emit_line(&header);
    }

    fn emit_field(&mut self, field: &FieldInfo) {
        self.emit_line(&format!(
            "{}: {},",
            field.name,
            field.field_type.to_vole_syntax(self.table)
        ));
    }

    fn emit_method_signature(&mut self, method: &MethodInfo) {
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!("func {}({}){}", method.name, params, return_type));
    }

    fn emit_method(&mut self, method: &MethodInfo) {
        self.emit_line("");
        let params = self.format_params(&method.params);
        let return_type = self.format_return_type(&method.return_type);
        self.emit_line(&format!(
            "func {}({}){} {{",
            method.name, params, return_type
        ));
        self.indent += 1;
        self.emit_function_body(&method.return_type, &method.params);
        self.indent -= 1;
        self.emit_line("}");
    }

    fn emit_function(&mut self, symbol: &Symbol) {
        if let SymbolKind::Function(ref info) = symbol.kind {
            self.emit_line("");
            let header = self.format_function_header(&symbol.name, info);
            self.emit_line(&format!("{} {{", header));
            self.indent += 1;
            self.emit_function_body(&info.return_type, &info.params);
            self.indent -= 1;
            self.emit_line("}");
        }
    }

    fn format_function_header(&self, name: &str, info: &FunctionInfo) -> String {
        let mut header = String::from("func ");
        header.push_str(name);

        // Add type parameters
        if !info.type_params.is_empty() {
            header.push('<');
            header.push_str(&self.format_type_params(&info.type_params));
            header.push('>');
        }

        header.push('(');
        header.push_str(&self.format_params(&info.params));
        header.push(')');
        header.push_str(&self.format_return_type(&info.return_type));

        header
    }

    fn emit_function_body(&mut self, return_type: &TypeInfo, params: &[ParamInfo]) {
        let stmt_count = self.rng.gen_range(
            self.config.statements_per_function.0..=self.config.statements_per_function.1,
        );

        // Generate some local variables and statements
        for i in 0..stmt_count {
            let var_name = format!("local{}", i);
            let expr = self.random_expression(params, 0);
            self.emit_line(&format!("let {} = {}", var_name, expr));
        }

        // Generate return statement
        match return_type {
            TypeInfo::Void => {
                // No return needed
            }
            _ => {
                let return_expr = self.expression_for_type(return_type, params, 0);
                self.emit_line(&format!("return {}", return_expr));
            }
        }
    }

    fn format_params(&self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.param_type.to_vole_syntax(self.table)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn format_return_type(&self, return_type: &TypeInfo) -> String {
        match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        }
    }

    fn format_type_params(&self, type_params: &[TypeParam]) -> String {
        type_params
            .iter()
            .map(|tp| {
                if tp.constraints.is_empty() {
                    tp.name.clone()
                } else {
                    let constraint_names: Vec<String> = tp
                        .constraints
                        .iter()
                        .filter_map(|(mod_id, sym_id)| {
                            self.table
                                .get_symbol(*mod_id, *sym_id)
                                .map(|s| s.name.clone())
                        })
                        .collect();
                    format!("{}: {}", tp.name, constraint_names.join(" + "))
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn emit_implement_block(&mut self, symbol: &Symbol) {
        if let SymbolKind::ImplementBlock(ref info) = symbol.kind {
            self.emit_implement_block_inner(info);
        }
    }

    fn emit_implement_block_inner(&mut self, info: &ImplementBlockInfo) {
        // Get interface and target type names
        let iface_name = self
            .table
            .get_symbol(info.interface.0, info.interface.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownInterface".to_string());

        let target_name = self
            .table
            .get_symbol(info.target_type.0, info.target_type.1)
            .map(|s| s.name.clone())
            .unwrap_or_else(|| "UnknownType".to_string());

        self.emit_line("");
        self.emit_line(&format!("implement {} for {} {{", iface_name, target_name));
        self.indent += 1;

        for method in &info.methods {
            self.emit_method(method);
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn literal_for_type(&mut self, type_info: &TypeInfo) -> String {
        match type_info {
            TypeInfo::Primitive(p) => self.literal_for_primitive(*p),
            TypeInfo::Optional(_) => "nil".to_string(),
            TypeInfo::Void => "nil".to_string(),
            _ => "nil".to_string(),
        }
    }

    fn literal_for_primitive(&mut self, prim: PrimitiveType) -> String {
        match prim {
            PrimitiveType::I32 => self.rng.gen_range(0..100).to_string(),
            PrimitiveType::I64 => self.rng.gen_range(0..1000).to_string(),
            PrimitiveType::F64 => {
                let val = self.rng.gen_range(0..100) as f64;
                format!("{:.2}", val + 0.5)
            }
            PrimitiveType::Bool => {
                let b = self.rng.gen_bool(0.5);
                if b { "true" } else { "false" }.to_string()
            }
            PrimitiveType::String => format!("\"str{}\"", self.rng.gen_range(0..100)),
            PrimitiveType::Nil => "nil".to_string(),
        }
    }

    fn random_expression(&mut self, params: &[ParamInfo], depth: usize) -> String {
        if depth >= self.config.max_expr_depth || params.is_empty() {
            // Return a simple literal
            let prim = PrimitiveType::random_expr_type(self.rng);
            return self.literal_for_primitive(prim);
        }

        // Choose expression type
        match self.rng.gen_range(0..5) {
            0 => {
                // Use a parameter
                let param = &params[self.rng.gen_range(0..params.len())];
                param.name.clone()
            }
            1 => {
                // Binary operation on integers
                let left = self.random_expression(params, depth + 1);
                let right = self.random_expression(params, depth + 1);
                let op = match self.rng.gen_range(0..4) {
                    0 => "+",
                    1 => "-",
                    2 => "*",
                    _ => "/",
                };
                format!("({} {} {})", left, op, right)
            }
            2 => {
                // Comparison
                let left = self.random_expression(params, depth + 1);
                let right = self.random_expression(params, depth + 1);
                let op = match self.rng.gen_range(0..4) {
                    0 => "==",
                    1 => "!=",
                    2 => "<",
                    _ => ">",
                };
                format!("({} {} {})", left, op, right)
            }
            3 => {
                // Literal
                let prim = PrimitiveType::random_expr_type(self.rng);
                self.literal_for_primitive(prim)
            }
            _ => {
                // Boolean operation
                let left = self.random_expression(params, depth + 1);
                let right = self.random_expression(params, depth + 1);
                let use_and = self.rng.gen_bool(0.5);
                let op = if use_and { "and" } else { "or" };
                format!("({} {} {})", left, op, right)
            }
        }
    }

    fn expression_for_type(
        &mut self,
        type_info: &TypeInfo,
        params: &[ParamInfo],
        depth: usize,
    ) -> String {
        match type_info {
            TypeInfo::Primitive(p) => {
                // Try to find a parameter of the same type
                let matching_param = params
                    .iter()
                    .find(|p2| matches!(&p2.param_type, TypeInfo::Primitive(pt) if pt == p));
                if let Some(param) = matching_param {
                    param.name.clone()
                } else {
                    self.literal_for_primitive(*p)
                }
            }
            TypeInfo::Optional(inner) => {
                // 50% chance of nil, 50% chance of value
                let use_nil = self.rng.gen_bool(0.5);
                if use_nil {
                    "nil".to_string()
                } else {
                    self.expression_for_type(inner, params, depth)
                }
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(types) => {
                // Pick one of the union types
                if types.is_empty() {
                    "nil".to_string()
                } else {
                    let idx = self.rng.gen_range(0..types.len());
                    self.expression_for_type(&types[idx], params, depth)
                }
            }
            _ => {
                let prim = PrimitiveType::random_expr_type(self.rng);
                self.literal_for_primitive(prim)
            }
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent_str, line).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use crate::symbols::ModuleId;
    use rand::SeedableRng;

    #[test]
    fn emit_module_produces_code() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("// Module:"));
        assert!(code.contains("func"));
    }

    #[test]
    fn emit_module_contains_class() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("class Class"));
    }

    #[test]
    fn emit_module_contains_interface() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (1, 1),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let module = table.get_module(ModuleId(0)).unwrap();
        let emit_config = EmitConfig::default();

        let code = emit_module(&mut rng, &table, module, &emit_config);

        assert!(code.contains("interface IFace"));
    }

    #[test]
    fn emit_is_deterministic() {
        let plan_config = PlanConfig::default();
        let emit_config = EmitConfig::default();

        let mut rng1 = rand::rngs::StdRng::seed_from_u64(12345);
        let table1 = plan(&mut rng1, &plan_config);
        let module1 = table1.get_module(ModuleId(0)).unwrap();
        let code1 = emit_module(&mut rng1, &table1, module1, &emit_config);

        let mut rng2 = rand::rngs::StdRng::seed_from_u64(12345);
        let table2 = plan(&mut rng2, &plan_config);
        let module2 = table2.get_module(ModuleId(0)).unwrap();
        let code2 = emit_module(&mut rng2, &table2, module2, &emit_config);

        assert_eq!(code1, code2);
    }
}
