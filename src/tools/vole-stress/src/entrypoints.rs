//! Entrypoint generation: main.vole and tests.vole
//!
//! This module generates entrypoint files that import leaf modules and exercise
//! the generated codebase through function calls, class construction, and tests.

use rand::Rng;
use std::fmt::Write as _;

use crate::symbols::{
    FieldInfo, ModuleSymbols, ParamInfo, PrimitiveType, StructInfo, SymbolKind, SymbolTable,
    TypeInfo,
};

/// Emit main.vole entrypoint that imports leaf modules and exercises the generated code.
pub fn emit_main<R: Rng>(rng: &mut R, table: &SymbolTable) -> String {
    let mut ctx = EntrypointContext::new(rng, table);
    ctx.emit_main()
}

/// Emit tests.vole integration tests that exercise cross-module functionality.
pub fn emit_integration_tests<R: Rng>(rng: &mut R, table: &SymbolTable) -> String {
    let mut ctx = EntrypointContext::new(rng, table);
    ctx.emit_tests()
}

/// Context for emitting entrypoint files (main.vole and tests.vole).
struct EntrypointContext<'a, R> {
    rng: &'a mut R,
    table: &'a SymbolTable,
    output: String,
    indent: usize,
}

impl<'a, R: Rng> EntrypointContext<'a, R> {
    fn new(rng: &'a mut R, table: &'a SymbolTable) -> Self {
        Self {
            rng,
            table,
            output: String::new(),
            indent: 0,
        }
    }

    fn emit_main(&mut self) -> String {
        self.emit_line("// main.vole - Entrypoint for stress test codebase");
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Get leaf modules and collect their imports
        let leaf_modules: Vec<_> = self.table.leaf_modules();
        let mut imports: Vec<(&str, &str)> = Vec::new();

        for module in &leaf_modules {
            imports.push((&module.name, &module.path));
        }

        // Emit imports
        for (name, path) in &imports {
            self.emit_line(&format!("let {} = import \"./{path}\"", name));
        }
        if !imports.is_empty() {
            self.emit_line("");
        }

        // Emit main function
        self.emit_line("func main() {");
        self.indent += 1;

        if leaf_modules.is_empty() {
            self.emit_line("print(\"No leaf modules to exercise\")");
        } else {
            for module in &leaf_modules {
                self.emit_module_exercises(module);
            }
        }

        self.emit_line("print(\"done\")");

        self.indent -= 1;
        self.emit_line("}");

        std::mem::take(&mut self.output)
    }

    fn emit_tests(&mut self) -> String {
        self.emit_line("// tests.vole - Integration tests for stress test codebase");
        self.emit_line("// Generated by vole-stress");
        self.emit_line("");

        // Get leaf modules and collect their imports
        let leaf_modules: Vec<_> = self.table.leaf_modules();
        let mut imports: Vec<(&str, &str)> = Vec::new();

        for module in &leaf_modules {
            imports.push((&module.name, &module.path));
        }

        // Emit imports
        for (name, path) in &imports {
            self.emit_line(&format!("let {} = import \"./{path}\"", name));
        }
        if !imports.is_empty() {
            self.emit_line("");
        }

        // Emit tests block
        self.emit_line("tests \"integration\" {");
        self.indent += 1;

        if leaf_modules.is_empty() {
            self.emit_test_empty_codebase();
        } else {
            for module in &leaf_modules {
                self.emit_module_tests(module);
            }
        }

        self.indent -= 1;
        self.emit_line("}");

        std::mem::take(&mut self.output)
    }

    fn emit_test_empty_codebase(&mut self) {
        self.emit_line("test \"empty codebase\" {");
        self.indent += 1;
        self.emit_line("assert(true)");
        self.indent -= 1;
        self.emit_line("}");
    }

    fn emit_module_tests(&mut self, module: &ModuleSymbols) {
        // Test globals (read non-mutable ones)
        for symbol in module.globals() {
            if let SymbolKind::Global(ref info) = symbol.kind {
                if !info.is_mutable {
                    self.emit_global_test(module, &symbol.name);
                }
            }
        }

        // Test functions (non-generic, non-diverging ones without interface params)
        for symbol in module.functions() {
            if let SymbolKind::Function(ref info) = symbol.kind {
                if info.type_params.is_empty()
                    && !matches!(info.return_type, TypeInfo::Never)
                    && !info
                        .params
                        .iter()
                        .any(|p| p.param_type.contains_interface())
                {
                    self.emit_function_test(module, &symbol.name, info);
                }
            }
        }

        // Test classes (non-generic ones)
        for symbol in module.classes() {
            if let SymbolKind::Class(ref info) = symbol.kind {
                if info.type_params.is_empty() {
                    self.emit_class_test(module, &symbol.name, info);
                }
            }
        }

        // Test structs
        for symbol in module.structs() {
            if let SymbolKind::Struct(ref info) = symbol.kind {
                self.emit_struct_test(module, &symbol.name, info);
            }
        }
    }

    fn emit_global_test(&mut self, module: &ModuleSymbols, name: &str) {
        self.emit_line(&format!(
            "test \"{}.{} global access\" {{",
            module.name, name
        ));
        self.indent += 1;
        // Use _ = value pattern to verify access succeeds without nil comparison
        // (non-optional types can't be compared to nil in Vole)
        self.emit_line(&format!("let _ = {}.{}", module.name, name));
        self.emit_line("assert(true)");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn emit_function_test(
        &mut self,
        module: &ModuleSymbols,
        name: &str,
        info: &crate::symbols::FunctionInfo,
    ) {
        self.emit_line(&format!(
            "test \"{}.{} function call\" {{",
            module.name, name
        ));
        self.indent += 1;

        let args = self.generate_call_args(&info.params);
        let call = format!("{}.{}({})", module.name, name, args);

        match &info.return_type {
            TypeInfo::Iterator(elem_type) => {
                // Generator function - exercise with iterator methods
                let chain = self.generate_iterator_chain(elem_type);
                self.emit_line(&format!("let _result = {}{}", call, chain));
                self.emit_line("assert(true)");
            }
            TypeInfo::Fallible { success, .. } => {
                // Fallible function - wrap in match to handle success/error
                let default_val = self.generate_value_for_type(success);
                self.emit_line(&format!(
                    "let _result = match {} {{ success x => x, error => {}, _ => {} }}",
                    call, default_val, default_val
                ));
                self.emit_line("assert(true)");
            }
            TypeInfo::Void => {
                self.emit_line(&call);
                self.emit_line("assert(true)");
            }
            TypeInfo::Optional(_) => {
                // Optional types can be compared to nil
                self.emit_line(&format!("let result = {}", call));
                self.emit_line("assert(result != nil || result == nil)");
            }
            _ => {
                // Non-optional types can't be compared to nil in Vole
                // Just verify the call succeeds by discarding the result
                self.emit_line(&format!("let _ = {}", call));
                self.emit_line("assert(true)");
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn emit_class_test(
        &mut self,
        module: &ModuleSymbols,
        name: &str,
        info: &crate::symbols::ClassInfo,
    ) {
        self.emit_line(&format!(
            "test \"{}.{} class construction\" {{",
            module.name, name
        ));
        self.indent += 1;

        let fields = self.generate_field_values(&info.fields);
        // Use _ = instance pattern to verify construction succeeds without nil comparison
        // (non-optional class instances can't be compared to nil in Vole)
        self.emit_line(&format!(
            "let instance = {}.{} {{ {} }}",
            module.name, name, fields
        ));
        // Construction succeeded if we get here, assert true
        self.emit_line("assert(true)");

        // Test each method that doesn't have type parameters
        for method in &info.methods {
            let args = self.generate_call_args(&method.params);
            match &method.return_type {
                TypeInfo::Void => {
                    self.emit_line(&format!("instance.{}({})", method.name, args));
                }
                _ => {
                    self.emit_line(&format!(
                        "let _{}_result = instance.{}({})",
                        method.name, method.name, args
                    ));
                }
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn emit_struct_test(&mut self, module: &ModuleSymbols, name: &str, info: &StructInfo) {
        self.emit_line(&format!(
            "test \"{}.{} struct construction\" {{",
            module.name, name
        ));
        self.indent += 1;

        let fields = self.generate_field_values(&info.fields);
        self.emit_line(&format!(
            "let instance = {}.{} {{ {} }}",
            module.name, name, fields
        ));
        // Construction succeeded if we get here
        self.emit_line("assert(true)");

        // Test field access for each field
        for field in &info.fields {
            self.emit_line(&format!(
                "let _{}_val = instance.{}",
                field.name, field.name
            ));
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn emit_module_exercises(&mut self, module: &ModuleSymbols) {
        self.emit_line(&format!("// Exercise {}", module.name));

        // Exercise globals (read non-mutable ones - mutable globals are not exported)
        for symbol in module.globals() {
            if let SymbolKind::Global(ref info) = symbol.kind {
                if !info.is_mutable {
                    self.emit_line(&format!(
                        "let _{}_val = {}.{}",
                        symbol.name.to_lowercase(),
                        module.name,
                        symbol.name
                    ));
                }
            }
        }

        // Exercise functions (call non-generic, non-diverging ones without interface params)
        for symbol in module.functions() {
            if let SymbolKind::Function(ref info) = symbol.kind {
                if info.type_params.is_empty()
                    && !matches!(info.return_type, TypeInfo::Never)
                    && !info
                        .params
                        .iter()
                        .any(|p| p.param_type.contains_interface())
                {
                    let args = self.generate_call_args(&info.params);
                    match &info.return_type {
                        TypeInfo::Iterator(elem_type) => {
                            // Generator function - exercise with iterator methods
                            let chain = self.generate_iterator_chain(elem_type);
                            self.emit_line(&format!(
                                "let _{}_result = {}.{}({}){}",
                                symbol.name, module.name, symbol.name, args, chain
                            ));
                        }
                        TypeInfo::Fallible { success, .. } => {
                            // Fallible function - wrap in match to handle result
                            let default_val = self.generate_value_for_type(success);
                            self.emit_line(&format!(
                                "let _{}_result = match {}.{}({}) {{ success x => x, error => {}, _ => {} }}",
                                symbol.name, module.name, symbol.name, args, default_val, default_val
                            ));
                        }
                        TypeInfo::Void => {
                            self.emit_line(&format!("{}.{}({})", module.name, symbol.name, args));
                        }
                        _ => {
                            self.emit_line(&format!(
                                "let _{}_result = {}.{}({})",
                                symbol.name, module.name, symbol.name, args
                            ));
                        }
                    }
                }
            }
        }

        // Exercise classes (construct non-generic ones)
        for symbol in module.classes() {
            if let SymbolKind::Class(ref info) = symbol.kind {
                if info.type_params.is_empty() {
                    let fields = self.generate_field_values(&info.fields);
                    self.emit_line(&format!(
                        "let _{}_instance = {}.{} {{ {} }}",
                        symbol.name.to_lowercase(),
                        module.name,
                        symbol.name,
                        fields
                    ));
                }
            }
        }

        // Exercise structs (construct all - structs have no generics)
        for symbol in module.structs() {
            if let SymbolKind::Struct(ref info) = symbol.kind {
                let fields = self.generate_field_values(&info.fields);
                self.emit_line(&format!(
                    "let _{}_instance = {}.{} {{ {} }}",
                    symbol.name.to_lowercase(),
                    module.name,
                    symbol.name,
                    fields
                ));
            }
        }

        self.emit_line("");
    }

    /// Generate a random iterator method chain for a generator call.
    ///
    /// The element type determines which terminal methods are valid:
    /// - `.sum()` is only valid for numeric element types
    /// - `.count()` is always valid and returns i64
    /// - All other chains end with `.collect()`
    fn generate_iterator_chain(&mut self, elem_type: &TypeInfo) -> String {
        let is_numeric = matches!(
            elem_type,
            TypeInfo::Primitive(PrimitiveType::I64)
                | TypeInfo::Primitive(PrimitiveType::I32)
                | TypeInfo::Primitive(PrimitiveType::F64)
        );

        let pattern = self.rng.gen_range(0..10);
        match pattern {
            0..=3 => ".collect()".to_string(),
            4 => {
                let n = self.rng.gen_range(1..=3);
                format!(".take({}).collect()", n)
            }
            5 => {
                let n = self.rng.gen_range(1..=2);
                format!(".skip({}).collect()", n)
            }
            6 => ".count()".to_string(),
            7 if is_numeric => ".sum()".to_string(),
            8 => {
                let pred = self.generate_filter_predicate(elem_type);
                format!(".filter({}).collect()", pred)
            }
            9 => {
                let mapper = self.generate_map_lambda(elem_type);
                format!(".map({}).collect()", mapper)
            }
            _ => ".collect()".to_string(),
        }
    }

    /// Generate a filter predicate lambda for a given element type.
    fn generate_filter_predicate(&self, elem_type: &TypeInfo) -> &'static str {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x > 0_i64",
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x > 0_i32",
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x > 0.0_f64",
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => x",
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => true",
            _ => "(x) => true",
        }
    }

    /// Generate a map transformation lambda for a given element type.
    fn generate_map_lambda(&self, elem_type: &TypeInfo) -> &'static str {
        match elem_type {
            TypeInfo::Primitive(PrimitiveType::I64) => "(x) => x + 1_i64",
            TypeInfo::Primitive(PrimitiveType::I32) => "(x) => x + 1_i32",
            TypeInfo::Primitive(PrimitiveType::F64) => "(x) => x + 1.0_f64",
            TypeInfo::Primitive(PrimitiveType::Bool) => "(x) => !x",
            TypeInfo::Primitive(PrimitiveType::String) => "(x) => x",
            _ => "(x) => x",
        }
    }

    fn generate_call_args(&mut self, params: &[ParamInfo]) -> String {
        params
            .iter()
            .map(|p| self.generate_value_for_type(&p.param_type))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn generate_field_values(&mut self, fields: &[FieldInfo]) -> String {
        fields
            .iter()
            .map(|f| {
                format!(
                    "{}: {}",
                    f.name,
                    self.generate_value_for_type(&f.field_type)
                )
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn generate_value_for_type(&mut self, ty: &TypeInfo) -> String {
        match ty {
            TypeInfo::Primitive(prim) => self.generate_primitive_value(*prim),
            TypeInfo::Optional(inner) => {
                // Generate a typed value rather than nil so the value carries
                // type information when nested inside containers like [T?].
                self.generate_value_for_type(inner)
            }
            TypeInfo::Array(elem) => {
                let elem_val = self.generate_value_for_type(elem);
                format!("[{}]", elem_val)
            }
            TypeInfo::Tuple(elems) => {
                let values: Vec<String> = elems
                    .iter()
                    .map(|t| self.generate_value_for_type(t))
                    .collect();
                format!("[{}]", values.join(", "))
            }
            TypeInfo::Void => "nil".to_string(),
            TypeInfo::Union(variants) => {
                // For union types, generate a value for the first variant
                if let Some(first) = variants.first() {
                    self.generate_value_for_type(first)
                } else {
                    "nil".to_string()
                }
            }
            TypeInfo::Class(mod_id, sym_id) => {
                // For class types, construct an instance with module-qualified name
                if let Some(module) = self.table.get_module(*mod_id) {
                    if let Some(symbol) = module.get_symbol(*sym_id) {
                        if let SymbolKind::Class(ref class_info) = symbol.kind {
                            if class_info.type_params.is_empty() {
                                let fields = self.generate_field_values(&class_info.fields);
                                return format!("{}.{} {{ {} }}", module.name, symbol.name, fields);
                            }
                        }
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Struct(mod_id, sym_id) => {
                // For struct types, construct an instance with module-qualified name
                if let Some(module) = self.table.get_module(*mod_id) {
                    if let Some(symbol) = module.get_symbol(*sym_id) {
                        if let SymbolKind::Struct(ref struct_info) = symbol.kind {
                            let fields = self.generate_field_values(&struct_info.fields);
                            return format!("{}.{} {{ {} }}", module.name, symbol.name, fields);
                        }
                    }
                }
                "nil".to_string()
            }
            TypeInfo::Function {
                param_types,
                return_type,
            } => self.generate_lambda_for_function_type(param_types, return_type),
            _ => "nil".to_string(),
        }
    }

    /// Generate a lambda expression matching a function type signature.
    fn generate_lambda_for_function_type(
        &mut self,
        param_types: &[TypeInfo],
        return_type: &TypeInfo,
    ) -> String {
        let params: Vec<String> = param_types
            .iter()
            .enumerate()
            .map(|(i, ty)| format!("p{}: {}", i, ty.to_vole_syntax(self.table)))
            .collect();
        let body = self.generate_value_for_type(return_type);
        let return_annotation = match return_type {
            TypeInfo::Void => String::new(),
            _ => format!(" -> {}", return_type.to_vole_syntax(self.table)),
        };
        format!("({}){} => {}", params.join(", "), return_annotation, body)
    }

    fn generate_primitive_value(&mut self, prim: PrimitiveType) -> String {
        match prim {
            PrimitiveType::I8 => {
                let val: i8 = self.rng.gen_range(1..50);
                format!("{}_i8", val)
            }
            PrimitiveType::I16 => {
                let val: i16 = self.rng.gen_range(1..100);
                format!("{}_i16", val)
            }
            PrimitiveType::I32 => {
                let val: i32 = self.rng.gen_range(1..50);
                format!("{}_i32", val)
            }
            PrimitiveType::I64 => {
                let val: i64 = self.rng.gen_range(1..100);
                format!("{}_i64", val)
            }
            PrimitiveType::I128 => {
                let val: i64 = self.rng.gen_range(1..1000);
                format!("{}_i128", val)
            }
            PrimitiveType::U8 => {
                let val: u8 = self.rng.gen_range(1..50);
                format!("{}_u8", val)
            }
            PrimitiveType::U16 => {
                let val: u16 = self.rng.gen_range(1..100);
                format!("{}_u16", val)
            }
            PrimitiveType::U32 => {
                let val: u32 = self.rng.gen_range(1..100);
                format!("{}_u32", val)
            }
            PrimitiveType::U64 => {
                let val: u64 = self.rng.gen_range(1..1000);
                format!("{}_u64", val)
            }
            PrimitiveType::F32 => {
                let val: f32 = self.rng.gen_range(1.0_f32..50.0_f32);
                format!("{:.2}_f32", val)
            }
            PrimitiveType::F64 => {
                let val: f64 = self.rng.gen_range(1.0..50.0);
                format!("{:.2}_f64", val)
            }
            PrimitiveType::Bool => "true".to_string(),
            PrimitiveType::String => {
                let id = self.rng.gen_range(0..100);
                format!("\"test{}\"", id)
            }
            PrimitiveType::Nil => "nil".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent_str = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent_str, line).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::planner::{PlanConfig, plan};
    use rand::SeedableRng;

    #[test]
    fn emit_main_imports_leaf_modules_and_exercises_contents() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 2,
            modules_per_layer: 2,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (1, 1),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_main(&mut rng, &table);

        // Should contain main.vole header and func main
        assert!(code.contains("// main.vole"));
        assert!(code.contains("func main()"));

        // Should import leaf modules (layer 1) but not layer 0 modules
        assert!(code.contains("import \"./mod_l1"));
        assert!(!code.contains("import \"./mod_l0"));

        // Should exercise globals, functions, and classes
        assert!(code.contains("_global"));
        assert!(code.contains("_func"));
        assert!(code.contains("_class"));
    }

    #[test]
    fn emit_integration_tests_generates_tests_block() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 2,
            modules_per_layer: 2,
            classes_per_module: (1, 1),
            functions_per_module: (1, 1),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (1, 1),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should contain tests.vole header
        assert!(code.contains("// tests.vole"));

        // Should have tests block
        assert!(code.contains("tests \"integration\" {"));

        // Should import leaf modules
        assert!(code.contains("import \"./mod_l1"));
        assert!(!code.contains("import \"./mod_l0"));

        // Should have individual test cases
        assert!(code.contains("test \""));
        assert!(code.contains("assert("));
    }

    #[test]
    fn emit_integration_tests_tests_globals() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (1, 1),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should test globals
        assert!(code.contains("global access\""));
    }

    #[test]
    fn emit_integration_tests_tests_functions() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (0, 0),
            functions_per_module: (2, 2),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should test functions
        assert!(code.contains("function call\""));
    }

    #[test]
    fn emit_integration_tests_tests_classes() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            classes_per_module: (1, 1),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should test class construction
        assert!(code.contains("class construction\""));
        assert!(code.contains("let instance ="));
    }

    #[test]
    fn emit_integration_tests_tests_structs() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 1,
            modules_per_layer: 1,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should test struct construction
        assert!(
            code.contains("struct construction\""),
            "Expected struct construction test, got:\n{}",
            code
        );
        assert!(
            code.contains("let instance ="),
            "Expected struct instance creation, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_main_exercises_structs() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 2,
            modules_per_layer: 2,
            structs_per_module: (1, 1),
            classes_per_module: (0, 0),
            functions_per_module: (0, 0),
            interfaces_per_module: (0, 0),
            errors_per_module: (0, 0),
            globals_per_module: (0, 0),
            type_params_per_class: (0, 0),
            type_params_per_function: (0, 0),
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_main(&mut rng, &table);

        // Should exercise struct construction in main
        assert!(
            code.contains("_struct"),
            "Expected struct exercise in main, got:\n{}",
            code
        );
    }

    #[test]
    fn emit_integration_tests_empty_codebase() {
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let plan_config = PlanConfig {
            layers: 0,
            modules_per_layer: 0,
            ..Default::default()
        };

        let table = plan(&mut rng, &plan_config);
        let code = emit_integration_tests(&mut rng, &table);

        // Should handle empty codebase gracefully
        assert!(code.contains("test \"empty codebase\""));
        assert!(code.contains("assert(true)"));
    }
}
