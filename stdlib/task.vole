// stdlib/task.vole
// Task and channel primitives for concurrency.
//
// Tasks are spawned with Task.run(() => { ... }) and return a handle.
// Use .join() to wait for a task to complete and get its result.
// Use .cancel() to request cooperative cancellation.
//
// Channels are the communication primitive between tasks.
// Use Channel.buffered<T>(n) for buffered channels or Channel.new<T>()
// for unbuffered (rendezvous) channels.
//
// Example usage:
//   let task = import "std:task"
//
//   // Spawn and join a task
//   let t = task.Task.run(() -> i64 => { return 42 })
//   assert(t.join() == 42)
//
//   // Channel communication
//   let ch = task.Channel.buffered<i64>(10)
//   ch.send(42)
//   let val = ch.receive()
//   ch.close()

let { Duration } = import "std:time"

// Native bindings to std:task module
external("std:task") {
    func "channel_new" as _channel_new(capacity: i64) -> handle
    func "channel_send" as _channel_send(ch: handle, tag: i64, value: i64) -> i64
    func "channel_recv" as _channel_recv(ch: handle) -> RecvResult
    func "channel_close" as _channel_close(ch: handle)
    func "channel_is_closed" as _channel_is_closed(ch: handle) -> i64
    func "task_run" as _task_run<T>(closure: () -> T) -> handle
    func "task_join" as _task_join(task: handle) -> JoinResult
    func "task_cancel" as _task_cancel(task: handle)
    func "task_is_done" as _task_is_done(task: handle) -> i64
    func "task_select2" as _task_select2(ch1: handle, ch2: handle, timeout_nanos: i64) -> i64
    func "task_select3" as _task_select3(ch1: handle, ch2: handle, ch3: handle, timeout_nanos: i64) -> i64
}

external("vole:compiler_intrinsic") {
    func _channel_send_t<T: Sendable>(ch: handle, value: T) -> bool where {
        default => "task_channel_send"
    }
    func _channel_receive_t<T: Sendable>(ch: handle) -> T where {
        default => "task_channel_recv"
    }
    func _channel_try_receive_t<T: Sendable>(ch: handle) -> T | Done where {
        default => "task_channel_try_recv"
    }
    func _task_join_t<T: Sendable>(task: handle) -> T where {
        default => "task_join"
    }
    func _task_run_t<T: Sendable>(closure: () -> T) -> handle where {
        default => "task_run"
    }
}

// =============================================================================
// FFI result structs
// =============================================================================

// Result of a channel recv: carries the type tag and raw value.
struct RecvResult {
    tag: i64,
    value: i64,
}

// Result of a task join: carries the type tag and raw value.
struct JoinResult {
    tag: i64,
    value: i64,
}

// =============================================================================
// SelectResult - return type for Task.select
// =============================================================================

// Result of a Task.select operation. Check `timed_out` first, then
// dispatch on `channel_index` to determine which channel produced the value.
// When `timed_out` is true, `value` is undefined and must not be read.
struct SelectResult<T> {
    channel_index: i64,
    value: T,
    timed_out: bool,
}

// =============================================================================
// Task - spawned green thread handle
// =============================================================================

class Task<T: Sendable> {
    _handle: handle,

    statics {
        // Spawn a task from a closure. The closure runs on the M:1 scheduler.
        // Returns a Task handle for join/cancel operations.
        func run(body: () -> T) -> Task<T> {
            return Task<T> { _handle: _task_run_t(body) }
        }

        // Create a streaming iterator backed by a producer task.
        // The producer receives an `emit` callback to send values.
        // The returned iterator yields values until the producer finishes.
        //
        // Example:
        //   let s = Task.stream((emit: (i64) -> void) => {
        //       emit(1)
        //       emit(2)
        //       emit(3)
        //   })
        //   for v in s { println(v) }
        func stream(producer: ((T) -> void) -> void) -> Iterator<T> {
            let ch = Channel<T> { _ptr: _channel_new(1) }
            let task = Task.run<i64>(() -> i64 => {
                producer((value: T) => {
                    _ = _channel_send_t(ch._ptr, value)
                })
                ch.close()
                return 0
            })
            return StreamIterator<T> { _ch: ch._ptr, _task: task._handle }
        }

        // Create a stateful actor backed by a task and channel.
        // The actor owns mutable state, receives messages of type T through
        // a channel, and applies the handler to update the state.
        //
        // Example:
        //   let counter = Task.state(0, (count: i64, msg: i64) -> i64 => {
        //       return count + msg
        //   })
        //   counter.send(1)
        //   counter.send(1)
        //   let final_count = counter.close_and_join()
        //   assert(final_count == 2)
        func state(initial: T, handler: (T, T) -> T) -> StateActor<T> {
            let ch = Channel.buffered<T>(8)
            let task = Task.run<T>(() -> T => {
                var current = initial
                for msg in ch.iter() {
                    current = handler(current, msg)
                }
                return current
            })
            return StateActor<T> { _ch: ch._ptr, _task: task._handle }
        }

        // Wait on two channels simultaneously, returning when the first
        // channel becomes ready or the timeout expires.
        //
        // `timeout` is the maximum wait duration (`Duration.zero()` = no timeout).
        // Returns a SelectResult<T> with:
        //   - channel_index: 0 or 1 (which channel has data)
        //   - value: the received value from that channel
        //   - timed_out: true if the timeout expired before any channel was ready
        //
        // When timed_out is true, value is undefined and must not be read.
        //
        // Example:
        //   let result = Task.select2(ch1, ch2, Duration.zero())
        //   if result.timed_out { println("timeout") }
        //   else if result.channel_index == 0 { handle(result.value) }
        func select2(ch1: Channel<T>, ch2: Channel<T>, timeout: Duration) -> SelectResult<T> {
            let idx = _task_select2(ch1._ptr, ch2._ptr, timeout.as_nanos())
            if idx == 0 {
                return SelectResult<T> { channel_index: 0, value: _channel_receive_t(ch1._ptr), timed_out: false }
            }
            if idx == 1 {
                return SelectResult<T> { channel_index: 1, value: _channel_receive_t(ch2._ptr), timed_out: false }
            }
            // Timeout: construct a dummy value via a temp closed channel.
            // The value is undefined; callers must check timed_out first.
            let tmp = Channel<T> { _ptr: _channel_new(0) }
            _channel_close(tmp._ptr)
            return SelectResult<T> { channel_index: -1, value: _channel_receive_t(tmp._ptr), timed_out: true }
        }

        // Wait on three channels simultaneously, returning when the first
        // channel becomes ready or the timeout expires.
        //
        // `timeout` is the maximum wait duration (`Duration.zero()` = no timeout).
        // Returns a SelectResult<T> with channel_index 0, 1, or 2.
        // When timed_out is true, value is undefined and must not be read.
        func select3(ch1: Channel<T>, ch2: Channel<T>, ch3: Channel<T>, timeout: Duration) -> SelectResult<T> {
            let idx = _task_select3(ch1._ptr, ch2._ptr, ch3._ptr, timeout.as_nanos())
            if idx == 0 {
                return SelectResult<T> { channel_index: 0, value: _channel_receive_t(ch1._ptr), timed_out: false }
            }
            if idx == 1 {
                return SelectResult<T> { channel_index: 1, value: _channel_receive_t(ch2._ptr), timed_out: false }
            }
            if idx == 2 {
                return SelectResult<T> { channel_index: 2, value: _channel_receive_t(ch3._ptr), timed_out: false }
            }
            // Timeout: construct a dummy value via a temp closed channel.
            // The value is undefined; callers must check timed_out first.
            let tmp = Channel<T> { _ptr: _channel_new(0) }
            _channel_close(tmp._ptr)
            return SelectResult<T> { channel_index: -1, value: _channel_receive_t(tmp._ptr), timed_out: true }
        }

        // Fan-out: spawn one task per closure and collect all results.
        // Results are returned in the same order as the input closures.
        func all(fns: [() -> T]) -> [T] {
            // Spawn all tasks first.
            let tasks: [Task<T>] = []
            var i = 0
            while i < fns.length() {
                tasks.push(Task.run(fns[i]))
                i = i + 1
            }

            // Join all tasks and collect results in order.
            let results: [T] = []
            var j = 0
            while j < tasks.length() {
                results.push(_task_join_t(tasks[j]._handle))
                j = j + 1
            }
            return results
        }

        // Transform all items and collect results.
        func parallel(items: [T], transform: (T) -> T) -> [T] {
            let fns: [() -> T] = []
            var i = 0
            while i < items.length() {
                let item = items[i]
                fns.push(() -> T => { return transform(item) })
                i = i + 1
            }
            return Task.all(fns)
        }

    }

    // Block until the task completes and return its result.
    // Panics if the task was cancelled or panicked.
    func join() -> T {
        return _task_join_t(self._handle)
    }

    // Request cooperative cancellation of the task.
    // If the task is already completed, this is a no-op.
    func cancel() {
        _task_cancel(self._handle)
    }

    // Check if the task has completed (or was cancelled).
    func is_done() -> bool {
        return _task_is_done(self._handle) == 1
    }
}

// =============================================================================
// Channel - communication channel between tasks
// =============================================================================

class Channel<T: Sendable> {
    _ptr: handle,

    statics {
        // Create an unbuffered (rendezvous) channel.
        func new() -> Channel<T> {
            return Channel<T> { _ptr: _channel_new(0) }
        }

        // Create a buffered channel with the given capacity.
        func buffered(capacity: i64) -> Channel<T> {
            return Channel<T> { _ptr: _channel_new(capacity) }
        }
    }

    // Send a value on the channel.
    // Returns true on success, false if the channel is closed.
    func send(value: T) -> bool {
        return _channel_send_t(self._ptr, value)
    }

    // Receive a value from the channel.
    func receive() -> T {
        return _channel_receive_t(self._ptr)
    }

    // Try to receive one value from the channel.
    // Returns `Done` when the channel is closed and empty.
    func try_receive() -> T | Done {
        return _channel_try_receive_t(self._ptr)
    }

    // Close the channel. Wakes all waiting tasks.
    // Double-close is a no-op.
    func close() {
        _channel_close(self._ptr)
    }

    // Check if the channel is closed.
    func is_closed() -> bool {
        return _channel_is_closed(self._ptr) == 1
    }

    // Return an iterator that drains the channel.
    // Yields values until the channel is closed and empty.
    func iter() -> Iterator<T> {
        return ChannelIterator<T> { _ptr: self._ptr }
    }
}

// =============================================================================
// ChannelIterator - drains a channel via the Iterator interface
// =============================================================================

class ChannelIterator<T: Sendable> implements Iterator<T> {
    _ptr: handle,
}

implement Iterator<T> for ChannelIterator<T> {
    func next() -> T | Done {
        return _channel_try_receive_t(self._ptr)
    }
}

// =============================================================================
// StreamIterator - drains a Task.stream's channel, keeping the task alive
// =============================================================================

class StreamIterator<T: Sendable> implements Iterator<T> {
    _ch: handle,
    _task: handle,
}

implement Iterator<T> for StreamIterator<T> {
    func next() -> T | Done {
        return _channel_try_receive_t(self._ch)
    }
}

// =============================================================================
// StateActor - stateful actor backed by a task and channel
// =============================================================================

class StateActor<T: Sendable> {
    _ch: handle,
    _task: handle,

    // Send a message to the actor.
    // The actor's handler will be called with (current_state, msg).
    func send(msg: T) {
        _ = _channel_send_t(self._ch, msg)
    }

    // Close the channel and wait for the actor task to finish.
    // Returns the actor's final state.
    func close_and_join() -> T {
        _channel_close(self._ch)
        return _task_join_t(self._task)
    }
}
