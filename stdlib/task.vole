// stdlib/task.vole
// Task and channel primitives for concurrency.
//
// Tasks are spawned with Task.run(() => { ... }) and return a handle.
// Use .join() to wait for a task to complete and get its result.
// Use .cancel() to request cooperative cancellation.
//
// Channels are the communication primitive between tasks.
// Use Channel.buffered<T>(n) for buffered channels or Channel.new<T>()
// for unbuffered (rendezvous) channels.
//
// Example usage:
//   let task = import "std:task"
//
//   // Spawn and join a task
//   let t = task.Task.run(() -> i64 => { return 42 })
//   assert(t.join() == 42)
//
//   // Channel communication
//   let ch = task.Channel.buffered<i64>(10)
//   ch.send(42)
//   let val = ch.receive()
//   ch.close()

// Native bindings to std:task module
external("std:task") {
    func "channel_new" as _channel_new(capacity: i64) -> handle
    func "channel_send" as _channel_send(ch: handle, tag: i64, value: i64) -> i64
    func "channel_recv" as _channel_recv(ch: handle) -> RecvResult
    func "channel_close" as _channel_close(ch: handle)
    func "channel_is_closed" as _channel_is_closed(ch: handle) -> i64
    func "task_run" as _task_run<T>(closure: () -> T) -> handle
    func "task_join" as _task_join(task: handle) -> JoinResult
    func "task_cancel" as _task_cancel(task: handle)
    func "task_is_done" as _task_is_done(task: handle) -> i64
    func "task_select2" as _task_select2(ch1: handle, ch2: handle, timeout_nanos: i64) -> i64
    func "task_select3" as _task_select3(ch1: handle, ch2: handle, ch3: handle, timeout_nanos: i64) -> i64
}

// =============================================================================
// FFI result structs
// =============================================================================

// Result of a channel recv: carries the type tag and raw value.
struct RecvResult {
    tag: i64,
    value: i64,
}

// Result of a task join: carries the type tag and raw value.
struct JoinResult {
    tag: i64,
    value: i64,
}

// =============================================================================
// SelectResult - return type for Task.select
// =============================================================================

// Result of a Task.select operation. Check `timed_out` first, then
// dispatch on `channel_index` to determine which channel produced the value.
struct SelectResult {
    channel_index: i64,
    value: i64,
    timed_out: bool,
}

// =============================================================================
// Task - spawned green thread handle
// =============================================================================

class Task<T: Sendable> {
    _handle: handle,

    statics {
        // Spawn a task from a closure. The closure runs on the M:1 scheduler.
        // Returns a Task handle for join/cancel operations.
        func run(body: () -> T) -> Task<T> {
            return Task<T> { _handle: _task_run(body) }
        }

        // Create a streaming iterator backed by a producer task.
        // The producer receives an `emit` callback to send values.
        // The returned iterator yields values until the producer finishes.
        //
        // Example:
        //   let s = Task.stream((emit: (i64) -> void) => {
        //       emit(1)
        //       emit(2)
        //       emit(3)
        //   })
        //   for v in s { println(v) }
        func stream(producer: ((T) -> void) -> void) -> Iterator<T> {
            let ch = Channel<T> { _ptr: _channel_new(1) }
            let task = Task.run<i64>(() -> i64 => {
                producer((value: T) => {
                    _ = ch.send(value)
                })
                ch.close()
                return 0
            })
            return StreamIterator<T> { _ch: ch._ptr, _task: task._handle }
        }

        // Create a stateful actor backed by a task and channel.
        // The actor owns mutable state, receives i64 messages through a
        // channel, and applies the handler to update the state.
        //
        // Example:
        //   let counter = Task.state(0, (count: i64, msg: i64) -> i64 => {
        //       return count + msg
        //   })
        //   counter.send(1)
        //   counter.send(1)
        //   let final_count = counter.close_and_join()
        //   assert(final_count == 2)
        func state(initial: i64, handler: (i64, i64) -> i64) -> StateActor {
            let ch = Channel<i64> { _ptr: _channel_new(8) }
            let task = Task.run<i64>(() -> i64 => {
                let mut current = initial
                let mut r = _channel_recv(ch._ptr)
                while r.tag != -1 {
                    current = handler(current, r.value)
                    r = _channel_recv(ch._ptr)
                }
                return current
            })
            return StateActor { _ch: ch._ptr, _task: task._handle }
        }

        // Wait on two channels simultaneously, returning when the first
        // channel becomes ready or the timeout expires.
        //
        // `timeout_nanos` is the maximum wait in nanoseconds (0 = no timeout).
        // Returns a SelectResult with:
        //   - channel_index: 0 or 1 (which channel has data)
        //   - value: the received value from that channel
        //   - timed_out: true if the timeout expired before any channel was ready
        //
        // Example:
        //   let result = Task.select2(ch1, ch2, 0)
        //   if result.timed_out { println("timeout") }
        //   else if result.channel_index == 0 { handle(result.value) }
        func select2(ch1: Channel<i64>, ch2: Channel<i64>, timeout_nanos: i64) -> SelectResult {
            let idx = _task_select2(ch1._ptr, ch2._ptr, timeout_nanos)
            if idx == -1 {
                return SelectResult { channel_index: -1, value: 0, timed_out: true }
            }
            let value = when {
                idx == 0 => ch1.receive(),
                _ => ch2.receive(),
            }
            return SelectResult { channel_index: idx, value: value, timed_out: false }
        }

        // Wait on three channels simultaneously, returning when the first
        // channel becomes ready or the timeout expires.
        //
        // `timeout_nanos` is the maximum wait in nanoseconds (0 = no timeout).
        // Returns a SelectResult with channel_index 0, 1, or 2.
        func select3(ch1: Channel<i64>, ch2: Channel<i64>, ch3: Channel<i64>, timeout_nanos: i64) -> SelectResult {
            let idx = _task_select3(ch1._ptr, ch2._ptr, ch3._ptr, timeout_nanos)
            if idx == -1 {
                return SelectResult { channel_index: -1, value: 0, timed_out: true }
            }
            let value = when {
                idx == 0 => ch1.receive(),
                idx == 1 => ch2.receive(),
                _ => ch3.receive(),
            }
            return SelectResult { channel_index: idx, value: value, timed_out: false }
        }

        // Fan-out: spawn one task per closure and collect all results.
        // Results are returned in the same order as the input closures.
        func all(fns: [() -> T]) -> [T] {
            // Spawn all tasks first.
            let tasks: [Task<T>] = []
            let mut i = 0
            while i < fns.length() {
                tasks.push(Task.run(fns[i]))
                i = i + 1
            }

            // Join all tasks and collect results in order.
            let results: [T] = []
            let mut j = 0
            while j < tasks.length() {
                results.push(tasks[j].join())
                j = j + 1
            }
            return results
        }

        // Transform all items and collect results.
        func parallel(items: [T], transform: (T) -> T) -> [T] {
            let fns: [() -> T] = []
            let mut i = 0
            while i < items.length() {
                let item = items[i]
                fns.push(() -> T => { return transform(item) })
                i = i + 1
            }
            return Task.all(fns)
        }

    }

    // Block until the task completes and return its result.
    // Panics if the task was cancelled or panicked.
    // NOTE: codegen intercepts this method and emits inline tag extraction.
    // The body below is a fallback that is never called at runtime.
    func join() -> T {
        return panic("Task.join should be codegen-intercepted")
    }

    // Request cooperative cancellation of the task.
    // If the task is already completed, this is a no-op.
    func cancel() {
        _task_cancel(self._handle)
    }

    // Check if the task has completed (or was cancelled).
    func is_done() -> bool {
        return _task_is_done(self._handle) == 1
    }
}

// =============================================================================
// Channel - communication channel between tasks
// =============================================================================

class Channel<T: Sendable> {
    _ptr: handle,

    statics {
        // Create an unbuffered (rendezvous) channel.
        func new() -> Channel<T> {
            return Channel<T> { _ptr: _channel_new(0) }
        }

        // Create a buffered channel with the given capacity.
        func buffered(capacity: i64) -> Channel<T> {
            return Channel<T> { _ptr: _channel_new(capacity) }
        }
    }

    // Send a value on the channel.
    // Returns true on success, false if the channel is closed.
    // NOTE: codegen intercepts this method and emits the correct RuntimeTypeId
    // tag based on the element type.
    func send(value: T) -> bool {
        _ = value
        return false
    }

    // Receive a value from the channel.
    // NOTE: codegen intercepts this method and extracts the typed value
    // from the RecvResult struct return.
    func receive() -> T {
        return panic("Channel.receive should be codegen-intercepted")
    }

    // Try to receive one value from the channel.
    // Returns `Done` when the channel is closed and empty.
    // NOTE: codegen intercepts this method and builds `T | Done` directly.
    func try_receive() -> T | Done {
        return Done {}
    }

    // Close the channel. Wakes all waiting tasks.
    // Double-close is a no-op.
    func close() {
        _channel_close(self._ptr)
    }

    // Check if the channel is closed.
    func is_closed() -> bool {
        return _channel_is_closed(self._ptr) == 1
    }

    // Return an iterator that drains the channel.
    // Yields values until the channel is closed and empty.
    func iter() -> Iterator<T> {
        return ChannelIterator<T> { _ptr: self._ptr }
    }
}

// =============================================================================
// ChannelIterator - drains a channel via the Iterator interface
// =============================================================================

class ChannelIterator<T: Sendable> implements Iterator<T> {
    _ptr: handle,
}

implement Iterator<T> for ChannelIterator<T> {
    func next() -> T | Done {
        let ch = Channel<T> { _ptr: self._ptr }
        return ch.try_receive()
    }
}

// =============================================================================
// StreamIterator - drains a Task.stream's channel, keeping the task alive
// =============================================================================

class StreamIterator<T: Sendable> implements Iterator<T> {
    _ch: handle,
    _task: handle,
}

implement Iterator<T> for StreamIterator<T> {
    func next() -> T | Done {
        let ch = Channel<T> { _ptr: self._ch }
        return ch.try_receive()
    }
}

// =============================================================================
// StateActor - stateful actor backed by a task and channel
// =============================================================================

class StateActor {
    _ch: handle,
    _task: handle,

    // Send a message to the actor.
    // The actor's handler will be called with (current_state, msg).
    func send(msg: i64) {
        _ = _channel_send(self._ch, 2, msg)
    }

    // Close the channel and wait for the actor task to finish.
    // Returns the actor's final state.
    func close_and_join() -> i64 {
        _channel_close(self._ch)
        let r = _task_join(self._task)
        return r.value
    }
}

// Process array items concurrently using up to `max` worker tasks.
// Each item from `items` is passed through `transform` in a worker task.
// Returns the transformed results as an array.
//
// NOTE: Output order is NOT guaranteed to match input order.
//
// Example:
//   let results = parallel([1, 2, 3, 4], 2, (x: i64) -> i64 => {
//       return x * 10
//   })
//   // results contains [10, 20, 30, 40] in some order
func parallel(items: [i64], max: i64, transform: (i64) -> i64) -> [i64] {
    _ = max
    return Task.parallel<i64>(items, transform)
}
