// stdlib/time.vole
// Time handling module with Duration and Timestamp types
//
// Duration: Represents a span of time (can be positive or negative)
// Timestamp: Represents a point in time with timezone offset
//
// Example usage:
//   let time = import "std:time"
//   let d = time.Duration.seconds(5)
//   let d2 = d.add(time.Duration.ms(100))
//   let t = time.Timestamp.now()
//   let iso = t.to_iso()
//
// Or with destructuring:
//   let { Duration, Timestamp } = import "std:time"
//   let d = Duration.seconds(5)
//   let t = Timestamp.now()

// Native functions for complex time operations
external("std:time") {
    // Get current time as nanoseconds since Unix epoch
    func time_now() -> i64

    // Parse ISO 8601 string, returns nanos since epoch or i64.min_value() on error
    func time_parse_iso(iso: string) -> i64

    // Format timestamp as ISO 8601 string
    func time_to_iso(nanos: i64, offset_mins: i64) -> string

    // Add months to timestamp (calendar math)
    func time_add_months(nanos: i64, months: i64) -> i64

    // Add years to timestamp (calendar math)
    func time_add_years(nanos: i64, years: i64) -> i64

    // Get date components from timestamp (returns packed i64: year<<32 | month<<16 | day)
    func time_get_date(nanos: i64, offset_mins: i64) -> i64

    // Get time components from timestamp (returns packed i64: hour<<32 | minute<<16 | second)
    func time_get_time(nanos: i64, offset_mins: i64) -> i64
}

// =============================================================================
// Duration - represents a time span in nanoseconds
// =============================================================================

record Duration {
    nanos: i64,

    statics {
        // Constructors
        func nanos(n: i64) -> Duration {
            return Duration { nanos: n }
        }

        func micros(n: i64) -> Duration {
            return Duration { nanos: n * 1000 }
        }

        func ms(n: i64) -> Duration {
            return Duration { nanos: n * 1000000 }
        }

        func seconds(n: i64) -> Duration {
            return Duration { nanos: n * 1000000000 }
        }

        func minutes(n: i64) -> Duration {
            return Duration { nanos: n * 60 * 1000000000 }
        }

        func hours(n: i64) -> Duration {
            return Duration { nanos: n * 3600 * 1000000000 }
        }

        func days(n: i64) -> Duration {
            return Duration { nanos: n * 86400 * 1000000000 }
        }

        func weeks(n: i64) -> Duration {
            return Duration { nanos: n * 604800 * 1000000000 }
        }

        func zero() -> Duration {
            return Duration { nanos: 0 }
        }
    }

    // Getters (convert to different units)
    func as_nanos() -> i64 {
        return self.nanos
    }

    func as_micros() -> i64 {
        return self.nanos / 1000
    }

    func as_ms() -> i64 {
        return self.nanos / 1000000
    }

    func as_seconds() -> i64 {
        return self.nanos / 1000000000
    }

    func as_minutes() -> i64 {
        return self.nanos / 60000000000
    }

    func as_hours() -> i64 {
        return self.nanos / 3600000000000
    }

    func as_days() -> i64 {
        return self.nanos / 86400000000000
    }

    // Arithmetic
    func add(other: Duration) -> Duration {
        return Duration { nanos: self.nanos + other.nanos }
    }

    func subtract(other: Duration) -> Duration {
        return Duration { nanos: self.nanos - other.nanos }
    }

    func multiply(n: i64) -> Duration {
        return Duration { nanos: self.nanos * n }
    }

    func divide(n: i64) -> Duration {
        return Duration { nanos: self.nanos / n }
    }

    // Utilities
    func abs() -> Duration {
        if self.nanos < 0 {
            return Duration { nanos: -self.nanos }
        }
        return Duration { nanos: self.nanos }
    }

    func is_negative() -> bool {
        return self.nanos < 0
    }

    func is_zero() -> bool {
        return self.nanos == 0
    }

    func is_positive() -> bool {
        return self.nanos > 0
    }

    func negate() -> Duration {
        return Duration { nanos: -self.nanos }
    }
}

// =============================================================================
// Timestamp - represents a point in time
// =============================================================================

record Timestamp {
    nanos: i64,
    offset_mins: i64,

    statics {
        // Constructors
        func now() -> Timestamp {
            return Timestamp { nanos: time_now(), offset_mins: 0 }
        }

        func from_unix(secs: i64) -> Timestamp {
            return Timestamp { nanos: secs * 1000000000, offset_mins: 0 }
        }

        func from_unix_ms(ms: i64) -> Timestamp {
            return Timestamp { nanos: ms * 1000000, offset_mins: 0 }
        }

        func parse(iso: string) -> Timestamp | nil {
            let nanos = time_parse_iso(iso)
            // i64.min_value() is used as sentinel for parse error
            if nanos == -9223372036854775807 - 1 {
                return nil
            }
            return Timestamp { nanos: nanos, offset_mins: 0 }
        }

        func from_parts(year: i64, month: i64, day: i64, hour: i64, minute: i64, second: i64) -> Timestamp | nil {
            // Build an ISO string and parse it
            let month_str = when { month < 10 => "0{month}", _ => "{month}" }
            let day_str = when { day < 10 => "0{day}", _ => "{day}" }
            let hour_str = when { hour < 10 => "0{hour}", _ => "{hour}" }
            let minute_str = when { minute < 10 => "0{minute}", _ => "{minute}" }
            let second_str = when { second < 10 => "0{second}", _ => "{second}" }
            let iso = "{year}-{month_str}-{day_str}T{hour_str}:{minute_str}:{second_str}Z"
            return Timestamp.parse(iso)
        }

        func epoch() -> Timestamp {
            return Timestamp { nanos: 0, offset_mins: 0 }
        }
    }

    // Getters
    func unix() -> i64 {
        return self.nanos / 1000000000
    }

    func unix_ms() -> i64 {
        return self.nanos / 1000000
    }

    func unix_nanos() -> i64 {
        return self.nanos
    }

    func offset() -> i64 {
        return self.offset_mins
    }

    func with_offset(offset_mins: i64) -> Timestamp {
        return Timestamp { nanos: self.nanos, offset_mins: offset_mins }
    }

    // Date components
    func year() -> i64 {
        let packed = time_get_date(self.nanos, self.offset_mins)
        return packed >> 32
    }

    func month() -> i64 {
        let packed = time_get_date(self.nanos, self.offset_mins)
        return (packed >> 16) & 0xFFFF
    }

    func day() -> i64 {
        let packed = time_get_date(self.nanos, self.offset_mins)
        return packed & 0xFFFF
    }

    // Time components
    func hour() -> i64 {
        let packed = time_get_time(self.nanos, self.offset_mins)
        return packed >> 32
    }

    func minute() -> i64 {
        let packed = time_get_time(self.nanos, self.offset_mins)
        return (packed >> 16) & 0xFFFF
    }

    func second() -> i64 {
        let packed = time_get_time(self.nanos, self.offset_mins)
        return packed & 0xFFFF
    }

    // Arithmetic
    func add(d: Duration) -> Timestamp {
        return Timestamp { nanos: self.nanos + d.nanos, offset_mins: self.offset_mins }
    }

    func subtract(d: Duration) -> Timestamp {
        return Timestamp { nanos: self.nanos - d.nanos, offset_mins: self.offset_mins }
    }

    func since(other: Timestamp) -> Duration {
        return Duration { nanos: self.nanos - other.nanos }
    }

    func distance(other: Timestamp) -> Duration {
        let diff = self.nanos - other.nanos
        if diff < 0 {
            return Duration { nanos: -diff }
        }
        return Duration { nanos: diff }
    }

    // Calendar arithmetic
    func add_days(n: i64) -> Timestamp {
        return Timestamp { nanos: self.nanos + n * 86400000000000, offset_mins: self.offset_mins }
    }

    func add_months(n: i64) -> Timestamp {
        let new_nanos = time_add_months(self.nanos, n)
        return Timestamp { nanos: new_nanos, offset_mins: self.offset_mins }
    }

    func add_years(n: i64) -> Timestamp {
        let new_nanos = time_add_years(self.nanos, n)
        return Timestamp { nanos: new_nanos, offset_mins: self.offset_mins }
    }

    // Formatting
    func to_iso() -> string {
        return time_to_iso(self.nanos, self.offset_mins)
    }

    // Comparisons
    func is_before(other: Timestamp) -> bool {
        return self.nanos < other.nanos
    }

    func is_after(other: Timestamp) -> bool {
        return self.nanos > other.nanos
    }

    func equals(other: Timestamp) -> bool {
        return self.nanos == other.nanos
    }
}
