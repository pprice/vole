// stdlib/prelude/iterators.vole
//
// Iterator factory functions and Iterable implementations for built-in types.

let { Iterator, Iterable } = import "./traits"

external("vole:std:runtime") {
    // repeat(value) - creates an infinite iterator yielding the same value
    // WARNING: Must use with take() or similar to avoid infinite loops
    // Example: repeat(42).take(3).collect() => [42, 42, 42]
    func "iter_repeat" as repeat(value: i64) -> Iterator<i64>

    // once(value) - creates an iterator that yields exactly one value
    // Example: once(42).collect() => [42]
    func "iter_once" as once(value: i64) -> Iterator<i64>

    // empty() - creates an iterator that yields nothing
    // Example: empty().collect() => []
    func "iter_empty" as empty() -> Iterator<i64>

    // from_fn(f) - creates an iterator from a generator function
    // The function should return T? - when it returns nil, iteration ends
    // Example:
    //   var n = 0
    //   from_fn(() => { n = n + 1; if n <= 3 { return n } else { return nil } }).collect()
    //   => [1, 2, 3]
    func "iter_from_fn" as from_fn(generator: () -> i64?) -> Iterator<i64>
}

// Register range as implementing Iterable<i64> so that Iterable default methods
// (map, filter, count, collect, etc.) are available directly on range values.
// Example: (0..10).count()  =>  10
//          (1..5).collect() =>  [1, 2, 3, 4]
extend range with Iterable<i64> {
    external("vole:std:runtime") {
        func "range_iter" as iter() -> Iterator<i64>
    }
}

// Register [T] as implementing Iterable<T> so that Iterable default methods
// (map, filter, count, collect, etc.) are available directly on array values.
// Example: [1, 2, 3].count()        =>  3
//          [1, 2, 3].map((x) => x*2) =>  [2, 4, 6]
extend [T] with Iterable<T> {
    external("vole:std:runtime") {
        func "array_iter" as iter() -> Iterator<T>
    }
}
