// stdlib/prelude/traits.vole
// Core trait definitions for Vole

// Static interfaces - methods called on types, not instances

interface Default {
    statics {
        func default_value() -> Self
    }
}

interface Bounded {
    statics {
        func min_value() -> Self
        func max_value() -> Self
    }
}



// Float constant interface - provides special float values
// These are compiled directly to constants by the codegen (no function call)
interface FloatConstants {
    statics {
        func nan() -> Self
        func infinity() -> Self
        func neg_infinity() -> Self
        func epsilon() -> Self
    }
}

// Instance interfaces

interface Equatable {
    func equals(other: Self) -> bool
}

interface Comparable {
    func compare(other: Self) -> i32

    default func lt(other: Self) -> bool { return self.compare(other) < 0 }
    default func gt(other: Self) -> bool { return self.compare(other) > 0 }
    default func lte(other: Self) -> bool { return self.compare(other) <= 0 }
    default func gte(other: Self) -> bool { return self.compare(other) >= 0 }
}

interface Hashable {
    func hash() -> i64
}

interface Stringable {
    func to_string() -> string
}

interface Transferable {
    func transfer() -> Self
}

interface Iterator<T> {
    func next() -> T | Done
    func map(f: (T) -> T) -> Iterator<T>
    func filter(pred: (T) -> bool) -> Iterator<T>
    func take(n: i64) -> Iterator<T>
    func skip(n: i64) -> Iterator<T>
    func collect() -> [T]
    func for_each(f: (T) -> void) -> void
    func reduce(init: T, f: (T, T) -> T) -> T
    func count() -> i64
    func sum() -> T
    func first() -> T?
    func last() -> T?
    func nth(n: i64) -> T?
    func find(pred: (T) -> bool) -> T?
    func any(pred: (T) -> bool) -> bool
    func all(pred: (T) -> bool) -> bool
    func chain(other: Iterator<T>) -> Iterator<T>
    func flatten() -> Iterator<T>
    func flat_map(f: (T) -> [T]) -> Iterator<T>
    func reverse() -> Iterator<T>
    func sorted() -> Iterator<T>
    func unique() -> Iterator<T>
    func chunks(size: i64) -> Iterator<[T]>
    func windows(size: i64) -> Iterator<[T]>
    func enumerate() -> Iterator<[i64, T]>
    func zip(other: Iterator<T>) -> Iterator<[T, T]>

    default external("vole:std:runtime") {
        func "iter_next" as next() -> T | Done
        func "iter_map" as map(f: (T) -> T) -> Iterator<T>
        func "iter_filter" as filter(pred: (T) -> bool) -> Iterator<T>
        func "iter_take" as take(n: i64) -> Iterator<T>
        func "iter_skip" as skip(n: i64) -> Iterator<T>
        func "iter_collect" as collect() -> [T]
        func "iter_for_each" as for_each(f: (T) -> void) -> void
        func "iter_reduce" as reduce(init: T, f: (T, T) -> T) -> T
        func "iter_count" as count() -> i64
        func "iter_sum" as sum() -> T
        func "iter_first" as first() -> T?
        func "iter_last" as last() -> T?
        func "iter_nth" as nth(n: i64) -> T?
        func "iter_find" as find(pred: (T) -> bool) -> T?
        func "iter_any" as any(pred: (T) -> bool) -> bool
        func "iter_all" as all(pred: (T) -> bool) -> bool
        func "iter_chain" as chain(other: Iterator<T>) -> Iterator<T>
        func "iter_flatten" as flatten() -> Iterator<T>
        func "iter_flat_map" as flat_map(f: (T) -> [T]) -> Iterator<T>
        func "iter_reverse" as reverse() -> Iterator<T>
        func "iter_sorted" as sorted() -> Iterator<T>
        func "iter_unique" as unique() -> Iterator<T>
        func "iter_chunks" as chunks(size: i64) -> Iterator<[T]>
        func "iter_windows" as windows(size: i64) -> Iterator<[T]>
        func "iter_enumerate" as enumerate() -> Iterator<[i64, T]>
        func "iter_zip" as zip(other: Iterator<T>) -> Iterator<[T, T]>
    }
}

interface Iterable<T> {
    func iter() -> Iterator<T>

    // Transforming — lazy, return Iterator<T>
    default func map(f: (T) -> T) -> Iterator<T> => self.iter().map(f)
    default func filter(pred: (T) -> bool) -> Iterator<T> => self.iter().filter(pred)
    default func take(n: i64) -> Iterator<T> => self.iter().take(n)
    default func skip(n: i64) -> Iterator<T> => self.iter().skip(n)
    default func enumerate() -> Iterator<[i64, T]> => self.iter().enumerate()
    default func zip(other: Iterator<T>) -> Iterator<[T, T]> => self.iter().zip(other)
    default func chain(other: Iterator<T>) -> Iterator<T> => self.iter().chain(other)
    default func reverse() -> Iterator<T> => self.iter().reverse()
    default func flatten() -> Iterator<T> => self.iter().flatten()
    default func flat_map(f: (T) -> [T]) -> Iterator<T> => self.iter().flat_map(f)
    default func sorted() -> Iterator<T> => self.iter().sorted()
    default func unique() -> Iterator<T> => self.iter().unique()
    default func chunks(n: i64) -> Iterator<[T]> => self.iter().chunks(n)
    default func windows(n: i64) -> Iterator<[T]> => self.iter().windows(n)

    // Consuming — eager, return a value
    default func collect() -> [T] => self.iter().collect()
    default func reduce(init: T, f: (T, T) -> T) -> T => self.iter().reduce(init, f)
    default func for_each(f: (T) -> void) -> void => self.iter().for_each(f)
    default func count() -> i64 => self.iter().count()
    default func sum() -> T => self.iter().sum()
    default func find(pred: (T) -> bool) -> T? => self.iter().find(pred)
    default func first() -> T? => self.iter().first()
    default func last() -> T? => self.iter().last()
    default func nth(n: i64) -> T? => self.iter().nth(n)
    default func any(pred: (T) -> bool) -> bool => self.iter().any(pred)
    default func all(pred: (T) -> bool) -> bool => self.iter().all(pred)
}

// Read-only collection interfaces for polymorphic access

interface MapLike<K, V> {
    func get(key: K) -> V?
    func contains_key(key: K) -> bool
    func len() -> i64
    func is_empty() -> bool
    func keys() -> Iterator<K>
    func values() -> Iterator<V>
    func entries() -> Iterator<[K, V]>
}

interface SetLike<T> {
    func contains(value: T) -> bool
    func len() -> i64
    func is_empty() -> bool
}
