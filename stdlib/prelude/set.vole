// stdlib/prelude/set.vole
//
// Set<T> - Generic hash set collection
//
// T must implement Hashable (for hashing) and Equatable (for element comparison).

let { SetLike, Iterator } = import "./traits"

class Set<T: Hashable + Equatable> implements SetLike<T> {
    _ptr: handle,  // Pointer to native VoleSet

    statics {
        func new() -> Set<T> {
            let eq_fn = (a: T, b: T) -> bool => a.equals(b)
            return Set { _ptr: _set_new_with_eq(eq_fn) }
        }

        func with_capacity(capacity: i64) -> Set<T> {
            let eq_fn = (a: T, b: T) -> bool => a.equals(b)
            return Set { _ptr: _set_with_capacity_eq(capacity, eq_fn) }
        }
    }

    func contains(value: T) -> bool {
        return _set_contains(self._ptr, value, value.hash())
    }

    func len() -> i64 {
        return _set_len(self._ptr)
    }

    func is_empty() -> bool {
        return _set_len(self._ptr) == 0
    }

    func iter() -> Iterator<T> {
        return _set_iter(self._ptr)
    }

    func add(value: T) -> bool {
        return _set_add(self._ptr, value, value.hash())
    }

    func remove(value: T) -> bool {
        return _set_remove(self._ptr, value, value.hash())
    }

    func clear() {
        _set_clear(self._ptr)
    }

    func union(other: Set<T>) -> Set<T> {
        return Set { _ptr: _set_union(self._ptr, other._ptr) }
    }

    func intersection(other: Set<T>) -> Set<T> {
        return Set { _ptr: _set_intersection(self._ptr, other._ptr) }
    }

    func difference(other: Set<T>) -> Set<T> {
        return Set { _ptr: _set_difference(self._ptr, other._ptr) }
    }

    func symmetric_difference(other: Set<T>) -> Set<T> {
        return Set { _ptr: _set_symmetric_difference(self._ptr, other._ptr) }
    }

    func is_subset(other: Set<T>) -> bool {
        return _set_is_subset(self._ptr, other._ptr)
    }

    func is_superset(other: Set<T>) -> bool {
        return _set_is_superset(self._ptr, other._ptr)
    }

    func is_disjoint(other: Set<T>) -> bool {
        return _set_is_disjoint(self._ptr, other._ptr)
    }
}

// Module-level native functions with generic type params for type erasure
external("std:collections") {
    func "set_new_with_eq" as _set_new_with_eq<T>(eq_closure: (T, T) -> bool) -> handle
    func "set_with_capacity_eq" as _set_with_capacity_eq<T>(capacity: i64, eq_closure: (T, T) -> bool) -> handle
    func "set_add" as _set_add<T>(ptr: handle, value: T, hash: i64) -> bool
    func "set_remove" as _set_remove<T>(ptr: handle, value: T, hash: i64) -> bool
    func "set_contains" as _set_contains<T>(ptr: handle, value: T, hash: i64) -> bool
    func "set_len" as _set_len(ptr: handle) -> i64
    func "set_clear" as _set_clear(ptr: handle) -> void
    func "set_iter" as _set_iter<T>(ptr: handle) -> Iterator<T>
    func "set_union" as _set_union(ptr: handle, other: handle) -> handle
    func "set_intersection" as _set_intersection(ptr: handle, other: handle) -> handle
    func "set_difference" as _set_difference(ptr: handle, other: handle) -> handle
    func "set_symmetric_difference" as _set_symmetric_difference(ptr: handle, other: handle) -> handle
    func "set_is_subset" as _set_is_subset(ptr: handle, other: handle) -> bool
    func "set_is_superset" as _set_is_superset(ptr: handle, other: handle) -> bool
    func "set_is_disjoint" as _set_is_disjoint(ptr: handle, other: handle) -> bool
}
