// stdlib/collections/set.vole
//
// Set<T> - Pure Vole generic hash set
//
// Open addressing with linear probing, power-of-2 table sizes, 70% load factor.
// T must implement Hashable (for hashing) and Equatable (for element comparison).

let { Array } = import "std:array"

sentinel Empty
sentinel Deleted

class SetEntry<T> {
    value: T,
}

class Set<T: Hashable + Equatable> {
    buckets: [SetEntry<T> | Empty | Deleted],
    size: i64,
    tomb_count: i64,

    statics {
        func new() -> Set<T> {
            return Set.with_capacity<T>(8)
        }

        func with_capacity(capacity: i64) -> Set<T> {
            let cap = Set.next_power_of_2(capacity)
            let buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
            return Set {
                buckets: buckets,
                size: 0,
                tomb_count: 0,
            }
        }

        func next_power_of_2(n: i64) -> i64 {
            if n <= 8 {
                return 8
            }

            let mut power = 8
            while power < n {
                power = power * 2
            }
            return power
        }
    }

    func add(value: T) -> bool {
        if self.needs_rehash() {
            self.rehash()
        }

        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.add_on_entry(existing, value)
            Empty => self.add_on_empty(idx, value)
            Deleted => self.add_on_deleted(idx, value)
        }
    }

    func contains(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => existing.equals(value)
            Empty => false
            Deleted => false
        }
    }

    func remove(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.remove_entry(idx, existing, value)
            Empty => false
            Deleted => false
        }
    }

    func clear() {
        let cap = self.buckets.length()
        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
        self.size = 0
        self.tomb_count = 0
    }

    func len() -> i64 {
        return self.size
    }

    func is_empty() -> bool {
        // Work around generic self-field comparison issue by using a local first.
        let s = self.size
        return s == 0
    }

    func find_slot(value: T) -> i64 {
        let cap = self.buckets.length()
        let mut idx = value.hash() & (cap - 1)
        let mut first_deleted = -1
        let mut probes = 0

        while probes < cap {
            let bucket = self.buckets[idx]

            let mut same_value = false
            let mut saw_deleted = false
            let mut saw_empty = false

            match bucket {
                SetEntry { value: existing } => same_value = existing.equals(value)
                Deleted => saw_deleted = true
                Empty => saw_empty = true
            }

            if same_value {
                return idx
            } else if saw_deleted {
                if first_deleted == -1 {
                    first_deleted = idx
                }
            } else if saw_empty {
                if first_deleted != -1 {
                    return first_deleted
                }
                return idx
            }

            idx = (idx + 1) & (cap - 1)
            probes = probes + 1
        }

        if first_deleted != -1 {
            return first_deleted
        }

        return idx
    }

    func needs_rehash() -> bool {
        let cap = self.buckets.length()
        let used = self.size + self.tomb_count
        return (used * 100) / cap > 70
    }

    func rehash() {
        let old_buckets = self.buckets
        let old_cap = old_buckets.length()
        let new_cap = old_cap * 2

        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(new_cap, Empty)
        self.size = 0
        self.tomb_count = 0

        for bucket in old_buckets {
            match bucket {
                SetEntry { value } => self.insert_no_rehash(value)
                Empty => self.rehash_noop()
                Deleted => self.rehash_noop()
            }
        }
    }

    func rehash_noop() {
        let _x = 0
    }

    func insert_no_rehash(value: T) {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        match bucket {
            SetEntry { value: existing } => self.insert_on_entry(idx, existing, value)
            Empty => self.insert_on_empty(idx, value)
            Deleted => self.insert_on_deleted(idx, value)
        }
    }

    func insert_on_empty(idx: i64, value: T) {
        self.write_entry(idx, value)
        self.size = self.size + 1
    }

    func insert_on_deleted(idx: i64, value: T) {
        self.write_entry(idx, value)
        self.size = self.size + 1
        self.tomb_count = self.tomb_count - 1
    }

    func add_on_entry(existing: T, value: T) -> bool {
        if existing.equals(value) {
            return false
        }
        return false
    }

    func insert_on_entry(idx: i64, existing: T, value: T) {
        if !existing.equals(value) {
            self.write_entry(idx, value)
        }
    }

    func write_entry(idx: i64, value: T) {
        self.buckets[idx] = SetEntry { value: value }
    }

    func add_on_empty(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        return true
    }

    func add_on_deleted(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        self.tomb_count = self.tomb_count - 1
        return true
    }

    func remove_entry(idx: i64, existing: T, value: T) -> bool {
        if !existing.equals(value) {
            return false
        }

        self.buckets[idx] = Deleted
        self.size = self.size - 1
        self.tomb_count = self.tomb_count + 1
        return true
    }

    func union(other: Set<T>) -> Set<T> {
        let result = Set.new<T>()
        for v in self.iter() { _ = result.add(v) }
        for v in other.iter() { _ = result.add(v) }
        return result
    }

    func intersection(other: Set<T>) -> Set<T> {
        let result = Set.new<T>()
        for v in self.iter() {
            if other.contains(v) { _ = result.add(v) }
        }
        return result
    }

    func difference(other: Set<T>) -> Set<T> {
        let result = Set.new<T>()
        for v in self.iter() {
            if !other.contains(v) { _ = result.add(v) }
        }
        return result
    }

    func symmetric_difference(other: Set<T>) -> Set<T> {
        let result = Set.new<T>()
        for v in self.iter() {
            if !other.contains(v) { _ = result.add(v) }
        }
        for v in other.iter() {
            if !self.contains(v) { _ = result.add(v) }
        }
        return result
    }

    func is_subset(other: Set<T>) -> bool {
        for v in self.iter() {
            if !other.contains(v) { return false }
        }
        return true
    }

    func is_superset(other: Set<T>) -> bool {
        return other.is_subset(self)
    }

    func is_disjoint(other: Set<T>) -> bool {
        for v in self.iter() {
            if other.contains(v) { return false }
        }
        return true
    }

    func iter() -> Iterator<T> {
        return SetIterator {
            buckets: self.buckets,
            index: 0,
        }
    }
}

class SetIterator<T> implements Iterator<T> {
    buckets: [SetEntry<T> | Empty | Deleted],
    index: i64,
}

implement Iterator<T> for SetIterator<T> {
    func next() -> T | Done {
        while self.index < self.buckets.length() {
            let bucket = self.buckets[self.index]
            self.index = self.index + 1
            let mut found = false
            match bucket {
                SetEntry { value } => found = true
                Empty => found = false
                Deleted => found = false
            }
            if found {
                return match bucket {
                    SetEntry { value } => value
                    Empty => Done {}
                    Deleted => Done {}
                }
            }
        }
        return Done {}
    }
}
