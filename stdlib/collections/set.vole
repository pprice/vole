// stdlib/collections/set.vole
// Pure Vole Set<T> using open addressing with linear probing.

let { Array } = import "std:array"
let { Empty, Deleted } = import "std:collections/sentinels"

class SetEntry<T> {
    value: T,
}

class Set<T: Hashable + Equatable> {
    buckets: [SetEntry<T> | Empty | Deleted],
    size: i64,
    tomb_count: i64,

    statics {
        func new() -> Set<T> {
            return Set.with_capacity<T>(8)
        }

        func with_capacity(capacity: i64) -> Set<T> {
            let cap = Set.next_power_of_2(capacity)
            let buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
            return Set {
                buckets: buckets,
                size: 0,
                tomb_count: 0,
            }
        }

        func next_power_of_2(n: i64) -> i64 {
            if n <= 8 {
                return 8
            }

            let mut power = 8
            while power < n {
                power = power * 2
            }
            return power
        }
    }

    func add(value: T) -> bool {
        if self.needs_rehash() {
            self.rehash()
        }

        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.add_on_entry(existing, value)
            Empty => self.add_on_empty(idx, value)
            Deleted => self.add_on_deleted(idx, value)
        }
    }

    func contains(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => existing.equals(value)
            Empty => false
            Deleted => false
        }
    }

    func remove(value: T) -> bool {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        return match bucket {
            SetEntry { value: existing } => self.remove_entry(idx, existing, value)
            Empty => false
            Deleted => false
        }
    }

    func clear() {
        let cap = self.buckets.length()
        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(cap, Empty)
        self.size = 0
        self.tomb_count = 0
    }

    func len() -> i64 {
        return self.size
    }

    func is_empty() -> bool {
        // Work around generic self-field comparison issue by using a local first.
        let s = self.size
        return s == 0
    }

    func find_slot(value: T) -> i64 {
        let cap = self.buckets.length()
        let mut idx = value.hash() & (cap - 1)
        let mut first_deleted = -1
        let mut probes = 0

        while probes < cap {
            let bucket = self.buckets[idx]

            let mut same_value = false
            let mut saw_deleted = false
            let mut saw_empty = false

            match bucket {
                SetEntry { value: existing } => same_value = existing.equals(value)
                Deleted => saw_deleted = true
                Empty => saw_empty = true
            }

            if same_value {
                return idx
            } else if saw_deleted {
                if first_deleted == -1 {
                    first_deleted = idx
                }
            } else if saw_empty {
                if first_deleted != -1 {
                    return first_deleted
                }
                return idx
            }

            idx = (idx + 1) & (cap - 1)
            probes = probes + 1
        }

        if first_deleted != -1 {
            return first_deleted
        }

        return idx
    }

    func needs_rehash() -> bool {
        let cap = self.buckets.length()
        let used = self.size + self.tomb_count
        return (used * 100) / cap > 70
    }

    func rehash() {
        let old_buckets = self.buckets
        let old_cap = old_buckets.length()
        let new_cap = old_cap * 2

        self.buckets = Array.filled<SetEntry<T> | Empty | Deleted>(new_cap, Empty)
        self.size = 0
        self.tomb_count = 0

        for bucket in old_buckets {
            match bucket {
                SetEntry { value } => self.insert_no_rehash(value)
                Empty => 0
                Deleted => 0
            }
        }
    }

    func insert_no_rehash(value: T) {
        let idx = self.find_slot(value)
        let bucket = self.buckets[idx]

        match bucket {
            SetEntry { value: existing } => self.insert_on_entry(idx, existing, value)
            Empty => self.add_on_empty(idx, value)
            Deleted => self.add_on_deleted(idx, value)
        }
    }

    func add_on_entry(existing: T, value: T) -> bool {
        if existing.equals(value) {
            return false
        }
        return false
    }

    func insert_on_entry(idx: i64, existing: T, value: T) {
        if !existing.equals(value) {
            self.write_entry(idx, value)
        }
    }

    func write_entry(idx: i64, value: T) {
        self.buckets[idx] = SetEntry { value: value }
    }

    func add_on_empty(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        return true
    }

    func add_on_deleted(idx: i64, value: T) -> bool {
        self.write_entry(idx, value)
        self.size = self.size + 1
        self.tomb_count = self.tomb_count - 1
        return true
    }

    func remove_entry(idx: i64, existing: T, value: T) -> bool {
        if !existing.equals(value) {
            return false
        }

        self.buckets[idx] = Deleted
        self.size = self.size - 1
        self.tomb_count = self.tomb_count + 1
        return true
    }
}
